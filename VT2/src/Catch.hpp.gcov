        -:    0:Source:../Catch.hpp
        -:    0:Programs:2
        -:    1:
        -:    2:/*
        -:    3: *  Catch v1.6.0
        -:    4: *  Generated: 2017-01-11 16:38:09.405017
        -:    5: *  ----------------------------------------------------------
        -:    6: *  This file has been merged from multiple headers. Please don't edit it directly
        -:    7: *  Copyright (c) 2012 Two Blue Cubes Ltd. All rights reserved.
        -:    8: *
        -:    9: *  Distributed under the Boost Software License, Version 1.0. (See accompanying
        -:   10: *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
        -:   11: */
        -:   12:#ifndef TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED
        -:   13:#define TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED
        -:   14:
        -:   15:#define TWOBLUECUBES_CATCH_HPP_INCLUDED
        -:   16:
        -:   17:#ifdef __clang__
        -:   18:#    pragma clang system_header
        -:   19:#elif defined __GNUC__
        -:   20:#    pragma GCC system_header
        -:   21:#endif
        -:   22:
        -:   23:// #included from: internal/catch_suppress_warnings.h
        -:   24:
        -:   25:#ifdef __clang__
        -:   26:#   ifdef __ICC // icpc defines the __clang__ macro
        -:   27:#       pragma warning(push)
        -:   28:#       pragma warning(disable: 161 1682)
        -:   29:#   else // __ICC
        -:   30:#       pragma clang diagnostic ignored "-Wglobal-constructors"
        -:   31:#       pragma clang diagnostic ignored "-Wvariadic-macros"
        -:   32:#       pragma clang diagnostic ignored "-Wc99-extensions"
        -:   33:#       pragma clang diagnostic ignored "-Wunused-variable"
        -:   34:#       pragma clang diagnostic push
        -:   35:#       pragma clang diagnostic ignored "-Wpadded"
        -:   36:#       pragma clang diagnostic ignored "-Wc++98-compat"
        -:   37:#       pragma clang diagnostic ignored "-Wc++98-compat-pedantic"
        -:   38:#       pragma clang diagnostic ignored "-Wswitch-enum"
        -:   39:#       pragma clang diagnostic ignored "-Wcovered-switch-default"
        -:   40:#    endif
        -:   41:#elif defined __GNUC__
        -:   42:#    pragma GCC diagnostic ignored "-Wvariadic-macros"
        -:   43:#    pragma GCC diagnostic ignored "-Wunused-variable"
        -:   44:#    pragma GCC diagnostic push
        -:   45:#    pragma GCC diagnostic ignored "-Wpadded"
        -:   46:#endif
        -:   47:#if defined(CATCH_CONFIG_MAIN) || defined(CATCH_CONFIG_RUNNER)
        -:   48:#  define CATCH_IMPL
        -:   49:#endif
        -:   50:
        -:   51:#ifdef CATCH_IMPL
        -:   52:#  ifndef CLARA_CONFIG_MAIN
        -:   53:#    define CLARA_CONFIG_MAIN_NOT_DEFINED
        -:   54:#    define CLARA_CONFIG_MAIN
        -:   55:#  endif
        -:   56:#endif
        -:   57:
        -:   58:// #included from: internal/catch_notimplemented_exception.h
        -:   59:#define TWOBLUECUBES_CATCH_NOTIMPLEMENTED_EXCEPTION_H_INCLUDED
        -:   60:
        -:   61:// #included from: catch_common.h
        -:   62:#define TWOBLUECUBES_CATCH_COMMON_H_INCLUDED
        -:   63:
        -:   64:// #included from: catch_compiler_capabilities.h
        -:   65:#define TWOBLUECUBES_CATCH_COMPILER_CAPABILITIES_HPP_INCLUDED
        -:   66:
        -:   67:// Detect a number of compiler features - mostly C++11/14 conformance - by compiler
        -:   68:// The following features are defined:
        -:   69://
        -:   70:// CATCH_CONFIG_CPP11_NULLPTR : is nullptr supported?
        -:   71:// CATCH_CONFIG_CPP11_NOEXCEPT : is noexcept supported?
        -:   72:// CATCH_CONFIG_CPP11_GENERATED_METHODS : The delete and default keywords for compiler generated methods
        -:   73:// CATCH_CONFIG_CPP11_IS_ENUM : std::is_enum is supported?
        -:   74:// CATCH_CONFIG_CPP11_TUPLE : std::tuple is supported
        -:   75:// CATCH_CONFIG_CPP11_LONG_LONG : is long long supported?
        -:   76:// CATCH_CONFIG_CPP11_OVERRIDE : is override supported?
        -:   77:// CATCH_CONFIG_CPP11_UNIQUE_PTR : is unique_ptr supported (otherwise use auto_ptr)
        -:   78:
        -:   79:// CATCH_CONFIG_CPP11_OR_GREATER : Is C++11 supported?
        -:   80:
        -:   81:// CATCH_CONFIG_VARIADIC_MACROS : are variadic macros supported?
        -:   82:// CATCH_CONFIG_COUNTER : is the __COUNTER__ macro supported?
        -:   83:// ****************
        -:   84:// Note to maintainers: if new toggles are added please document them
        -:   85:// in configuration.md, too
        -:   86:// ****************
        -:   87:
        -:   88:// In general each macro has a _NO_<feature name> form
        -:   89:// (e.g. CATCH_CONFIG_CPP11_NO_NULLPTR) which disables the feature.
        -:   90:// Many features, at point of detection, define an _INTERNAL_ macro, so they
        -:   91:// can be combined, en-mass, with the _NO_ forms later.
        -:   92:
        -:   93:// All the C++11 features can be disabled with CATCH_CONFIG_NO_CPP11
        -:   94:
        -:   95:#ifdef __cplusplus
        -:   96:
        -:   97:#  if __cplusplus >= 201103L
        -:   98:#    define CATCH_CPP11_OR_GREATER
        -:   99:#  endif
        -:  100:
        -:  101:#  if __cplusplus >= 201402L
        -:  102:#    define CATCH_CPP14_OR_GREATER
        -:  103:#  endif
        -:  104:
        -:  105:#endif
        -:  106:
        -:  107:#ifdef __clang__
        -:  108:
        -:  109:#  if __has_feature(cxx_nullptr)
        -:  110:#    define CATCH_INTERNAL_CONFIG_CPP11_NULLPTR
        -:  111:#  endif
        -:  112:
        -:  113:#  if __has_feature(cxx_noexcept)
        -:  114:#    define CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT
        -:  115:#  endif
        -:  116:
        -:  117:#   if defined(CATCH_CPP11_OR_GREATER)
        -:  118:#       define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS _Pragma( "clang diagnostic ignored \"-Wparentheses\"" )
        -:  119:#   endif
        -:  120:
        -:  121:#endif // __clang__
        -:  122:
        -:  123:////////////////////////////////////////////////////////////////////////////////
        -:  124:// Borland
        -:  125:#ifdef __BORLANDC__
        -:  126:
        -:  127:#endif // __BORLANDC__
        -:  128:
        -:  129:////////////////////////////////////////////////////////////////////////////////
        -:  130:// EDG
        -:  131:#ifdef __EDG_VERSION__
        -:  132:
        -:  133:#endif // __EDG_VERSION__
        -:  134:
        -:  135:////////////////////////////////////////////////////////////////////////////////
        -:  136:// Digital Mars
        -:  137:#ifdef __DMC__
        -:  138:
        -:  139:#endif // __DMC__
        -:  140:
        -:  141:////////////////////////////////////////////////////////////////////////////////
        -:  142:// GCC
        -:  143:#ifdef __GNUC__
        -:  144:
        -:  145:#   if __GNUC__ == 4 && __GNUC_MINOR__ >= 6 && defined(__GXX_EXPERIMENTAL_CXX0X__)
        -:  146:#       define CATCH_INTERNAL_CONFIG_CPP11_NULLPTR
        -:  147:#   endif
        -:  148:
        -:  149:#   if !defined(CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS) && defined(CATCH_CPP11_OR_GREATER)
        -:  150:#       define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS _Pragma( "GCC diagnostic ignored \"-Wparentheses\"" )
        -:  151:#   endif
        -:  152:
        -:  153:// - otherwise more recent versions define __cplusplus >= 201103L
        -:  154:// and will get picked up below
        -:  155:
        -:  156:#endif // __GNUC__
        -:  157:
        -:  158:////////////////////////////////////////////////////////////////////////////////
        -:  159:// Visual C++
        -:  160:#ifdef _MSC_VER
        -:  161:
        -:  162:#if (_MSC_VER >= 1600)
        -:  163:#   define CATCH_INTERNAL_CONFIG_CPP11_NULLPTR
        -:  164:#   define CATCH_INTERNAL_CONFIG_CPP11_UNIQUE_PTR
        -:  165:#endif
        -:  166:
        -:  167:#if (_MSC_VER >= 1900 ) // (VC++ 13 (VS2015))
        -:  168:#define CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT
        -:  169:#define CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS
        -:  170:#define CATCH_INTERNAL_CONFIG_CPP11_SHUFFLE
        -:  171:#endif
        -:  172:
        -:  173:#endif // _MSC_VER
        -:  174:
        -:  175:////////////////////////////////////////////////////////////////////////////////
        -:  176:
        -:  177:// Use variadic macros if the compiler supports them
        -:  178:#if ( defined _MSC_VER && _MSC_VER > 1400 && !defined __EDGE__) || \
        -:  179:    ( defined __WAVE__ && __WAVE_HAS_VARIADICS ) || \
        -:  180:    ( defined __GNUC__ && __GNUC__ >= 3 ) || \
        -:  181:    ( !defined __cplusplus && __STDC_VERSION__ >= 199901L || __cplusplus >= 201103L )
        -:  182:
        -:  183:#define CATCH_INTERNAL_CONFIG_VARIADIC_MACROS
        -:  184:
        -:  185:#endif
        -:  186:
        -:  187:// Use __COUNTER__ if the compiler supports it
        -:  188:#if ( defined _MSC_VER && _MSC_VER >= 1300 ) || \
        -:  189:    ( defined __GNUC__  && __GNUC__ >= 4 && __GNUC_MINOR__ >= 3 ) || \
        -:  190:    ( defined __clang__ && __clang_major__ >= 3 )
        -:  191:
        -:  192:#define CATCH_INTERNAL_CONFIG_COUNTER
        -:  193:
        -:  194:#endif
        -:  195:
        -:  196:////////////////////////////////////////////////////////////////////////////////
        -:  197:// C++ language feature support
        -:  198:
        -:  199:// catch all support for C++11
        -:  200:#if defined(CATCH_CPP11_OR_GREATER)
        -:  201:
        -:  202:#  if !defined(CATCH_INTERNAL_CONFIG_CPP11_NULLPTR)
        -:  203:#    define CATCH_INTERNAL_CONFIG_CPP11_NULLPTR
        -:  204:#  endif
        -:  205:
        -:  206:#  ifndef CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT
        -:  207:#    define CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT
        -:  208:#  endif
        -:  209:
        -:  210:#  ifndef CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS
        -:  211:#    define CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS
        -:  212:#  endif
        -:  213:
        -:  214:#  ifndef CATCH_INTERNAL_CONFIG_CPP11_IS_ENUM
        -:  215:#    define CATCH_INTERNAL_CONFIG_CPP11_IS_ENUM
        -:  216:#  endif
        -:  217:
        -:  218:#  ifndef CATCH_INTERNAL_CONFIG_CPP11_TUPLE
        -:  219:#    define CATCH_INTERNAL_CONFIG_CPP11_TUPLE
        -:  220:#  endif
        -:  221:
        -:  222:#  ifndef CATCH_INTERNAL_CONFIG_VARIADIC_MACROS
        -:  223:#    define CATCH_INTERNAL_CONFIG_VARIADIC_MACROS
        -:  224:#  endif
        -:  225:
        -:  226:#  if !defined(CATCH_INTERNAL_CONFIG_CPP11_LONG_LONG)
        -:  227:#    define CATCH_INTERNAL_CONFIG_CPP11_LONG_LONG
        -:  228:#  endif
        -:  229:
        -:  230:#  if !defined(CATCH_INTERNAL_CONFIG_CPP11_OVERRIDE)
        -:  231:#    define CATCH_INTERNAL_CONFIG_CPP11_OVERRIDE
        -:  232:#  endif
        -:  233:#  if !defined(CATCH_INTERNAL_CONFIG_CPP11_UNIQUE_PTR)
        -:  234:#    define CATCH_INTERNAL_CONFIG_CPP11_UNIQUE_PTR
        -:  235:#  endif
        -:  236:# if !defined(CATCH_INTERNAL_CONFIG_CPP11_SHUFFLE)
        -:  237:#   define CATCH_INTERNAL_CONFIG_CPP11_SHUFFLE
        -:  238:#  endif
        -:  239:
        -:  240:#endif // __cplusplus >= 201103L
        -:  241:
        -:  242:// Now set the actual defines based on the above + anything the user has configured
        -:  243:#if defined(CATCH_INTERNAL_CONFIG_CPP11_NULLPTR) && !defined(CATCH_CONFIG_CPP11_NO_NULLPTR) && !defined(CATCH_CONFIG_CPP11_NULLPTR) && !defined(CATCH_CONFIG_NO_CPP11)
        -:  244:#   define CATCH_CONFIG_CPP11_NULLPTR
        -:  245:#endif
        -:  246:#if defined(CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT) && !defined(CATCH_CONFIG_CPP11_NO_NOEXCEPT) && !defined(CATCH_CONFIG_CPP11_NOEXCEPT) && !defined(CATCH_CONFIG_NO_CPP11)
        -:  247:#   define CATCH_CONFIG_CPP11_NOEXCEPT
        -:  248:#endif
        -:  249:#if defined(CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS) && !defined(CATCH_CONFIG_CPP11_NO_GENERATED_METHODS) && !defined(CATCH_CONFIG_CPP11_GENERATED_METHODS) && !defined(CATCH_CONFIG_NO_CPP11)
        -:  250:#   define CATCH_CONFIG_CPP11_GENERATED_METHODS
        -:  251:#endif
        -:  252:#if defined(CATCH_INTERNAL_CONFIG_CPP11_IS_ENUM) && !defined(CATCH_CONFIG_CPP11_NO_IS_ENUM) && !defined(CATCH_CONFIG_CPP11_IS_ENUM) && !defined(CATCH_CONFIG_NO_CPP11)
        -:  253:#   define CATCH_CONFIG_CPP11_IS_ENUM
        -:  254:#endif
        -:  255:#if defined(CATCH_INTERNAL_CONFIG_CPP11_TUPLE) && !defined(CATCH_CONFIG_CPP11_NO_TUPLE) && !defined(CATCH_CONFIG_CPP11_TUPLE) && !defined(CATCH_CONFIG_NO_CPP11)
        -:  256:#   define CATCH_CONFIG_CPP11_TUPLE
        -:  257:#endif
        -:  258:#if defined(CATCH_INTERNAL_CONFIG_VARIADIC_MACROS) && !defined(CATCH_CONFIG_NO_VARIADIC_MACROS) && !defined(CATCH_CONFIG_VARIADIC_MACROS)
        -:  259:#   define CATCH_CONFIG_VARIADIC_MACROS
        -:  260:#endif
        -:  261:#if defined(CATCH_INTERNAL_CONFIG_CPP11_LONG_LONG) && !defined(CATCH_CONFIG_CPP11_NO_LONG_LONG) && !defined(CATCH_CONFIG_CPP11_LONG_LONG) && !defined(CATCH_CONFIG_NO_CPP11)
        -:  262:#   define CATCH_CONFIG_CPP11_LONG_LONG
        -:  263:#endif
        -:  264:#if defined(CATCH_INTERNAL_CONFIG_CPP11_OVERRIDE) && !defined(CATCH_CONFIG_CPP11_NO_OVERRIDE) && !defined(CATCH_CONFIG_CPP11_OVERRIDE) && !defined(CATCH_CONFIG_NO_CPP11)
        -:  265:#   define CATCH_CONFIG_CPP11_OVERRIDE
        -:  266:#endif
        -:  267:#if defined(CATCH_INTERNAL_CONFIG_CPP11_UNIQUE_PTR) && !defined(CATCH_CONFIG_CPP11_NO_UNIQUE_PTR) && !defined(CATCH_CONFIG_CPP11_UNIQUE_PTR) && !defined(CATCH_CONFIG_NO_CPP11)
        -:  268:#   define CATCH_CONFIG_CPP11_UNIQUE_PTR
        -:  269:#endif
        -:  270:#if defined(CATCH_INTERNAL_CONFIG_COUNTER) && !defined(CATCH_CONFIG_NO_COUNTER) && !defined(CATCH_CONFIG_COUNTER)
        -:  271:#   define CATCH_CONFIG_COUNTER
        -:  272:#endif
        -:  273:#if defined(CATCH_INTERNAL_CONFIG_CPP11_SHUFFLE) && !defined(CATCH_CONFIG_CPP11_NO_SHUFFLE) && !defined(CATCH_CONFIG_CPP11_SHUFFLE) && !defined(CATCH_CONFIG_NO_CPP11)
        -:  274:#   define CATCH_CONFIG_CPP11_SHUFFLE
        -:  275:#endif
        -:  276:
        -:  277:#if !defined(CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS)
        -:  278:#   define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS
        -:  279:#endif
        -:  280:
        -:  281:// noexcept support:
        -:  282:#if defined(CATCH_CONFIG_CPP11_NOEXCEPT) && !defined(CATCH_NOEXCEPT)
        -:  283:#  define CATCH_NOEXCEPT noexcept
        -:  284:#  define CATCH_NOEXCEPT_IS(x) noexcept(x)
        -:  285:#else
        -:  286:#  define CATCH_NOEXCEPT throw()
        -:  287:#  define CATCH_NOEXCEPT_IS(x)
        -:  288:#endif
        -:  289:
        -:  290:// nullptr support
        -:  291:#ifdef CATCH_CONFIG_CPP11_NULLPTR
        -:  292:#   define CATCH_NULL nullptr
        -:  293:#else
        -:  294:#   define CATCH_NULL NULL
        -:  295:#endif
        -:  296:
        -:  297:// override support
        -:  298:#ifdef CATCH_CONFIG_CPP11_OVERRIDE
        -:  299:#   define CATCH_OVERRIDE override
        -:  300:#else
        -:  301:#   define CATCH_OVERRIDE
        -:  302:#endif
        -:  303:
        -:  304:// unique_ptr support
        -:  305:#ifdef CATCH_CONFIG_CPP11_UNIQUE_PTR
        -:  306:#   define CATCH_AUTO_PTR( T ) std::unique_ptr<T>
        -:  307:#else
        -:  308:#   define CATCH_AUTO_PTR( T ) std::auto_ptr<T>
        -:  309:#endif
        -:  310:
        -:  311:#define INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line ) name##line
        -:  312:#define INTERNAL_CATCH_UNIQUE_NAME_LINE( name, line ) INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line )
        -:  313:#ifdef CATCH_CONFIG_COUNTER
        -:  314:#  define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __COUNTER__ )
        -:  315:#else
        -:  316:#  define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __LINE__ )
        -:  317:#endif
        -:  318:
        -:  319:#define INTERNAL_CATCH_STRINGIFY2( expr ) #expr
        -:  320:#define INTERNAL_CATCH_STRINGIFY( expr ) INTERNAL_CATCH_STRINGIFY2( expr )
        -:  321:
        -:  322:#include <sstream>
        -:  323:#include <stdexcept>
        -:  324:#include <algorithm>
        -:  325:
        -:  326:namespace Catch {
        -:  327:
        -:  328:    struct IConfig;
        -:  329:
        -:  330:    struct CaseSensitive { enum Choice {
        -:  331:        Yes,
        -:  332:        No
        -:  333:    }; };
        -:  334:
        -:  335:    class NonCopyable {
        -:  336:#ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
        -:  337:        NonCopyable( NonCopyable const& )              = delete;
        -:  338:        NonCopyable( NonCopyable && )                  = delete;
        -:  339:        NonCopyable& operator = ( NonCopyable const& ) = delete;
        -:  340:        NonCopyable& operator = ( NonCopyable && )     = delete;
        -:  341:#else
        -:  342:        NonCopyable( NonCopyable const& info );
        -:  343:        NonCopyable& operator = ( NonCopyable const& );
        -:  344:#endif
        -:  345:
        -:  346:    protected:
        9:  347:        NonCopyable() {}
        -:  348:        virtual ~NonCopyable();
        -:  349:    };
        -:  350:
        -:  351:    class SafeBool {
        -:  352:    public:
        -:  353:        typedef void (SafeBool::*type)() const;
        -:  354:
        3:  355:        static type makeSafe( bool value ) {
        3:  356:            return value ? &SafeBool::trueValue : 0;
        -:  357:        }
        -:  358:    private:
    #####:  359:        void trueValue() const {}
        -:  360:    };
        -:  361:
        -:  362:    template<typename ContainerT>
        1:  363:    inline void deleteAll( ContainerT& container ) {
        1:  364:        typename ContainerT::const_iterator it = container.begin();
        1:  365:        typename ContainerT::const_iterator itEnd = container.end();
        1:  366:        for(; it != itEnd; ++it )
    #####:  367:            delete *it;
        1:  368:    }
        -:  369:    template<typename AssociativeContainerT>
        -:  370:    inline void deleteAllValues( AssociativeContainerT& container ) {
        -:  371:        typename AssociativeContainerT::const_iterator it = container.begin();
        -:  372:        typename AssociativeContainerT::const_iterator itEnd = container.end();
        -:  373:        for(; it != itEnd; ++it )
        -:  374:            delete it->second;
        -:  375:    }
        -:  376:
        -:  377:    bool startsWith( std::string const& s, std::string const& prefix );
        -:  378:    bool endsWith( std::string const& s, std::string const& suffix );
        -:  379:    bool contains( std::string const& s, std::string const& infix );
        -:  380:    void toLowerInPlace( std::string& s );
        -:  381:    std::string toLower( std::string const& s );
        -:  382:    std::string trim( std::string const& str );
        -:  383:    bool replaceInPlace( std::string& str, std::string const& replaceThis, std::string const& withThis );
        -:  384:
    #####:  385:    struct pluralise {
        -:  386:        pluralise( std::size_t count, std::string const& label );
        -:  387:
        -:  388:        friend std::ostream& operator << ( std::ostream& os, pluralise const& pluraliser );
        -:  389:
        -:  390:        std::size_t m_count;
        -:  391:        std::string m_label;
        -:  392:    };
        -:  393:
        2:  394:    struct SourceLineInfo {
        -:  395:
        -:  396:        SourceLineInfo();
        -:  397:        SourceLineInfo( char const* _file, std::size_t _line );
        -:  398:        SourceLineInfo( SourceLineInfo const& other );
        -:  399:#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
    #####:  400:        SourceLineInfo( SourceLineInfo && )                  = default;
        -:  401:        SourceLineInfo& operator = ( SourceLineInfo const& ) = default;
        -:  402:        SourceLineInfo& operator = ( SourceLineInfo && )     = default;
        -:  403:#  endif
        -:  404:        bool empty() const;
        -:  405:        bool operator == ( SourceLineInfo const& other ) const;
        -:  406:        bool operator < ( SourceLineInfo const& other ) const;
        -:  407:
        -:  408:        std::string file;
        -:  409:        std::size_t line;
        -:  410:    };
        -:  411:
        -:  412:    std::ostream& operator << ( std::ostream& os, SourceLineInfo const& info );
        -:  413:
        -:  414:    // This is just here to avoid compiler warnings with macro constants and boolean literals
        -:  415:    inline bool isTrue( bool value ){ return value; }
    #####:  416:    inline bool alwaysTrue() { return true; }
        -:  417:    inline bool alwaysFalse() { return false; }
        -:  418:
        -:  419:    void throwLogicError( std::string const& message, SourceLineInfo const& locationInfo );
        -:  420:
        -:  421:    void seedRng( IConfig const& config );
        -:  422:    unsigned int rngSeed();
        -:  423:
        -:  424:    // Use this in variadic streaming macros to allow
        -:  425:    //    >> +StreamEndStop
        -:  426:    // as well as
        -:  427:    //    >> stuff +StreamEndStop
        -:  428:    struct StreamEndStop {
        -:  429:        std::string operator+() {
        -:  430:            return std::string();
        -:  431:        }
        -:  432:    };
        -:  433:    template<typename T>
        -:  434:    T const& operator + ( T const& value, StreamEndStop ) {
        -:  435:        return value;
        -:  436:    }
        -:  437:}
        -:  438:
        -:  439:#define CATCH_INTERNAL_LINEINFO ::Catch::SourceLineInfo( __FILE__, static_cast<std::size_t>( __LINE__ ) )
        -:  440:#define CATCH_INTERNAL_ERROR( msg ) ::Catch::throwLogicError( msg, CATCH_INTERNAL_LINEINFO );
        -:  441:
        -:  442:#include <ostream>
        -:  443:
        -:  444:namespace Catch {
        -:  445:
        -:  446:    class NotImplementedException : public std::exception
        -:  447:    {
        -:  448:    public:
        -:  449:        NotImplementedException( SourceLineInfo const& lineInfo );
        -:  450:        NotImplementedException( NotImplementedException const& ) {}
        -:  451:
    #####:  452:        virtual ~NotImplementedException() CATCH_NOEXCEPT {}
        -:  453:
        -:  454:        virtual const char* what() const CATCH_NOEXCEPT;
        -:  455:
        -:  456:    private:
        -:  457:        std::string m_what;
        -:  458:        SourceLineInfo m_lineInfo;
        -:  459:    };
        -:  460:
        -:  461:} // end namespace Catch
        -:  462:
        -:  463:///////////////////////////////////////////////////////////////////////////////
        -:  464:#define CATCH_NOT_IMPLEMENTED throw Catch::NotImplementedException( CATCH_INTERNAL_LINEINFO )
        -:  465:
        -:  466:// #included from: internal/catch_context.h
        -:  467:#define TWOBLUECUBES_CATCH_CONTEXT_H_INCLUDED
        -:  468:
        -:  469:// #included from: catch_interfaces_generators.h
        -:  470:#define TWOBLUECUBES_CATCH_INTERFACES_GENERATORS_H_INCLUDED
        -:  471:
        -:  472:#include <string>
        -:  473:
        -:  474:namespace Catch {
        -:  475:
    #####:  476:    struct IGeneratorInfo {
        -:  477:        virtual ~IGeneratorInfo();
        -:  478:        virtual bool moveNext() = 0;
        -:  479:        virtual std::size_t getCurrentIndex() const = 0;
        -:  480:    };
        -:  481:
    #####:  482:    struct IGeneratorsForTest {
        -:  483:        virtual ~IGeneratorsForTest();
        -:  484:
        -:  485:        virtual IGeneratorInfo& getGeneratorInfo( std::string const& fileInfo, std::size_t size ) = 0;
        -:  486:        virtual bool moveNext() = 0;
        -:  487:    };
        -:  488:
        -:  489:    IGeneratorsForTest* createGeneratorsForTest();
        -:  490:
        -:  491:} // end namespace Catch
        -:  492:
        -:  493:// #included from: catch_ptr.hpp
        -:  494:#define TWOBLUECUBES_CATCH_PTR_HPP_INCLUDED
        -:  495:
        -:  496:#ifdef __clang__
        -:  497:#pragma clang diagnostic push
        -:  498:#pragma clang diagnostic ignored "-Wpadded"
        -:  499:#endif
        -:  500:
        -:  501:namespace Catch {
        -:  502:
        -:  503:    // An intrusive reference counting smart pointer.
        -:  504:    // T must implement addRef() and release() methods
        -:  505:    // typically implementing the IShared interface
        -:  506:    template<typename T>
        -:  507:    class Ptr {
        -:  508:    public:
        4:  509:        Ptr() : m_p( CATCH_NULL ){}
       11:  510:        Ptr( T* p ) : m_p( p ){
       11:  511:            if( m_p )
       10:  512:                m_p->addRef();
       11:  513:        }
       23:  514:        Ptr( Ptr const& other ) : m_p( other.m_p ){
       23:  515:            if( m_p )
       23:  516:                m_p->addRef();
       23:  517:        }
       38:  518:        ~Ptr(){
       38:  519:            if( m_p )
       33:  520:                m_p->release();
       38:  521:        }
        1:  522:        void reset() {
        1:  523:            if( m_p )
    #####:  524:                m_p->release();
        1:  525:            m_p = CATCH_NULL;
        1:  526:        }
        2:  527:        Ptr& operator = ( T* p ){
        4:  528:            Ptr temp( p );
        2:  529:            swap( temp );
        4:  530:            return *this;
        -:  531:        }
        4:  532:        Ptr& operator = ( Ptr const& other ){
        8:  533:            Ptr temp( other );
        4:  534:            swap( temp );
        8:  535:            return *this;
        -:  536:        }
        6:  537:        void swap( Ptr& other ) { std::swap( m_p, other.m_p ); }
        2:  538:        T* get() const{ return m_p; }
        4:  539:        T& operator*() const { return *m_p; }
       14:  540:        T* operator->() const { return m_p; }
        3:  541:        bool operator !() const { return m_p == CATCH_NULL; }
        2:  542:        operator SafeBool::type() const { return SafeBool::makeSafe( m_p != CATCH_NULL ); }
        -:  543:
        -:  544:    private:
        -:  545:        T* m_p;
        -:  546:    };
        -:  547:
        8:  548:    struct IShared : NonCopyable {
        -:  549:        virtual ~IShared();
        -:  550:        virtual void addRef() const = 0;
        -:  551:        virtual void release() const = 0;
        -:  552:    };
        -:  553:
        -:  554:    template<typename T = IShared>
        8:  555:    struct SharedImpl : T {
        -:  556:
        8:  557:        SharedImpl() : m_rc( 0 ){}
        -:  558:
       33:  559:        virtual void addRef() const {
       33:  560:            ++m_rc;
       33:  561:        }
       33:  562:        virtual void release() const {
       33:  563:            if( --m_rc == 0 )
        8:  564:                delete this;
       33:  565:        }
        -:  566:
        -:  567:        mutable unsigned int m_rc;
        -:  568:    };
        -:  569:
        -:  570:} // end namespace Catch
        -:  571:
        -:  572:#ifdef __clang__
        -:  573:#pragma clang diagnostic pop
        -:  574:#endif
        -:  575:
        -:  576:#include <memory>
        -:  577:#include <vector>
        -:  578:#include <stdlib.h>
        -:  579:
        -:  580:namespace Catch {
        -:  581:
        -:  582:    class TestCase;
        -:  583:    class Stream;
        -:  584:    struct IResultCapture;
        -:  585:    struct IRunner;
        -:  586:    struct IGeneratorsForTest;
        -:  587:    struct IConfig;
        -:  588:
        1:  589:    struct IContext
        -:  590:    {
        -:  591:        virtual ~IContext();
        -:  592:
        -:  593:        virtual IResultCapture* getResultCapture() = 0;
        -:  594:        virtual IRunner* getRunner() = 0;
        -:  595:        virtual size_t getGeneratorIndex( std::string const& fileInfo, size_t totalSize ) = 0;
        -:  596:        virtual bool advanceGeneratorsForCurrentTest() = 0;
        -:  597:        virtual Ptr<IConfig const> getConfig() const = 0;
        -:  598:    };
        -:  599:
        1:  600:    struct IMutableContext : IContext
        -:  601:    {
        -:  602:        virtual ~IMutableContext();
        -:  603:        virtual void setResultCapture( IResultCapture* resultCapture ) = 0;
        -:  604:        virtual void setRunner( IRunner* runner ) = 0;
        -:  605:        virtual void setConfig( Ptr<IConfig const> const& config ) = 0;
        -:  606:    };
        -:  607:
        -:  608:    IContext& getCurrentContext();
        -:  609:    IMutableContext& getCurrentMutableContext();
        -:  610:    void cleanUpContext();
        -:  611:    Stream createStream( std::string const& streamName );
        -:  612:
        -:  613:}
        -:  614:
        -:  615:// #included from: internal/catch_test_registry.hpp
        -:  616:#define TWOBLUECUBES_CATCH_TEST_REGISTRY_HPP_INCLUDED
        -:  617:
        -:  618:// #included from: catch_interfaces_testcase.h
        -:  619:#define TWOBLUECUBES_CATCH_INTERFACES_TESTCASE_H_INCLUDED
        -:  620:
        -:  621:#include <vector>
        -:  622:
        -:  623:namespace Catch {
        -:  624:
        -:  625:    class TestSpec;
        -:  626:
    #####:  627:    struct ITestCase : IShared {
        -:  628:        virtual void invoke () const = 0;
        -:  629:    protected:
        -:  630:        virtual ~ITestCase();
        -:  631:    };
        -:  632:
        -:  633:    class TestCase;
        -:  634:    struct IConfig;
        -:  635:
        1:  636:    struct ITestCaseRegistry {
        -:  637:        virtual ~ITestCaseRegistry();
        -:  638:        virtual std::vector<TestCase> const& getAllTests() const = 0;
        -:  639:        virtual std::vector<TestCase> const& getAllTestsSorted( IConfig const& config ) const = 0;
        -:  640:    };
        -:  641:
        -:  642:    bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config );
        -:  643:    std::vector<TestCase> filterTests( std::vector<TestCase> const& testCases, TestSpec const& testSpec, IConfig const& config );
        -:  644:    std::vector<TestCase> const& getAllTestCasesSorted( IConfig const& config );
        -:  645:
        -:  646:}
        -:  647:
        -:  648:namespace Catch {
        -:  649:
        -:  650:template<typename C>
        -:  651:class MethodTestCase : public SharedImpl<ITestCase> {
        -:  652:
        -:  653:public:
        -:  654:    MethodTestCase( void (C::*method)() ) : m_method( method ) {}
        -:  655:
        -:  656:    virtual void invoke() const {
        -:  657:        C obj;
        -:  658:        (obj.*m_method)();
        -:  659:    }
        -:  660:
        -:  661:private:
        -:  662:    virtual ~MethodTestCase() {}
        -:  663:
        -:  664:    void (C::*m_method)();
        -:  665:};
        -:  666:
        -:  667:typedef void(*TestFunction)();
        -:  668:
        -:  669:struct NameAndDesc {
        -:  670:    NameAndDesc( const char* _name = "", const char* _description= "" )
        -:  671:    : name( _name ), description( _description )
        -:  672:    {}
        -:  673:
        -:  674:    const char* name;
        -:  675:    const char* description;
        -:  676:};
        -:  677:
        -:  678:void registerTestCase
        -:  679:    (   ITestCase* testCase,
        -:  680:        char const* className,
        -:  681:        NameAndDesc const& nameAndDesc,
        -:  682:        SourceLineInfo const& lineInfo );
        -:  683:
        -:  684:struct AutoReg {
        -:  685:
        -:  686:    AutoReg
        -:  687:        (   TestFunction function,
        -:  688:            SourceLineInfo const& lineInfo,
        -:  689:            NameAndDesc const& nameAndDesc );
        -:  690:
        -:  691:    template<typename C>
        -:  692:    AutoReg
        -:  693:        (   void (C::*method)(),
        -:  694:            char const* className,
        -:  695:            NameAndDesc const& nameAndDesc,
        -:  696:            SourceLineInfo const& lineInfo ) {
        -:  697:
        -:  698:        registerTestCase
        -:  699:            (   new MethodTestCase<C>( method ),
        -:  700:                className,
        -:  701:                nameAndDesc,
        -:  702:                lineInfo );
        -:  703:    }
        -:  704:
        -:  705:    ~AutoReg();
        -:  706:
        -:  707:private:
        -:  708:    AutoReg( AutoReg const& );
        -:  709:    void operator= ( AutoReg const& );
        -:  710:};
        -:  711:
        -:  712:void registerTestCaseFunction
        -:  713:    (   TestFunction function,
        -:  714:        SourceLineInfo const& lineInfo,
        -:  715:        NameAndDesc const& nameAndDesc );
        -:  716:
        -:  717:} // end namespace Catch
        -:  718:
        -:  719:#ifdef CATCH_CONFIG_VARIADIC_MACROS
        -:  720:    ///////////////////////////////////////////////////////////////////////////////
        -:  721:    #define INTERNAL_CATCH_TESTCASE2( TestName, ... ) \
        -:  722:        static void TestName(); \
        -:  723:        namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( &TestName, CATCH_INTERNAL_LINEINFO, Catch::NameAndDesc( __VA_ARGS__ ) ); }\
        -:  724:        static void TestName()
        -:  725:    #define INTERNAL_CATCH_TESTCASE( ... ) \
        -:  726:        INTERNAL_CATCH_TESTCASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), __VA_ARGS__ )
        -:  727:
        -:  728:    ///////////////////////////////////////////////////////////////////////////////
        -:  729:    #define INTERNAL_CATCH_METHOD_AS_TEST_CASE( QualifiedMethod, ... ) \
        -:  730:        namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( &QualifiedMethod, "&" #QualifiedMethod, Catch::NameAndDesc( __VA_ARGS__ ), CATCH_INTERNAL_LINEINFO ); }
        -:  731:
        -:  732:    ///////////////////////////////////////////////////////////////////////////////
        -:  733:    #define INTERNAL_CATCH_TEST_CASE_METHOD2( TestName, ClassName, ... )\
        -:  734:        namespace{ \
        -:  735:            struct TestName : ClassName{ \
        -:  736:                void test(); \
        -:  737:            }; \
        -:  738:            Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar ) ( &TestName::test, #ClassName, Catch::NameAndDesc( __VA_ARGS__ ), CATCH_INTERNAL_LINEINFO ); \
        -:  739:        } \
        -:  740:        void TestName::test()
        -:  741:    #define INTERNAL_CATCH_TEST_CASE_METHOD( ClassName, ... ) \
        -:  742:        INTERNAL_CATCH_TEST_CASE_METHOD2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), ClassName, __VA_ARGS__ )
        -:  743:
        -:  744:    ///////////////////////////////////////////////////////////////////////////////
        -:  745:    #define INTERNAL_CATCH_REGISTER_TESTCASE( Function, ... ) \
        -:  746:        Catch::AutoReg( Function, CATCH_INTERNAL_LINEINFO, Catch::NameAndDesc( __VA_ARGS__ ) );
        -:  747:
        -:  748:#else
        -:  749:    ///////////////////////////////////////////////////////////////////////////////
        -:  750:    #define INTERNAL_CATCH_TESTCASE2( TestName, Name, Desc ) \
        -:  751:        static void TestName(); \
        -:  752:        namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( &TestName, CATCH_INTERNAL_LINEINFO, Catch::NameAndDesc( Name, Desc ) ); }\
        -:  753:        static void TestName()
        -:  754:    #define INTERNAL_CATCH_TESTCASE( Name, Desc ) \
        -:  755:        INTERNAL_CATCH_TESTCASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), Name, Desc )
        -:  756:
        -:  757:    ///////////////////////////////////////////////////////////////////////////////
        -:  758:    #define INTERNAL_CATCH_METHOD_AS_TEST_CASE( QualifiedMethod, Name, Desc ) \
        -:  759:        namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( &QualifiedMethod, "&" #QualifiedMethod, Catch::NameAndDesc( Name, Desc ), CATCH_INTERNAL_LINEINFO ); }
        -:  760:
        -:  761:    ///////////////////////////////////////////////////////////////////////////////
        -:  762:    #define INTERNAL_CATCH_TEST_CASE_METHOD2( TestCaseName, ClassName, TestName, Desc )\
        -:  763:        namespace{ \
        -:  764:            struct TestCaseName : ClassName{ \
        -:  765:                void test(); \
        -:  766:            }; \
        -:  767:            Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar ) ( &TestCaseName::test, #ClassName, Catch::NameAndDesc( TestName, Desc ), CATCH_INTERNAL_LINEINFO ); \
        -:  768:        } \
        -:  769:        void TestCaseName::test()
        -:  770:    #define INTERNAL_CATCH_TEST_CASE_METHOD( ClassName, TestName, Desc )\
        -:  771:        INTERNAL_CATCH_TEST_CASE_METHOD2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), ClassName, TestName, Desc )
        -:  772:
        -:  773:    ///////////////////////////////////////////////////////////////////////////////
        -:  774:    #define INTERNAL_CATCH_REGISTER_TESTCASE( Function, Name, Desc ) \
        -:  775:        Catch::AutoReg( Function, CATCH_INTERNAL_LINEINFO, Catch::NameAndDesc( Name, Desc ) );
        -:  776:#endif
        -:  777:
        -:  778:// #included from: internal/catch_capture.hpp
        -:  779:#define TWOBLUECUBES_CATCH_CAPTURE_HPP_INCLUDED
        -:  780:
        -:  781:// #included from: catch_result_builder.h
        -:  782:#define TWOBLUECUBES_CATCH_RESULT_BUILDER_H_INCLUDED
        -:  783:
        -:  784:// #included from: catch_result_type.h
        -:  785:#define TWOBLUECUBES_CATCH_RESULT_TYPE_H_INCLUDED
        -:  786:
        -:  787:namespace Catch {
        -:  788:
        -:  789:    // ResultWas::OfType enum
        -:  790:    struct ResultWas { enum OfType {
        -:  791:        Unknown = -1,
        -:  792:        Ok = 0,
        -:  793:        Info = 1,
        -:  794:        Warning = 2,
        -:  795:
        -:  796:        FailureBit = 0x10,
        -:  797:
        -:  798:        ExpressionFailed = FailureBit | 1,
        -:  799:        ExplicitFailure = FailureBit | 2,
        -:  800:
        -:  801:        Exception = 0x100 | FailureBit,
        -:  802:
        -:  803:        ThrewException = Exception | 1,
        -:  804:        DidntThrowException = Exception | 2,
        -:  805:
        -:  806:        FatalErrorCondition = 0x200 | FailureBit
        -:  807:
        -:  808:    }; };
        -:  809:
    #####:  810:    inline bool isOk( ResultWas::OfType resultType ) {
    #####:  811:        return ( resultType & ResultWas::FailureBit ) == 0;
        -:  812:    }
        -:  813:    inline bool isJustInfo( int flags ) {
        -:  814:        return flags == ResultWas::Info;
        -:  815:    }
        -:  816:
        -:  817:    // ResultDisposition::Flags enum
        -:  818:    struct ResultDisposition { enum Flags {
        -:  819:        Normal = 0x01,
        -:  820:
        -:  821:        ContinueOnFailure = 0x02,   // Failures fail test, but execution continues
        -:  822:        FalseTest = 0x04,           // Prefix expression with !
        -:  823:        SuppressFail = 0x08         // Failures are reported but do not fail the test
        -:  824:    }; };
        -:  825:
        -:  826:    inline ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs ) {
        -:  827:        return static_cast<ResultDisposition::Flags>( static_cast<int>( lhs ) | static_cast<int>( rhs ) );
        -:  828:    }
        -:  829:
        -:  830:    inline bool shouldContinueOnFailure( int flags )    { return ( flags & ResultDisposition::ContinueOnFailure ) != 0; }
    #####:  831:    inline bool isFalseTest( int flags )                { return ( flags & ResultDisposition::FalseTest ) != 0; }
    #####:  832:    inline bool shouldSuppressFailure( int flags )      { return ( flags & ResultDisposition::SuppressFail ) != 0; }
        -:  833:
        -:  834:} // end namespace Catch
        -:  835:
        -:  836:// #included from: catch_assertionresult.h
        -:  837:#define TWOBLUECUBES_CATCH_ASSERTIONRESULT_H_INCLUDED
        -:  838:
        -:  839:#include <string>
        -:  840:
        -:  841:namespace Catch {
        -:  842:
        2:  843:    struct AssertionInfo
        -:  844:    {
        2:  845:        AssertionInfo() {}
        -:  846:        AssertionInfo(  std::string const& _macroName,
        -:  847:                        SourceLineInfo const& _lineInfo,
        -:  848:                        std::string const& _capturedExpression,
        -:  849:                        ResultDisposition::Flags _resultDisposition );
        -:  850:
        -:  851:        std::string macroName;
        -:  852:        SourceLineInfo lineInfo;
        -:  853:        std::string capturedExpression;
        -:  854:        ResultDisposition::Flags resultDisposition;
        -:  855:    };
        -:  856:
        1:  857:    struct AssertionResultData
        -:  858:    {
        1:  859:        AssertionResultData() : resultType( ResultWas::Unknown ) {}
        -:  860:
        -:  861:        std::string reconstructedExpression;
        -:  862:        std::string message;
        -:  863:        ResultWas::OfType resultType;
        -:  864:    };
        -:  865:
    #####:  866:    class AssertionResult {
        -:  867:    public:
        -:  868:        AssertionResult();
        -:  869:        AssertionResult( AssertionInfo const& info, AssertionResultData const& data );
        -:  870:        ~AssertionResult();
        -:  871:#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
    #####:  872:         AssertionResult( AssertionResult const& )              = default;
    #####:  873:         AssertionResult( AssertionResult && )                  = default;
        -:  874:         AssertionResult& operator = ( AssertionResult const& ) = default;
        -:  875:         AssertionResult& operator = ( AssertionResult && )     = default;
        -:  876:#  endif
        -:  877:
        -:  878:        bool isOk() const;
        -:  879:        bool succeeded() const;
        -:  880:        ResultWas::OfType getResultType() const;
        -:  881:        bool hasExpression() const;
        -:  882:        bool hasMessage() const;
        -:  883:        std::string getExpression() const;
        -:  884:        std::string getExpressionInMacro() const;
        -:  885:        bool hasExpandedExpression() const;
        -:  886:        std::string getExpandedExpression() const;
        -:  887:        std::string getMessage() const;
        -:  888:        SourceLineInfo getSourceInfo() const;
        -:  889:        std::string getTestMacroName() const;
        -:  890:
        -:  891:    protected:
        -:  892:        AssertionInfo m_info;
        -:  893:        AssertionResultData m_resultData;
        -:  894:    };
        -:  895:
        -:  896:} // end namespace Catch
        -:  897:
        -:  898:// #included from: catch_matchers.hpp
        -:  899:#define TWOBLUECUBES_CATCH_MATCHERS_HPP_INCLUDED
        -:  900:
        -:  901:namespace Catch {
        -:  902:namespace Matchers {
        -:  903:    namespace Impl {
        -:  904:
        -:  905:    namespace Generic {
        -:  906:        template<typename ExpressionT> class AllOf;
        -:  907:        template<typename ExpressionT> class AnyOf;
        -:  908:        template<typename ExpressionT> class Not;
        -:  909:    }
        -:  910:
        -:  911:    template<typename ExpressionT>
    #####:  912:    struct Matcher : SharedImpl<IShared>
        -:  913:    {
        -:  914:        typedef ExpressionT ExpressionType;
        -:  915:
    #####:  916:        virtual ~Matcher() {}
        -:  917:        virtual Ptr<Matcher> clone() const = 0;
        -:  918:        virtual bool match( ExpressionT const& expr ) const = 0;
        -:  919:        virtual std::string toString() const = 0;
        -:  920:
        -:  921:        Generic::AllOf<ExpressionT> operator && ( Matcher<ExpressionT> const& other ) const;
        -:  922:        Generic::AnyOf<ExpressionT> operator || ( Matcher<ExpressionT> const& other ) const;
        -:  923:        Generic::Not<ExpressionT> operator ! () const;
        -:  924:    };
        -:  925:
        -:  926:    template<typename DerivedT, typename ExpressionT>
    #####:  927:    struct MatcherImpl : Matcher<ExpressionT> {
        -:  928:
    #####:  929:        virtual Ptr<Matcher<ExpressionT> > clone() const {
    #####:  930:            return Ptr<Matcher<ExpressionT> >( new DerivedT( static_cast<DerivedT const&>( *this ) ) );
        -:  931:        }
        -:  932:    };
        -:  933:
        -:  934:    namespace Generic {
        -:  935:        template<typename ExpressionT>
        -:  936:        class Not : public MatcherImpl<Not<ExpressionT>, ExpressionT> {
        -:  937:        public:
        -:  938:            explicit Not( Matcher<ExpressionT> const& matcher ) : m_matcher(matcher.clone()) {}
        -:  939:            Not( Not const& other ) : m_matcher( other.m_matcher ) {}
        -:  940:
        -:  941:            virtual bool match( ExpressionT const& expr ) const CATCH_OVERRIDE {
        -:  942:                return !m_matcher->match( expr );
        -:  943:            }
        -:  944:
        -:  945:            virtual std::string toString() const CATCH_OVERRIDE {
        -:  946:                return "not " + m_matcher->toString();
        -:  947:            }
        -:  948:        private:
        -:  949:            Ptr< Matcher<ExpressionT> > m_matcher;
        -:  950:        };
        -:  951:
        -:  952:        template<typename ExpressionT>
    #####:  953:        class AllOf : public MatcherImpl<AllOf<ExpressionT>, ExpressionT> {
        -:  954:        public:
        -:  955:
    #####:  956:            AllOf() {}
    #####:  957:            AllOf( AllOf const& other ) : m_matchers( other.m_matchers ) {}
        -:  958:
        -:  959:            AllOf& add( Matcher<ExpressionT> const& matcher ) {
        -:  960:                m_matchers.push_back( matcher.clone() );
        -:  961:                return *this;
        -:  962:            }
    #####:  963:            virtual bool match( ExpressionT const& expr ) const
        -:  964:            {
    #####:  965:                for( std::size_t i = 0; i < m_matchers.size(); ++i )
    #####:  966:                    if( !m_matchers[i]->match( expr ) )
    #####:  967:                        return false;
    #####:  968:                return true;
        -:  969:            }
    #####:  970:            virtual std::string toString() const {
    #####:  971:                std::ostringstream oss;
    #####:  972:                oss << "( ";
    #####:  973:                for( std::size_t i = 0; i < m_matchers.size(); ++i ) {
    #####:  974:                    if( i != 0 )
    #####:  975:                        oss << " and ";
    #####:  976:                    oss << m_matchers[i]->toString();
        -:  977:                }
    #####:  978:                oss << " )";
    #####:  979:                return oss.str();
        -:  980:            }
        -:  981:
        -:  982:            AllOf operator && ( Matcher<ExpressionT> const& other ) const {
        -:  983:                AllOf allOfExpr( *this );
        -:  984:                allOfExpr.add( other );
        -:  985:                return allOfExpr;
        -:  986:            }
        -:  987:
        -:  988:        private:
        -:  989:            std::vector<Ptr<Matcher<ExpressionT> > > m_matchers;
        -:  990:        };
        -:  991:
        -:  992:        template<typename ExpressionT>
        -:  993:        class AnyOf : public MatcherImpl<AnyOf<ExpressionT>, ExpressionT> {
        -:  994:        public:
        -:  995:
        -:  996:            AnyOf() {}
        -:  997:            AnyOf( AnyOf const& other ) : m_matchers( other.m_matchers ) {}
        -:  998:
        -:  999:            AnyOf& add( Matcher<ExpressionT> const& matcher ) {
        -: 1000:                m_matchers.push_back( matcher.clone() );
        -: 1001:                return *this;
        -: 1002:            }
        -: 1003:            virtual bool match( ExpressionT const& expr ) const
        -: 1004:            {
        -: 1005:                for( std::size_t i = 0; i < m_matchers.size(); ++i )
        -: 1006:                    if( m_matchers[i]->match( expr ) )
        -: 1007:                        return true;
        -: 1008:                return false;
        -: 1009:            }
        -: 1010:            virtual std::string toString() const {
        -: 1011:                std::ostringstream oss;
        -: 1012:                oss << "( ";
        -: 1013:                for( std::size_t i = 0; i < m_matchers.size(); ++i ) {
        -: 1014:                    if( i != 0 )
        -: 1015:                        oss << " or ";
        -: 1016:                    oss << m_matchers[i]->toString();
        -: 1017:                }
        -: 1018:                oss << " )";
        -: 1019:                return oss.str();
        -: 1020:            }
        -: 1021:
        -: 1022:            AnyOf operator || ( Matcher<ExpressionT> const& other ) const {
        -: 1023:                AnyOf anyOfExpr( *this );
        -: 1024:                anyOfExpr.add( other );
        -: 1025:                return anyOfExpr;
        -: 1026:            }
        -: 1027:
        -: 1028:        private:
        -: 1029:            std::vector<Ptr<Matcher<ExpressionT> > > m_matchers;
        -: 1030:        };
        -: 1031:
        -: 1032:    } // namespace Generic
        -: 1033:
        -: 1034:    template<typename ExpressionT>
        -: 1035:    Generic::AllOf<ExpressionT> Matcher<ExpressionT>::operator && ( Matcher<ExpressionT> const& other ) const {
        -: 1036:        Generic::AllOf<ExpressionT> allOfExpr;
        -: 1037:        allOfExpr.add( *this );
        -: 1038:        allOfExpr.add( other );
        -: 1039:        return allOfExpr;
        -: 1040:    }
        -: 1041:
        -: 1042:    template<typename ExpressionT>
        -: 1043:    Generic::AnyOf<ExpressionT> Matcher<ExpressionT>::operator || ( Matcher<ExpressionT> const& other ) const {
        -: 1044:        Generic::AnyOf<ExpressionT> anyOfExpr;
        -: 1045:        anyOfExpr.add( *this );
        -: 1046:        anyOfExpr.add( other );
        -: 1047:        return anyOfExpr;
        -: 1048:    }
        -: 1049:
        -: 1050:    template<typename ExpressionT>
        -: 1051:    Generic::Not<ExpressionT> Matcher<ExpressionT>::operator ! () const {
        -: 1052:        return Generic::Not<ExpressionT>( *this );
        -: 1053:    }
        -: 1054:
        -: 1055:    namespace StdString {
        -: 1056:
        -: 1057:        inline std::string makeString( std::string const& str ) { return str; }
        -: 1058:        inline std::string makeString( const char* str ) { return str ? std::string( str ) : std::string(); }
        -: 1059:
    #####: 1060:        struct CasedString
        -: 1061:        {
    #####: 1062:            CasedString( std::string const& str, CaseSensitive::Choice caseSensitivity )
        -: 1063:            :   m_caseSensitivity( caseSensitivity ),
    #####: 1064:                m_str( adjustString( str ) )
    #####: 1065:            {}
    #####: 1066:            std::string adjustString( std::string const& str ) const {
    #####: 1067:                return m_caseSensitivity == CaseSensitive::No
        -: 1068:                    ? toLower( str )
    #####: 1069:                    : str;
        -: 1070:
        -: 1071:            }
    #####: 1072:            std::string toStringSuffix() const
        -: 1073:            {
    #####: 1074:                return m_caseSensitivity == CaseSensitive::No
        -: 1075:                    ? " (case insensitive)"
    #####: 1076:                    : "";
        -: 1077:            }
        -: 1078:            CaseSensitive::Choice m_caseSensitivity;
        -: 1079:            std::string m_str;
        -: 1080:        };
        -: 1081:
        -: 1082:        struct Equals : MatcherImpl<Equals, std::string> {
    #####: 1083:            Equals( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes )
    #####: 1084:            :   m_data( str, caseSensitivity )
    #####: 1085:            {}
    #####: 1086:            Equals( Equals const& other ) : m_data( other.m_data ){}
        -: 1087:
        -: 1088:            virtual ~Equals();
        -: 1089:
    #####: 1090:            virtual bool match( std::string const& expr ) const {
    #####: 1091:                return m_data.m_str == m_data.adjustString( expr );;
        -: 1092:            }
    #####: 1093:            virtual std::string toString() const {
    #####: 1094:                return "equals: \"" + m_data.m_str + "\"" + m_data.toStringSuffix();
        -: 1095:            }
        -: 1096:
        -: 1097:            CasedString m_data;
        -: 1098:        };
        -: 1099:
        -: 1100:        struct Contains : MatcherImpl<Contains, std::string> {
        -: 1101:            Contains( std::string const& substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes )
        -: 1102:            : m_data( substr, caseSensitivity ){}
    #####: 1103:            Contains( Contains const& other ) : m_data( other.m_data ){}
        -: 1104:
        -: 1105:            virtual ~Contains();
        -: 1106:
    #####: 1107:            virtual bool match( std::string const& expr ) const {
    #####: 1108:                return m_data.adjustString( expr ).find( m_data.m_str ) != std::string::npos;
        -: 1109:            }
    #####: 1110:            virtual std::string toString() const {
    #####: 1111:                return "contains: \"" + m_data.m_str  + "\"" + m_data.toStringSuffix();
        -: 1112:            }
        -: 1113:
        -: 1114:            CasedString m_data;
        -: 1115:        };
        -: 1116:
        -: 1117:        struct StartsWith : MatcherImpl<StartsWith, std::string> {
        -: 1118:            StartsWith( std::string const& substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes )
        -: 1119:            : m_data( substr, caseSensitivity ){}
        -: 1120:
    #####: 1121:            StartsWith( StartsWith const& other ) : m_data( other.m_data ){}
        -: 1122:
        -: 1123:            virtual ~StartsWith();
        -: 1124:
    #####: 1125:            virtual bool match( std::string const& expr ) const {
    #####: 1126:                return startsWith( m_data.adjustString( expr ), m_data.m_str );
        -: 1127:            }
    #####: 1128:            virtual std::string toString() const {
    #####: 1129:                return "starts with: \"" + m_data.m_str + "\"" + m_data.toStringSuffix();
        -: 1130:            }
        -: 1131:
        -: 1132:            CasedString m_data;
        -: 1133:        };
        -: 1134:
        -: 1135:        struct EndsWith : MatcherImpl<EndsWith, std::string> {
        -: 1136:            EndsWith( std::string const& substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes )
        -: 1137:            : m_data( substr, caseSensitivity ){}
    #####: 1138:            EndsWith( EndsWith const& other ) : m_data( other.m_data ){}
        -: 1139:
        -: 1140:            virtual ~EndsWith();
        -: 1141:
    #####: 1142:            virtual bool match( std::string const& expr ) const {
    #####: 1143:                return endsWith( m_data.adjustString( expr ), m_data.m_str );
        -: 1144:            }
    #####: 1145:            virtual std::string toString() const {
    #####: 1146:                return "ends with: \"" + m_data.m_str + "\"" + m_data.toStringSuffix();
        -: 1147:            }
        -: 1148:
        -: 1149:            CasedString m_data;
        -: 1150:        };
        -: 1151:    } // namespace StdString
        -: 1152:    } // namespace Impl
        -: 1153:
        -: 1154:    // The following functions create the actual matcher objects.
        -: 1155:    // This allows the types to be inferred
        -: 1156:    template<typename ExpressionT>
        -: 1157:    inline Impl::Generic::Not<ExpressionT> Not( Impl::Matcher<ExpressionT> const& m ) {
        -: 1158:        return Impl::Generic::Not<ExpressionT>( m );
        -: 1159:    }
        -: 1160:
        -: 1161:    template<typename ExpressionT>
        -: 1162:    inline Impl::Generic::AllOf<ExpressionT> AllOf( Impl::Matcher<ExpressionT> const& m1,
        -: 1163:                                                    Impl::Matcher<ExpressionT> const& m2 ) {
        -: 1164:        return Impl::Generic::AllOf<ExpressionT>().add( m1 ).add( m2 );
        -: 1165:    }
        -: 1166:    template<typename ExpressionT>
        -: 1167:    inline Impl::Generic::AllOf<ExpressionT> AllOf( Impl::Matcher<ExpressionT> const& m1,
        -: 1168:                                                    Impl::Matcher<ExpressionT> const& m2,
        -: 1169:                                                    Impl::Matcher<ExpressionT> const& m3 ) {
        -: 1170:        return Impl::Generic::AllOf<ExpressionT>().add( m1 ).add( m2 ).add( m3 );
        -: 1171:    }
        -: 1172:    template<typename ExpressionT>
        -: 1173:    inline Impl::Generic::AnyOf<ExpressionT> AnyOf( Impl::Matcher<ExpressionT> const& m1,
        -: 1174:                                                    Impl::Matcher<ExpressionT> const& m2 ) {
        -: 1175:        return Impl::Generic::AnyOf<ExpressionT>().add( m1 ).add( m2 );
        -: 1176:    }
        -: 1177:    template<typename ExpressionT>
        -: 1178:    inline Impl::Generic::AnyOf<ExpressionT> AnyOf( Impl::Matcher<ExpressionT> const& m1,
        -: 1179:                                                    Impl::Matcher<ExpressionT> const& m2,
        -: 1180:                                                    Impl::Matcher<ExpressionT> const& m3 ) {
        -: 1181:        return Impl::Generic::AnyOf<ExpressionT>().add( m1 ).add( m2 ).add( m3 );
        -: 1182:    }
        -: 1183:
    #####: 1184:    inline Impl::StdString::Equals      Equals( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes ) {
    #####: 1185:        return Impl::StdString::Equals( str, caseSensitivity );
        -: 1186:    }
        -: 1187:    inline Impl::StdString::Equals      Equals( const char* str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes ) {
        -: 1188:        return Impl::StdString::Equals( Impl::StdString::makeString( str ), caseSensitivity );
        -: 1189:    }
        -: 1190:    inline Impl::StdString::Contains    Contains( std::string const& substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes ) {
        -: 1191:        return Impl::StdString::Contains( substr, caseSensitivity );
        -: 1192:    }
        -: 1193:    inline Impl::StdString::Contains    Contains( const char* substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes ) {
        -: 1194:        return Impl::StdString::Contains( Impl::StdString::makeString( substr ), caseSensitivity );
        -: 1195:    }
        -: 1196:    inline Impl::StdString::StartsWith  StartsWith( std::string const& substr ) {
        -: 1197:        return Impl::StdString::StartsWith( substr );
        -: 1198:    }
        -: 1199:    inline Impl::StdString::StartsWith  StartsWith( const char* substr ) {
        -: 1200:        return Impl::StdString::StartsWith( Impl::StdString::makeString( substr ) );
        -: 1201:    }
        -: 1202:    inline Impl::StdString::EndsWith    EndsWith( std::string const& substr ) {
        -: 1203:        return Impl::StdString::EndsWith( substr );
        -: 1204:    }
        -: 1205:    inline Impl::StdString::EndsWith    EndsWith( const char* substr ) {
        -: 1206:        return Impl::StdString::EndsWith( Impl::StdString::makeString( substr ) );
        -: 1207:    }
        -: 1208:
        -: 1209:} // namespace Matchers
        -: 1210:
        -: 1211:using namespace Matchers;
        -: 1212:
        -: 1213:} // namespace Catch
        -: 1214:
        -: 1215:namespace Catch {
        -: 1216:
        -: 1217:    struct TestFailureException{};
        -: 1218:
        -: 1219:    template<typename T> class ExpressionLhs;
        -: 1220:
        -: 1221:    struct STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison;
        -: 1222:
    #####: 1223:    struct CopyableStream {
    #####: 1224:        CopyableStream() {}
        -: 1225:        CopyableStream( CopyableStream const& other ) {
        -: 1226:            oss << other.oss.str();
        -: 1227:        }
        -: 1228:        CopyableStream& operator=( CopyableStream const& other ) {
        -: 1229:            oss.str("");
        -: 1230:            oss << other.oss.str();
        -: 1231:            return *this;
        -: 1232:        }
        -: 1233:        std::ostringstream oss;
        -: 1234:    };
        -: 1235:
    #####: 1236:    class ResultBuilder {
        -: 1237:    public:
        -: 1238:        ResultBuilder(  char const* macroName,
        -: 1239:                        SourceLineInfo const& lineInfo,
        -: 1240:                        char const* capturedExpression,
        -: 1241:                        ResultDisposition::Flags resultDisposition,
        -: 1242:                        char const* secondArg = "" );
        -: 1243:
        -: 1244:        template<typename T>
        -: 1245:        ExpressionLhs<T const&> operator <= ( T const& operand );
        -: 1246:        ExpressionLhs<bool> operator <= ( bool value );
        -: 1247:
        -: 1248:        template<typename T>
    #####: 1249:        ResultBuilder& operator << ( T const& value ) {
    #####: 1250:            m_stream.oss << value;
    #####: 1251:            return *this;
        -: 1252:        }
        -: 1253:
        -: 1254:        template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator && ( RhsT const& );
        -: 1255:        template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator || ( RhsT const& );
        -: 1256:
        -: 1257:        ResultBuilder& setResultType( ResultWas::OfType result );
        -: 1258:        ResultBuilder& setResultType( bool result );
        -: 1259:        ResultBuilder& setLhs( std::string const& lhs );
        -: 1260:        ResultBuilder& setRhs( std::string const& rhs );
        -: 1261:        ResultBuilder& setOp( std::string const& op );
        -: 1262:
        -: 1263:        void endExpression();
        -: 1264:
        -: 1265:        std::string reconstructExpression() const;
        -: 1266:        AssertionResult build() const;
        -: 1267:
        -: 1268:        void useActiveException( ResultDisposition::Flags resultDisposition = ResultDisposition::Normal );
        -: 1269:        void captureResult( ResultWas::OfType resultType );
        -: 1270:        void captureExpression();
        -: 1271:        void captureExpectedException( std::string const& expectedMessage );
        -: 1272:        void captureExpectedException( Matchers::Impl::Matcher<std::string> const& matcher );
        -: 1273:        void handleResult( AssertionResult const& result );
        -: 1274:        void react();
        -: 1275:        bool shouldDebugBreak() const;
        -: 1276:        bool allowThrows() const;
        -: 1277:
        -: 1278:    private:
        -: 1279:        AssertionInfo m_assertionInfo;
        -: 1280:        AssertionResultData m_data;
    #####: 1281:        struct ExprComponents {
    #####: 1282:            ExprComponents() : testFalse( false ) {}
        -: 1283:            bool testFalse;
        -: 1284:            std::string lhs, rhs, op;
        -: 1285:        } m_exprComponents;
        -: 1286:        CopyableStream m_stream;
        -: 1287:
        -: 1288:        bool m_shouldDebugBreak;
        -: 1289:        bool m_shouldThrow;
        -: 1290:    };
        -: 1291:
        -: 1292:} // namespace Catch
        -: 1293:
        -: 1294:// Include after due to circular dependency:
        -: 1295:// #included from: catch_expression_lhs.hpp
        -: 1296:#define TWOBLUECUBES_CATCH_EXPRESSION_LHS_HPP_INCLUDED
        -: 1297:
        -: 1298:// #included from: catch_evaluate.hpp
        -: 1299:#define TWOBLUECUBES_CATCH_EVALUATE_HPP_INCLUDED
        -: 1300:
        -: 1301:#ifdef _MSC_VER
        -: 1302:#pragma warning(push)
        -: 1303:#pragma warning(disable:4389) // '==' : signed/unsigned mismatch
        -: 1304:#endif
        -: 1305:
        -: 1306:#include <cstddef>
        -: 1307:
        -: 1308:namespace Catch {
        -: 1309:namespace Internal {
        -: 1310:
        -: 1311:    enum Operator {
        -: 1312:        IsEqualTo,
        -: 1313:        IsNotEqualTo,
        -: 1314:        IsLessThan,
        -: 1315:        IsGreaterThan,
        -: 1316:        IsLessThanOrEqualTo,
        -: 1317:        IsGreaterThanOrEqualTo
        -: 1318:    };
        -: 1319:
        -: 1320:    template<Operator Op> struct OperatorTraits             { static const char* getName(){ return "*error*"; } };
        -: 1321:    template<> struct OperatorTraits<IsEqualTo>             { static const char* getName(){ return "=="; } };
        -: 1322:    template<> struct OperatorTraits<IsNotEqualTo>          { static const char* getName(){ return "!="; } };
        -: 1323:    template<> struct OperatorTraits<IsLessThan>            { static const char* getName(){ return "<"; } };
        -: 1324:    template<> struct OperatorTraits<IsGreaterThan>         { static const char* getName(){ return ">"; } };
        -: 1325:    template<> struct OperatorTraits<IsLessThanOrEqualTo>   { static const char* getName(){ return "<="; } };
        -: 1326:    template<> struct OperatorTraits<IsGreaterThanOrEqualTo>{ static const char* getName(){ return ">="; } };
        -: 1327:
        -: 1328:    template<typename T>
        -: 1329:    inline T& opCast(T const& t) { return const_cast<T&>(t); }
        -: 1330:
        -: 1331:// nullptr_t support based on pull request #154 from Konstantin Baumann
        -: 1332:#ifdef CATCH_CONFIG_CPP11_NULLPTR
        -: 1333:    inline std::nullptr_t opCast(std::nullptr_t) { return nullptr; }
        -: 1334:#endif // CATCH_CONFIG_CPP11_NULLPTR
        -: 1335:
        -: 1336:    // So the compare overloads can be operator agnostic we convey the operator as a template
        -: 1337:    // enum, which is used to specialise an Evaluator for doing the comparison.
        -: 1338:    template<typename T1, typename T2, Operator Op>
        -: 1339:    class Evaluator{};
        -: 1340:
        -: 1341:    template<typename T1, typename T2>
        -: 1342:    struct Evaluator<T1, T2, IsEqualTo> {
        -: 1343:        static bool evaluate( T1 const& lhs, T2 const& rhs) {
        -: 1344:            return bool( opCast( lhs ) ==  opCast( rhs ) );
        -: 1345:        }
        -: 1346:    };
        -: 1347:    template<typename T1, typename T2>
        -: 1348:    struct Evaluator<T1, T2, IsNotEqualTo> {
        -: 1349:        static bool evaluate( T1 const& lhs, T2 const& rhs ) {
        -: 1350:            return bool( opCast( lhs ) != opCast( rhs ) );
        -: 1351:        }
        -: 1352:    };
        -: 1353:    template<typename T1, typename T2>
        -: 1354:    struct Evaluator<T1, T2, IsLessThan> {
        -: 1355:        static bool evaluate( T1 const& lhs, T2 const& rhs ) {
        -: 1356:            return bool( opCast( lhs ) < opCast( rhs ) );
        -: 1357:        }
        -: 1358:    };
        -: 1359:    template<typename T1, typename T2>
        -: 1360:    struct Evaluator<T1, T2, IsGreaterThan> {
        -: 1361:        static bool evaluate( T1 const& lhs, T2 const& rhs ) {
        -: 1362:            return bool( opCast( lhs ) > opCast( rhs ) );
        -: 1363:        }
        -: 1364:    };
        -: 1365:    template<typename T1, typename T2>
        -: 1366:    struct Evaluator<T1, T2, IsGreaterThanOrEqualTo> {
        -: 1367:        static bool evaluate( T1 const& lhs, T2 const& rhs ) {
        -: 1368:            return bool( opCast( lhs ) >= opCast( rhs ) );
        -: 1369:        }
        -: 1370:    };
        -: 1371:    template<typename T1, typename T2>
        -: 1372:    struct Evaluator<T1, T2, IsLessThanOrEqualTo> {
        -: 1373:        static bool evaluate( T1 const& lhs, T2 const& rhs ) {
        -: 1374:            return bool( opCast( lhs ) <= opCast( rhs ) );
        -: 1375:        }
        -: 1376:    };
        -: 1377:
        -: 1378:    template<Operator Op, typename T1, typename T2>
        -: 1379:    bool applyEvaluator( T1 const& lhs, T2 const& rhs ) {
        -: 1380:        return Evaluator<T1, T2, Op>::evaluate( lhs, rhs );
        -: 1381:    }
        -: 1382:
        -: 1383:    // This level of indirection allows us to specialise for integer types
        -: 1384:    // to avoid signed/ unsigned warnings
        -: 1385:
        -: 1386:    // "base" overload
        -: 1387:    template<Operator Op, typename T1, typename T2>
        -: 1388:    bool compare( T1 const& lhs, T2 const& rhs ) {
        -: 1389:        return Evaluator<T1, T2, Op>::evaluate( lhs, rhs );
        -: 1390:    }
        -: 1391:
        -: 1392:    // unsigned X to int
        -: 1393:    template<Operator Op> bool compare( unsigned int lhs, int rhs ) {
        -: 1394:        return applyEvaluator<Op>( lhs, static_cast<unsigned int>( rhs ) );
        -: 1395:    }
        -: 1396:    template<Operator Op> bool compare( unsigned long lhs, int rhs ) {
        -: 1397:        return applyEvaluator<Op>( lhs, static_cast<unsigned int>( rhs ) );
        -: 1398:    }
        -: 1399:    template<Operator Op> bool compare( unsigned char lhs, int rhs ) {
        -: 1400:        return applyEvaluator<Op>( lhs, static_cast<unsigned int>( rhs ) );
        -: 1401:    }
        -: 1402:
        -: 1403:    // unsigned X to long
        -: 1404:    template<Operator Op> bool compare( unsigned int lhs, long rhs ) {
        -: 1405:        return applyEvaluator<Op>( lhs, static_cast<unsigned long>( rhs ) );
        -: 1406:    }
        -: 1407:    template<Operator Op> bool compare( unsigned long lhs, long rhs ) {
        -: 1408:        return applyEvaluator<Op>( lhs, static_cast<unsigned long>( rhs ) );
        -: 1409:    }
        -: 1410:    template<Operator Op> bool compare( unsigned char lhs, long rhs ) {
        -: 1411:        return applyEvaluator<Op>( lhs, static_cast<unsigned long>( rhs ) );
        -: 1412:    }
        -: 1413:
        -: 1414:    // int to unsigned X
        -: 1415:    template<Operator Op> bool compare( int lhs, unsigned int rhs ) {
        -: 1416:        return applyEvaluator<Op>( static_cast<unsigned int>( lhs ), rhs );
        -: 1417:    }
        -: 1418:    template<Operator Op> bool compare( int lhs, unsigned long rhs ) {
        -: 1419:        return applyEvaluator<Op>( static_cast<unsigned int>( lhs ), rhs );
        -: 1420:    }
        -: 1421:    template<Operator Op> bool compare( int lhs, unsigned char rhs ) {
        -: 1422:        return applyEvaluator<Op>( static_cast<unsigned int>( lhs ), rhs );
        -: 1423:    }
        -: 1424:
        -: 1425:    // long to unsigned X
        -: 1426:    template<Operator Op> bool compare( long lhs, unsigned int rhs ) {
        -: 1427:        return applyEvaluator<Op>( static_cast<unsigned long>( lhs ), rhs );
        -: 1428:    }
        -: 1429:    template<Operator Op> bool compare( long lhs, unsigned long rhs ) {
        -: 1430:        return applyEvaluator<Op>( static_cast<unsigned long>( lhs ), rhs );
        -: 1431:    }
        -: 1432:    template<Operator Op> bool compare( long lhs, unsigned char rhs ) {
        -: 1433:        return applyEvaluator<Op>( static_cast<unsigned long>( lhs ), rhs );
        -: 1434:    }
        -: 1435:
        -: 1436:    // pointer to long (when comparing against NULL)
        -: 1437:    template<Operator Op, typename T> bool compare( long lhs, T* rhs ) {
        -: 1438:        return Evaluator<T*, T*, Op>::evaluate( reinterpret_cast<T*>( lhs ), rhs );
        -: 1439:    }
        -: 1440:    template<Operator Op, typename T> bool compare( T* lhs, long rhs ) {
        -: 1441:        return Evaluator<T*, T*, Op>::evaluate( lhs, reinterpret_cast<T*>( rhs ) );
        -: 1442:    }
        -: 1443:
        -: 1444:    // pointer to int (when comparing against NULL)
        -: 1445:    template<Operator Op, typename T> bool compare( int lhs, T* rhs ) {
        -: 1446:        return Evaluator<T*, T*, Op>::evaluate( reinterpret_cast<T*>( lhs ), rhs );
        -: 1447:    }
        -: 1448:    template<Operator Op, typename T> bool compare( T* lhs, int rhs ) {
        -: 1449:        return Evaluator<T*, T*, Op>::evaluate( lhs, reinterpret_cast<T*>( rhs ) );
        -: 1450:    }
        -: 1451:
        -: 1452:#ifdef CATCH_CONFIG_CPP11_LONG_LONG
        -: 1453:    // long long to unsigned X
        -: 1454:    template<Operator Op> bool compare( long long lhs, unsigned int rhs ) {
        -: 1455:        return applyEvaluator<Op>( static_cast<unsigned long>( lhs ), rhs );
        -: 1456:    }
        -: 1457:    template<Operator Op> bool compare( long long lhs, unsigned long rhs ) {
        -: 1458:        return applyEvaluator<Op>( static_cast<unsigned long>( lhs ), rhs );
        -: 1459:    }
        -: 1460:    template<Operator Op> bool compare( long long lhs, unsigned long long rhs ) {
        -: 1461:        return applyEvaluator<Op>( static_cast<unsigned long>( lhs ), rhs );
        -: 1462:    }
        -: 1463:    template<Operator Op> bool compare( long long lhs, unsigned char rhs ) {
        -: 1464:        return applyEvaluator<Op>( static_cast<unsigned long>( lhs ), rhs );
        -: 1465:    }
        -: 1466:
        -: 1467:    // unsigned long long to X
        -: 1468:    template<Operator Op> bool compare( unsigned long long lhs, int rhs ) {
        -: 1469:        return applyEvaluator<Op>( static_cast<long>( lhs ), rhs );
        -: 1470:    }
        -: 1471:    template<Operator Op> bool compare( unsigned long long lhs, long rhs ) {
        -: 1472:        return applyEvaluator<Op>( static_cast<long>( lhs ), rhs );
        -: 1473:    }
        -: 1474:    template<Operator Op> bool compare( unsigned long long lhs, long long rhs ) {
        -: 1475:        return applyEvaluator<Op>( static_cast<long>( lhs ), rhs );
        -: 1476:    }
        -: 1477:    template<Operator Op> bool compare( unsigned long long lhs, char rhs ) {
        -: 1478:        return applyEvaluator<Op>( static_cast<long>( lhs ), rhs );
        -: 1479:    }
        -: 1480:
        -: 1481:    // pointer to long long (when comparing against NULL)
        -: 1482:    template<Operator Op, typename T> bool compare( long long lhs, T* rhs ) {
        -: 1483:        return Evaluator<T*, T*, Op>::evaluate( reinterpret_cast<T*>( lhs ), rhs );
        -: 1484:    }
        -: 1485:    template<Operator Op, typename T> bool compare( T* lhs, long long rhs ) {
        -: 1486:        return Evaluator<T*, T*, Op>::evaluate( lhs, reinterpret_cast<T*>( rhs ) );
        -: 1487:    }
        -: 1488:#endif // CATCH_CONFIG_CPP11_LONG_LONG
        -: 1489:
        -: 1490:#ifdef CATCH_CONFIG_CPP11_NULLPTR
        -: 1491:    // pointer to nullptr_t (when comparing against nullptr)
        -: 1492:    template<Operator Op, typename T> bool compare( std::nullptr_t, T* rhs ) {
        -: 1493:        return Evaluator<T*, T*, Op>::evaluate( nullptr, rhs );
        -: 1494:    }
        -: 1495:    template<Operator Op, typename T> bool compare( T* lhs, std::nullptr_t ) {
        -: 1496:        return Evaluator<T*, T*, Op>::evaluate( lhs, nullptr );
        -: 1497:    }
        -: 1498:#endif // CATCH_CONFIG_CPP11_NULLPTR
        -: 1499:
        -: 1500:} // end of namespace Internal
        -: 1501:} // end of namespace Catch
        -: 1502:
        -: 1503:#ifdef _MSC_VER
        -: 1504:#pragma warning(pop)
        -: 1505:#endif
        -: 1506:
        -: 1507:// #included from: catch_tostring.h
        -: 1508:#define TWOBLUECUBES_CATCH_TOSTRING_H_INCLUDED
        -: 1509:
        -: 1510:#include <sstream>
        -: 1511:#include <iomanip>
        -: 1512:#include <limits>
        -: 1513:#include <vector>
        -: 1514:#include <cstddef>
        -: 1515:
        -: 1516:#ifdef __OBJC__
        -: 1517:// #included from: catch_objc_arc.hpp
        -: 1518:#define TWOBLUECUBES_CATCH_OBJC_ARC_HPP_INCLUDED
        -: 1519:
        -: 1520:#import <Foundation/Foundation.h>
        -: 1521:
        -: 1522:#ifdef __has_feature
        -: 1523:#define CATCH_ARC_ENABLED __has_feature(objc_arc)
        -: 1524:#else
        -: 1525:#define CATCH_ARC_ENABLED 0
        -: 1526:#endif
        -: 1527:
        -: 1528:void arcSafeRelease( NSObject* obj );
        -: 1529:id performOptionalSelector( id obj, SEL sel );
        -: 1530:
        -: 1531:#if !CATCH_ARC_ENABLED
        -: 1532:inline void arcSafeRelease( NSObject* obj ) {
        -: 1533:    [obj release];
        -: 1534:}
        -: 1535:inline id performOptionalSelector( id obj, SEL sel ) {
        -: 1536:    if( [obj respondsToSelector: sel] )
        -: 1537:        return [obj performSelector: sel];
        -: 1538:    return nil;
        -: 1539:}
        -: 1540:#define CATCH_UNSAFE_UNRETAINED
        -: 1541:#define CATCH_ARC_STRONG
        -: 1542:#else
        -: 1543:inline void arcSafeRelease( NSObject* ){}
        -: 1544:inline id performOptionalSelector( id obj, SEL sel ) {
        -: 1545:#ifdef __clang__
        -: 1546:#pragma clang diagnostic push
        -: 1547:#pragma clang diagnostic ignored "-Warc-performSelector-leaks"
        -: 1548:#endif
        -: 1549:    if( [obj respondsToSelector: sel] )
        -: 1550:        return [obj performSelector: sel];
        -: 1551:#ifdef __clang__
        -: 1552:#pragma clang diagnostic pop
        -: 1553:#endif
        -: 1554:    return nil;
        -: 1555:}
        -: 1556:#define CATCH_UNSAFE_UNRETAINED __unsafe_unretained
        -: 1557:#define CATCH_ARC_STRONG __strong
        -: 1558:#endif
        -: 1559:
        -: 1560:#endif
        -: 1561:
        -: 1562:#ifdef CATCH_CONFIG_CPP11_TUPLE
        -: 1563:#include <tuple>
        -: 1564:#endif
        -: 1565:
        -: 1566:#ifdef CATCH_CONFIG_CPP11_IS_ENUM
        -: 1567:#include <type_traits>
        -: 1568:#endif
        -: 1569:
        -: 1570:namespace Catch {
        -: 1571:
        -: 1572:// Why we're here.
        -: 1573:template<typename T>
        -: 1574:std::string toString( T const& value );
        -: 1575:
        -: 1576:// Built in overloads
        -: 1577:
        -: 1578:std::string toString( std::string const& value );
        -: 1579:std::string toString( std::wstring const& value );
        -: 1580:std::string toString( const char* const value );
        -: 1581:std::string toString( char* const value );
        -: 1582:std::string toString( const wchar_t* const value );
        -: 1583:std::string toString( wchar_t* const value );
        -: 1584:std::string toString( int value );
        -: 1585:std::string toString( unsigned long value );
        -: 1586:std::string toString( unsigned int value );
        -: 1587:std::string toString( const double value );
        -: 1588:std::string toString( const float value );
        -: 1589:std::string toString( bool value );
        -: 1590:std::string toString( char value );
        -: 1591:std::string toString( signed char value );
        -: 1592:std::string toString( unsigned char value );
        -: 1593:
        -: 1594:#ifdef CATCH_CONFIG_CPP11_LONG_LONG
        -: 1595:std::string toString( long long value );
        -: 1596:std::string toString( unsigned long long value );
        -: 1597:#endif
        -: 1598:
        -: 1599:#ifdef CATCH_CONFIG_CPP11_NULLPTR
        -: 1600:std::string toString( std::nullptr_t );
        -: 1601:#endif
        -: 1602:
        -: 1603:#ifdef __OBJC__
        -: 1604:    std::string toString( NSString const * const& nsstring );
        -: 1605:    std::string toString( NSString * CATCH_ARC_STRONG const& nsstring );
        -: 1606:    std::string toString( NSObject* const& nsObject );
        -: 1607:#endif
        -: 1608:
        -: 1609:namespace Detail {
        -: 1610:
        -: 1611:    extern const std::string unprintableString;
        -: 1612:
        -: 1613:    struct BorgType {
        -: 1614:        template<typename T> BorgType( T const& );
        -: 1615:    };
        -: 1616:
        -: 1617:    struct TrueType { char sizer[1]; };
        -: 1618:    struct FalseType { char sizer[2]; };
        -: 1619:
        -: 1620:    TrueType& testStreamable( std::ostream& );
        -: 1621:    FalseType testStreamable( FalseType );
        -: 1622:
        -: 1623:    FalseType operator<<( std::ostream const&, BorgType const& );
        -: 1624:
        -: 1625:    template<typename T>
        -: 1626:    struct IsStreamInsertable {
        -: 1627:        static std::ostream &s;
        -: 1628:        static T  const&t;
        -: 1629:        enum { value = sizeof( testStreamable(s << t) ) == sizeof( TrueType ) };
        -: 1630:    };
        -: 1631:
        -: 1632:#if defined(CATCH_CONFIG_CPP11_IS_ENUM)
        -: 1633:    template<typename T,
        -: 1634:             bool IsEnum = std::is_enum<T>::value
        -: 1635:             >
        -: 1636:    struct EnumStringMaker
        -: 1637:    {
        -: 1638:        static std::string convert( T const& ) { return unprintableString; }
        -: 1639:    };
        -: 1640:
        -: 1641:    template<typename T>
        -: 1642:    struct EnumStringMaker<T,true>
        -: 1643:    {
        -: 1644:        static std::string convert( T const& v )
        -: 1645:        {
        -: 1646:            return ::Catch::toString(
        -: 1647:                static_cast<typename std::underlying_type<T>::type>(v)
        -: 1648:                );
        -: 1649:        }
        -: 1650:    };
        -: 1651:#endif
        -: 1652:    template<bool C>
        -: 1653:    struct StringMakerBase {
        -: 1654:#if defined(CATCH_CONFIG_CPP11_IS_ENUM)
        -: 1655:        template<typename T>
        -: 1656:        static std::string convert( T const& v )
        -: 1657:        {
        -: 1658:            return EnumStringMaker<T>::convert( v );
        -: 1659:        }
        -: 1660:#else
        -: 1661:        template<typename T>
        -: 1662:        static std::string convert( T const& ) { return unprintableString; }
        -: 1663:#endif
        -: 1664:    };
        -: 1665:
        -: 1666:    template<>
        -: 1667:    struct StringMakerBase<true> {
        -: 1668:        template<typename T>
    #####: 1669:        static std::string convert( T const& _value ) {
    #####: 1670:            std::ostringstream oss;
    #####: 1671:            oss << _value;
    #####: 1672:            return oss.str();
        -: 1673:        }
        -: 1674:    };
        -: 1675:
        -: 1676:    std::string rawMemoryToString( const void *object, std::size_t size );
        -: 1677:
        -: 1678:    template<typename T>
        -: 1679:    inline std::string rawMemoryToString( const T& object ) {
        -: 1680:      return rawMemoryToString( &object, sizeof(object) );
        -: 1681:    }
        -: 1682:
        -: 1683:} // end namespace Detail
        -: 1684:
        -: 1685:template<typename T>
        -: 1686:struct StringMaker :
        -: 1687:    Detail::StringMakerBase<Detail::IsStreamInsertable<T>::value> {};
        -: 1688:
        -: 1689:template<typename T>
        -: 1690:struct StringMaker<T*> {
        -: 1691:    template<typename U>
        -: 1692:    static std::string convert( U* p ) {
        -: 1693:        if( !p )
        -: 1694:            return "NULL";
        -: 1695:        else
        -: 1696:            return Detail::rawMemoryToString( p );
        -: 1697:    }
        -: 1698:};
        -: 1699:
        -: 1700:template<typename R, typename C>
        -: 1701:struct StringMaker<R C::*> {
        -: 1702:    static std::string convert( R C::* p ) {
        -: 1703:        if( !p )
        -: 1704:            return "NULL";
        -: 1705:        else
        -: 1706:            return Detail::rawMemoryToString( p );
        -: 1707:    }
        -: 1708:};
        -: 1709:
        -: 1710:namespace Detail {
        -: 1711:    template<typename InputIterator>
        -: 1712:    std::string rangeToString( InputIterator first, InputIterator last );
        -: 1713:}
        -: 1714:
        -: 1715://template<typename T, typename Allocator>
        -: 1716://struct StringMaker<std::vector<T, Allocator> > {
        -: 1717://    static std::string convert( std::vector<T,Allocator> const& v ) {
        -: 1718://        return Detail::rangeToString( v.begin(), v.end() );
        -: 1719://    }
        -: 1720://};
        -: 1721:
        -: 1722:template<typename T, typename Allocator>
        -: 1723:std::string toString( std::vector<T,Allocator> const& v ) {
        -: 1724:    return Detail::rangeToString( v.begin(), v.end() );
        -: 1725:}
        -: 1726:
        -: 1727:#ifdef CATCH_CONFIG_CPP11_TUPLE
        -: 1728:
        -: 1729:// toString for tuples
        -: 1730:namespace TupleDetail {
        -: 1731:  template<
        -: 1732:      typename Tuple,
        -: 1733:      std::size_t N = 0,
        -: 1734:      bool = (N < std::tuple_size<Tuple>::value)
        -: 1735:      >
        -: 1736:  struct ElementPrinter {
        -: 1737:      static void print( const Tuple& tuple, std::ostream& os )
        -: 1738:      {
        -: 1739:          os << ( N ? ", " : " " )
        -: 1740:             << Catch::toString(std::get<N>(tuple));
        -: 1741:          ElementPrinter<Tuple,N+1>::print(tuple,os);
        -: 1742:      }
        -: 1743:  };
        -: 1744:
        -: 1745:  template<
        -: 1746:      typename Tuple,
        -: 1747:      std::size_t N
        -: 1748:      >
        -: 1749:  struct ElementPrinter<Tuple,N,false> {
        -: 1750:      static void print( const Tuple&, std::ostream& ) {}
        -: 1751:  };
        -: 1752:
        -: 1753:}
        -: 1754:
        -: 1755:template<typename ...Types>
        -: 1756:struct StringMaker<std::tuple<Types...>> {
        -: 1757:
        -: 1758:    static std::string convert( const std::tuple<Types...>& tuple )
        -: 1759:    {
        -: 1760:        std::ostringstream os;
        -: 1761:        os << '{';
        -: 1762:        TupleDetail::ElementPrinter<std::tuple<Types...>>::print( tuple, os );
        -: 1763:        os << " }";
        -: 1764:        return os.str();
        -: 1765:    }
        -: 1766:};
        -: 1767:#endif // CATCH_CONFIG_CPP11_TUPLE
        -: 1768:
        -: 1769:namespace Detail {
        -: 1770:    template<typename T>
    #####: 1771:    std::string makeString( T const& value ) {
    #####: 1772:        return StringMaker<T>::convert( value );
        -: 1773:    }
        -: 1774:} // end namespace Detail
        -: 1775:
        -: 1776:/// \brief converts any type to a string
        -: 1777:///
        -: 1778:/// The default template forwards on to ostringstream - except when an
        -: 1779:/// ostringstream overload does not exist - in which case it attempts to detect
        -: 1780:/// that and writes {?}.
        -: 1781:/// Overload (not specialise) this template for custom typs that you don't want
        -: 1782:/// to provide an ostream overload for.
        -: 1783:template<typename T>
        -: 1784:std::string toString( T const& value ) {
        -: 1785:    return StringMaker<T>::convert( value );
        -: 1786:}
        -: 1787:
        -: 1788:    namespace Detail {
        -: 1789:    template<typename InputIterator>
        -: 1790:    std::string rangeToString( InputIterator first, InputIterator last ) {
        -: 1791:        std::ostringstream oss;
        -: 1792:        oss << "{ ";
        -: 1793:        if( first != last ) {
        -: 1794:            oss << Catch::toString( *first );
        -: 1795:            for( ++first ; first != last ; ++first )
        -: 1796:                oss << ", " << Catch::toString( *first );
        -: 1797:        }
        -: 1798:        oss << " }";
        -: 1799:        return oss.str();
        -: 1800:    }
        -: 1801:}
        -: 1802:
        -: 1803:} // end namespace Catch
        -: 1804:
        -: 1805:namespace Catch {
        -: 1806:
        -: 1807:// Wraps the LHS of an expression and captures the operator and RHS (if any) -
        -: 1808:// wrapping them all in a ResultBuilder object
        -: 1809:template<typename T>
        -: 1810:class ExpressionLhs {
        -: 1811:    ExpressionLhs& operator = ( ExpressionLhs const& );
        -: 1812:#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
        -: 1813:    ExpressionLhs& operator = ( ExpressionLhs && ) = delete;
        -: 1814:#  endif
        -: 1815:
        -: 1816:public:
        -: 1817:    ExpressionLhs( ResultBuilder& rb, T lhs ) : m_rb( rb ), m_lhs( lhs ) {}
        -: 1818:#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
        -: 1819:    ExpressionLhs( ExpressionLhs const& ) = default;
        -: 1820:    ExpressionLhs( ExpressionLhs && )     = default;
        -: 1821:#  endif
        -: 1822:
        -: 1823:    template<typename RhsT>
        -: 1824:    ResultBuilder& operator == ( RhsT const& rhs ) {
        -: 1825:        return captureExpression<Internal::IsEqualTo>( rhs );
        -: 1826:    }
        -: 1827:
        -: 1828:    template<typename RhsT>
        -: 1829:    ResultBuilder& operator != ( RhsT const& rhs ) {
        -: 1830:        return captureExpression<Internal::IsNotEqualTo>( rhs );
        -: 1831:    }
        -: 1832:
        -: 1833:    template<typename RhsT>
        -: 1834:    ResultBuilder& operator < ( RhsT const& rhs ) {
        -: 1835:        return captureExpression<Internal::IsLessThan>( rhs );
        -: 1836:    }
        -: 1837:
        -: 1838:    template<typename RhsT>
        -: 1839:    ResultBuilder& operator > ( RhsT const& rhs ) {
        -: 1840:        return captureExpression<Internal::IsGreaterThan>( rhs );
        -: 1841:    }
        -: 1842:
        -: 1843:    template<typename RhsT>
        -: 1844:    ResultBuilder& operator <= ( RhsT const& rhs ) {
        -: 1845:        return captureExpression<Internal::IsLessThanOrEqualTo>( rhs );
        -: 1846:    }
        -: 1847:
        -: 1848:    template<typename RhsT>
        -: 1849:    ResultBuilder& operator >= ( RhsT const& rhs ) {
        -: 1850:        return captureExpression<Internal::IsGreaterThanOrEqualTo>( rhs );
        -: 1851:    }
        -: 1852:
        -: 1853:    ResultBuilder& operator == ( bool rhs ) {
        -: 1854:        return captureExpression<Internal::IsEqualTo>( rhs );
        -: 1855:    }
        -: 1856:
        -: 1857:    ResultBuilder& operator != ( bool rhs ) {
        -: 1858:        return captureExpression<Internal::IsNotEqualTo>( rhs );
        -: 1859:    }
        -: 1860:
        -: 1861:    void endExpression() {
        -: 1862:        bool value = m_lhs ? true : false;
        -: 1863:        m_rb
        -: 1864:            .setLhs( Catch::toString( value ) )
        -: 1865:            .setResultType( value )
        -: 1866:            .endExpression();
        -: 1867:    }
        -: 1868:
        -: 1869:    // Only simple binary expressions are allowed on the LHS.
        -: 1870:    // If more complex compositions are required then place the sub expression in parentheses
        -: 1871:    template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator + ( RhsT const& );
        -: 1872:    template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator - ( RhsT const& );
        -: 1873:    template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator / ( RhsT const& );
        -: 1874:    template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator * ( RhsT const& );
        -: 1875:    template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator && ( RhsT const& );
        -: 1876:    template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator || ( RhsT const& );
        -: 1877:
        -: 1878:private:
        -: 1879:    template<Internal::Operator Op, typename RhsT>
        -: 1880:    ResultBuilder& captureExpression( RhsT const& rhs ) {
        -: 1881:        return m_rb
        -: 1882:            .setResultType( Internal::compare<Op>( m_lhs, rhs ) )
        -: 1883:            .setLhs( Catch::toString( m_lhs ) )
        -: 1884:            .setRhs( Catch::toString( rhs ) )
        -: 1885:            .setOp( Internal::OperatorTraits<Op>::getName() );
        -: 1886:    }
        -: 1887:
        -: 1888:private:
        -: 1889:    ResultBuilder& m_rb;
        -: 1890:    T m_lhs;
        -: 1891:};
        -: 1892:
        -: 1893:} // end namespace Catch
        -: 1894:
        -: 1895:
        -: 1896:namespace Catch {
        -: 1897:
        -: 1898:    template<typename T>
        -: 1899:    inline ExpressionLhs<T const&> ResultBuilder::operator <= ( T const& operand ) {
        -: 1900:        return ExpressionLhs<T const&>( *this, operand );
        -: 1901:    }
        -: 1902:
        -: 1903:    inline ExpressionLhs<bool> ResultBuilder::operator <= ( bool value ) {
        -: 1904:        return ExpressionLhs<bool>( *this, value );
        -: 1905:    }
        -: 1906:
        -: 1907:} // namespace Catch
        -: 1908:
        -: 1909:// #included from: catch_message.h
        -: 1910:#define TWOBLUECUBES_CATCH_MESSAGE_H_INCLUDED
        -: 1911:
        -: 1912:#include <string>
        -: 1913:
        -: 1914:namespace Catch {
        -: 1915:
    #####: 1916:    struct MessageInfo {
        -: 1917:        MessageInfo(    std::string const& _macroName,
        -: 1918:                        SourceLineInfo const& _lineInfo,
        -: 1919:                        ResultWas::OfType _type );
        -: 1920:
        -: 1921:        std::string macroName;
        -: 1922:        SourceLineInfo lineInfo;
        -: 1923:        ResultWas::OfType type;
        -: 1924:        std::string message;
        -: 1925:        unsigned int sequence;
        -: 1926:
    #####: 1927:        bool operator == ( MessageInfo const& other ) const {
    #####: 1928:            return sequence == other.sequence;
        -: 1929:        }
        -: 1930:        bool operator < ( MessageInfo const& other ) const {
        -: 1931:            return sequence < other.sequence;
        -: 1932:        }
        -: 1933:    private:
        -: 1934:        static unsigned int globalCount;
        -: 1935:    };
        -: 1936:
    #####: 1937:    struct MessageBuilder {
    #####: 1938:        MessageBuilder( std::string const& macroName,
        -: 1939:                        SourceLineInfo const& lineInfo,
        -: 1940:                        ResultWas::OfType type )
    #####: 1941:        : m_info( macroName, lineInfo, type )
    #####: 1942:        {}
        -: 1943:
        -: 1944:        template<typename T>
    #####: 1945:        MessageBuilder& operator << ( T const& value ) {
    #####: 1946:            m_stream << value;
    #####: 1947:            return *this;
        -: 1948:        }
        -: 1949:
        -: 1950:        MessageInfo m_info;
        -: 1951:        std::ostringstream m_stream;
        -: 1952:    };
        -: 1953:
        -: 1954:    class ScopedMessage {
        -: 1955:    public:
        -: 1956:        ScopedMessage( MessageBuilder const& builder );
        -: 1957:        ScopedMessage( ScopedMessage const& other );
        -: 1958:        ~ScopedMessage();
        -: 1959:
        -: 1960:        MessageInfo m_info;
        -: 1961:    };
        -: 1962:
        -: 1963:} // end namespace Catch
        -: 1964:
        -: 1965:// #included from: catch_interfaces_capture.h
        -: 1966:#define TWOBLUECUBES_CATCH_INTERFACES_CAPTURE_H_INCLUDED
        -: 1967:
        -: 1968:#include <string>
        -: 1969:
        -: 1970:namespace Catch {
        -: 1971:
        -: 1972:    class TestCase;
        -: 1973:    class AssertionResult;
        -: 1974:    struct AssertionInfo;
        -: 1975:    struct SectionInfo;
        -: 1976:    struct SectionEndInfo;
        -: 1977:    struct MessageInfo;
        -: 1978:    class ScopedMessageBuilder;
        -: 1979:    struct Counts;
        -: 1980:
        1: 1981:    struct IResultCapture {
        -: 1982:
        -: 1983:        virtual ~IResultCapture();
        -: 1984:
        -: 1985:        virtual void assertionEnded( AssertionResult const& result ) = 0;
        -: 1986:        virtual bool sectionStarted(    SectionInfo const& sectionInfo,
        -: 1987:                                        Counts& assertions ) = 0;
        -: 1988:        virtual void sectionEnded( SectionEndInfo const& endInfo ) = 0;
        -: 1989:        virtual void sectionEndedEarly( SectionEndInfo const& endInfo ) = 0;
        -: 1990:        virtual void pushScopedMessage( MessageInfo const& message ) = 0;
        -: 1991:        virtual void popScopedMessage( MessageInfo const& message ) = 0;
        -: 1992:
        -: 1993:        virtual std::string getCurrentTestName() const = 0;
        -: 1994:        virtual const AssertionResult* getLastResult() const = 0;
        -: 1995:
        -: 1996:        virtual void handleFatalErrorCondition( std::string const& message ) = 0;
        -: 1997:    };
        -: 1998:
        -: 1999:    IResultCapture& getResultCapture();
        -: 2000:}
        -: 2001:
        -: 2002:// #included from: catch_debugger.h
        -: 2003:#define TWOBLUECUBES_CATCH_DEBUGGER_H_INCLUDED
        -: 2004:
        -: 2005:// #included from: catch_platform.h
        -: 2006:#define TWOBLUECUBES_CATCH_PLATFORM_H_INCLUDED
        -: 2007:
        -: 2008:#if defined(__MAC_OS_X_VERSION_MIN_REQUIRED)
        -: 2009:#define CATCH_PLATFORM_MAC
        -: 2010:#elif  defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
        -: 2011:#define CATCH_PLATFORM_IPHONE
        -: 2012:#elif defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER)
        -: 2013:#define CATCH_PLATFORM_WINDOWS
        -: 2014:#endif
        -: 2015:
        -: 2016:#include <string>
        -: 2017:
        -: 2018:namespace Catch{
        -: 2019:
        -: 2020:    bool isDebuggerActive();
        -: 2021:    void writeToDebugConsole( std::string const& text );
        -: 2022:}
        -: 2023:
        -: 2024:#ifdef CATCH_PLATFORM_MAC
        -: 2025:
        -: 2026:    // The following code snippet based on:
        -: 2027:    // http://cocoawithlove.com/2008/03/break-into-debugger.html
        -: 2028:    #ifdef DEBUG
        -: 2029:        #if defined(__ppc64__) || defined(__ppc__)
        -: 2030:            #define CATCH_BREAK_INTO_DEBUGGER() \
        -: 2031:                if( Catch::isDebuggerActive() ) { \
        -: 2032:                    __asm__("li r0, 20\nsc\nnop\nli r0, 37\nli r4, 2\nsc\nnop\n" \
        -: 2033:                    : : : "memory","r0","r3","r4" ); \
        -: 2034:                }
        -: 2035:        #else
        -: 2036:            #define CATCH_BREAK_INTO_DEBUGGER() if( Catch::isDebuggerActive() ) {__asm__("int $3\n" : : );}
        -: 2037:        #endif
        -: 2038:    #endif
        -: 2039:
        -: 2040:#elif defined(_MSC_VER)
        -: 2041:    #define CATCH_BREAK_INTO_DEBUGGER() if( Catch::isDebuggerActive() ) { __debugbreak(); }
        -: 2042:#elif defined(__MINGW32__)
        -: 2043:    extern "C" __declspec(dllimport) void __stdcall DebugBreak();
        -: 2044:    #define CATCH_BREAK_INTO_DEBUGGER() if( Catch::isDebuggerActive() ) { DebugBreak(); }
        -: 2045:#endif
        -: 2046:
        -: 2047:#ifndef CATCH_BREAK_INTO_DEBUGGER
        -: 2048:#define CATCH_BREAK_INTO_DEBUGGER() Catch::alwaysTrue();
        -: 2049:#endif
        -: 2050:
        -: 2051:// #included from: catch_interfaces_runner.h
        -: 2052:#define TWOBLUECUBES_CATCH_INTERFACES_RUNNER_H_INCLUDED
        -: 2053:
        -: 2054:namespace Catch {
        -: 2055:    class TestCase;
        -: 2056:
        1: 2057:    struct IRunner {
        -: 2058:        virtual ~IRunner();
        -: 2059:        virtual bool aborting() const = 0;
        -: 2060:    };
        -: 2061:}
        -: 2062:
        -: 2063:///////////////////////////////////////////////////////////////////////////////
        -: 2064:// In the event of a failure works out if the debugger needs to be invoked
        -: 2065:// and/or an exception thrown and takes appropriate action.
        -: 2066:// This needs to be done as a macro so the debugger will stop in the user
        -: 2067:// source code rather than in Catch library code
        -: 2068:#define INTERNAL_CATCH_REACT( resultBuilder ) \
        -: 2069:    if( resultBuilder.shouldDebugBreak() ) CATCH_BREAK_INTO_DEBUGGER(); \
        -: 2070:    resultBuilder.react();
        -: 2071:
        -: 2072:///////////////////////////////////////////////////////////////////////////////
        -: 2073:#define INTERNAL_CATCH_TEST( expr, resultDisposition, macroName ) \
        -: 2074:    do { \
        -: 2075:        Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, #expr, resultDisposition ); \
        -: 2076:        try { \
        -: 2077:            CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \
        -: 2078:            ( __catchResult <= expr ).endExpression(); \
        -: 2079:        } \
        -: 2080:        catch( ... ) { \
        -: 2081:            __catchResult.useActiveException( Catch::ResultDisposition::Normal ); \
        -: 2082:        } \
        -: 2083:        INTERNAL_CATCH_REACT( __catchResult ) \
        -: 2084:    } while( Catch::isTrue( false && !!(expr) ) ) // expr here is never evaluated at runtime but it forces the compiler to give it a look
        -: 2085:
        -: 2086:///////////////////////////////////////////////////////////////////////////////
        -: 2087:#define INTERNAL_CATCH_IF( expr, resultDisposition, macroName ) \
        -: 2088:    INTERNAL_CATCH_TEST( expr, resultDisposition, macroName ); \
        -: 2089:    if( Catch::getResultCapture().getLastResult()->succeeded() )
        -: 2090:
        -: 2091:///////////////////////////////////////////////////////////////////////////////
        -: 2092:#define INTERNAL_CATCH_ELSE( expr, resultDisposition, macroName ) \
        -: 2093:    INTERNAL_CATCH_TEST( expr, resultDisposition, macroName ); \
        -: 2094:    if( !Catch::getResultCapture().getLastResult()->succeeded() )
        -: 2095:
        -: 2096:///////////////////////////////////////////////////////////////////////////////
        -: 2097:#define INTERNAL_CATCH_NO_THROW( expr, resultDisposition, macroName ) \
        -: 2098:    do { \
        -: 2099:        Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, #expr, resultDisposition ); \
        -: 2100:        try { \
        -: 2101:            expr; \
        -: 2102:            __catchResult.captureResult( Catch::ResultWas::Ok ); \
        -: 2103:        } \
        -: 2104:        catch( ... ) { \
        -: 2105:            __catchResult.useActiveException( resultDisposition ); \
        -: 2106:        } \
        -: 2107:        INTERNAL_CATCH_REACT( __catchResult ) \
        -: 2108:    } while( Catch::alwaysFalse() )
        -: 2109:
        -: 2110:///////////////////////////////////////////////////////////////////////////////
        -: 2111:#define INTERNAL_CATCH_THROWS( expr, resultDisposition, matcher, macroName ) \
        -: 2112:    do { \
        -: 2113:        Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, #expr, resultDisposition, #matcher ); \
        -: 2114:        if( __catchResult.allowThrows() ) \
        -: 2115:            try { \
        -: 2116:                expr; \
        -: 2117:                __catchResult.captureResult( Catch::ResultWas::DidntThrowException ); \
        -: 2118:            } \
        -: 2119:            catch( ... ) { \
        -: 2120:                __catchResult.captureExpectedException( matcher ); \
        -: 2121:            } \
        -: 2122:        else \
        -: 2123:            __catchResult.captureResult( Catch::ResultWas::Ok ); \
        -: 2124:        INTERNAL_CATCH_REACT( __catchResult ) \
        -: 2125:    } while( Catch::alwaysFalse() )
        -: 2126:
        -: 2127:///////////////////////////////////////////////////////////////////////////////
        -: 2128:#define INTERNAL_CATCH_THROWS_AS( expr, exceptionType, resultDisposition, macroName ) \
        -: 2129:    do { \
        -: 2130:        Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, #expr, resultDisposition ); \
        -: 2131:        if( __catchResult.allowThrows() ) \
        -: 2132:            try { \
        -: 2133:                expr; \
        -: 2134:                __catchResult.captureResult( Catch::ResultWas::DidntThrowException ); \
        -: 2135:            } \
        -: 2136:            catch( exceptionType ) { \
        -: 2137:                __catchResult.captureResult( Catch::ResultWas::Ok ); \
        -: 2138:            } \
        -: 2139:            catch( ... ) { \
        -: 2140:                __catchResult.useActiveException( resultDisposition ); \
        -: 2141:            } \
        -: 2142:        else \
        -: 2143:            __catchResult.captureResult( Catch::ResultWas::Ok ); \
        -: 2144:        INTERNAL_CATCH_REACT( __catchResult ) \
        -: 2145:    } while( Catch::alwaysFalse() )
        -: 2146:
        -: 2147:///////////////////////////////////////////////////////////////////////////////
        -: 2148:#ifdef CATCH_CONFIG_VARIADIC_MACROS
        -: 2149:    #define INTERNAL_CATCH_MSG( messageType, resultDisposition, macroName, ... ) \
        -: 2150:        do { \
        -: 2151:            Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, "", resultDisposition ); \
        -: 2152:            __catchResult << __VA_ARGS__ + ::Catch::StreamEndStop(); \
        -: 2153:            __catchResult.captureResult( messageType ); \
        -: 2154:            INTERNAL_CATCH_REACT( __catchResult ) \
        -: 2155:        } while( Catch::alwaysFalse() )
        -: 2156:#else
        -: 2157:    #define INTERNAL_CATCH_MSG( messageType, resultDisposition, macroName, log ) \
        -: 2158:        do { \
        -: 2159:            Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, "", resultDisposition ); \
        -: 2160:            __catchResult << log + ::Catch::StreamEndStop(); \
        -: 2161:            __catchResult.captureResult( messageType ); \
        -: 2162:            INTERNAL_CATCH_REACT( __catchResult ) \
        -: 2163:        } while( Catch::alwaysFalse() )
        -: 2164:#endif
        -: 2165:
        -: 2166:///////////////////////////////////////////////////////////////////////////////
        -: 2167:#define INTERNAL_CATCH_INFO( log, macroName ) \
        -: 2168:    Catch::ScopedMessage INTERNAL_CATCH_UNIQUE_NAME( scopedMessage ) = Catch::MessageBuilder( macroName, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info ) << log;
        -: 2169:
        -: 2170:///////////////////////////////////////////////////////////////////////////////
        -: 2171:#define INTERNAL_CHECK_THAT( arg, matcher, resultDisposition, macroName ) \
        -: 2172:    do { \
        -: 2173:        Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, #arg ", " #matcher, resultDisposition ); \
        -: 2174:        try { \
        -: 2175:            std::string matcherAsString = (matcher).toString(); \
        -: 2176:            __catchResult \
        -: 2177:                .setLhs( Catch::toString( arg ) ) \
        -: 2178:                .setRhs( matcherAsString == Catch::Detail::unprintableString ? #matcher : matcherAsString ) \
        -: 2179:                .setOp( "matches" ) \
        -: 2180:                .setResultType( (matcher).match( arg ) ); \
        -: 2181:            __catchResult.captureExpression(); \
        -: 2182:        } catch( ... ) { \
        -: 2183:            __catchResult.useActiveException( resultDisposition | Catch::ResultDisposition::ContinueOnFailure ); \
        -: 2184:        } \
        -: 2185:        INTERNAL_CATCH_REACT( __catchResult ) \
        -: 2186:    } while( Catch::alwaysFalse() )
        -: 2187:
        -: 2188:// #included from: internal/catch_section.h
        -: 2189:#define TWOBLUECUBES_CATCH_SECTION_H_INCLUDED
        -: 2190:
        -: 2191:// #included from: catch_section_info.h
        -: 2192:#define TWOBLUECUBES_CATCH_SECTION_INFO_H_INCLUDED
        -: 2193:
        -: 2194:// #included from: catch_totals.hpp
        -: 2195:#define TWOBLUECUBES_CATCH_TOTALS_HPP_INCLUDED
        -: 2196:
        -: 2197:#include <cstddef>
        -: 2198:
        -: 2199:namespace Catch {
        -: 2200:
        -: 2201:    struct Counts {
        4: 2202:        Counts() : passed( 0 ), failed( 0 ), failedButOk( 0 ) {}
        -: 2203:
    #####: 2204:        Counts operator - ( Counts const& other ) const {
    #####: 2205:            Counts diff;
    #####: 2206:            diff.passed = passed - other.passed;
    #####: 2207:            diff.failed = failed - other.failed;
    #####: 2208:            diff.failedButOk = failedButOk - other.failedButOk;
    #####: 2209:            return diff;
        -: 2210:        }
    #####: 2211:        Counts& operator += ( Counts const& other ) {
    #####: 2212:            passed += other.passed;
    #####: 2213:            failed += other.failed;
    #####: 2214:            failedButOk += other.failedButOk;
    #####: 2215:            return *this;
        -: 2216:        }
        -: 2217:
        2: 2218:        std::size_t total() const {
        2: 2219:            return passed + failed + failedButOk;
        -: 2220:        }
    #####: 2221:        bool allPassed() const {
    #####: 2222:            return failed == 0 && failedButOk == 0;
        -: 2223:        }
    #####: 2224:        bool allOk() const {
    #####: 2225:            return failed == 0;
        -: 2226:        }
        -: 2227:
        -: 2228:        std::size_t passed;
        -: 2229:        std::size_t failed;
        -: 2230:        std::size_t failedButOk;
        -: 2231:    };
        -: 2232:
        2: 2233:    struct Totals {
        -: 2234:
    #####: 2235:        Totals operator - ( Totals const& other ) const {
    #####: 2236:            Totals diff;
    #####: 2237:            diff.assertions = assertions - other.assertions;
    #####: 2238:            diff.testCases = testCases - other.testCases;
    #####: 2239:            return diff;
        -: 2240:        }
        -: 2241:
    #####: 2242:        Totals delta( Totals const& prevTotals ) const {
    #####: 2243:            Totals diff = *this - prevTotals;
    #####: 2244:            if( diff.assertions.failed > 0 )
    #####: 2245:                ++diff.testCases.failed;
    #####: 2246:            else if( diff.assertions.failedButOk > 0 )
    #####: 2247:                ++diff.testCases.failedButOk;
        -: 2248:            else
    #####: 2249:                ++diff.testCases.passed;
    #####: 2250:            return diff;
        -: 2251:        }
        -: 2252:
    #####: 2253:        Totals& operator += ( Totals const& other ) {
    #####: 2254:            assertions += other.assertions;
    #####: 2255:            testCases += other.testCases;
    #####: 2256:            return *this;
        -: 2257:        }
        -: 2258:
        -: 2259:        Counts assertions;
        -: 2260:        Counts testCases;
        -: 2261:    };
        -: 2262:}
        -: 2263:
        -: 2264:namespace Catch {
        -: 2265:
    #####: 2266:    struct SectionInfo {
        -: 2267:        SectionInfo
        -: 2268:            (   SourceLineInfo const& _lineInfo,
        -: 2269:                std::string const& _name,
        -: 2270:                std::string const& _description = std::string() );
        -: 2271:
        -: 2272:        std::string name;
        -: 2273:        std::string description;
        -: 2274:        SourceLineInfo lineInfo;
        -: 2275:    };
        -: 2276:
    #####: 2277:    struct SectionEndInfo {
    #####: 2278:        SectionEndInfo( SectionInfo const& _sectionInfo, Counts const& _prevAssertions, double _durationInSeconds )
    #####: 2279:        : sectionInfo( _sectionInfo ), prevAssertions( _prevAssertions ), durationInSeconds( _durationInSeconds )
    #####: 2280:        {}
        -: 2281:
        -: 2282:        SectionInfo sectionInfo;
        -: 2283:        Counts prevAssertions;
        -: 2284:        double durationInSeconds;
        -: 2285:    };
        -: 2286:
        -: 2287:} // end namespace Catch
        -: 2288:
        -: 2289:// #included from: catch_timer.h
        -: 2290:#define TWOBLUECUBES_CATCH_TIMER_H_INCLUDED
        -: 2291:
        -: 2292:#ifdef CATCH_PLATFORM_WINDOWS
        -: 2293:typedef unsigned long long uint64_t;
        -: 2294:#else
        -: 2295:#include <stdint.h>
        -: 2296:#endif
        -: 2297:
        -: 2298:namespace Catch {
        -: 2299:
        -: 2300:    class Timer {
        -: 2301:    public:
    #####: 2302:        Timer() : m_ticks( 0 ) {}
        -: 2303:        void start();
        -: 2304:        unsigned int getElapsedMicroseconds() const;
        -: 2305:        unsigned int getElapsedMilliseconds() const;
        -: 2306:        double getElapsedSeconds() const;
        -: 2307:
        -: 2308:    private:
        -: 2309:        uint64_t m_ticks;
        -: 2310:    };
        -: 2311:
        -: 2312:} // namespace Catch
        -: 2313:
        -: 2314:#include <string>
        -: 2315:
        -: 2316:namespace Catch {
        -: 2317:
        -: 2318:    class Section : NonCopyable {
        -: 2319:    public:
        -: 2320:        Section( SectionInfo const& info );
        -: 2321:        ~Section();
        -: 2322:
        -: 2323:        // This indicates whether the section should be executed or not
        -: 2324:        operator bool() const;
        -: 2325:
        -: 2326:    private:
        -: 2327:        SectionInfo m_info;
        -: 2328:
        -: 2329:        std::string m_name;
        -: 2330:        Counts m_assertions;
        -: 2331:        bool m_sectionIncluded;
        -: 2332:        Timer m_timer;
        -: 2333:    };
        -: 2334:
        -: 2335:} // end namespace Catch
        -: 2336:
        -: 2337:#ifdef CATCH_CONFIG_VARIADIC_MACROS
        -: 2338:    #define INTERNAL_CATCH_SECTION( ... ) \
        -: 2339:        if( Catch::Section const& INTERNAL_CATCH_UNIQUE_NAME( catch_internal_Section ) = Catch::SectionInfo( CATCH_INTERNAL_LINEINFO, __VA_ARGS__ ) )
        -: 2340:#else
        -: 2341:    #define INTERNAL_CATCH_SECTION( name, desc ) \
        -: 2342:        if( Catch::Section const& INTERNAL_CATCH_UNIQUE_NAME( catch_internal_Section ) = Catch::SectionInfo( CATCH_INTERNAL_LINEINFO, name, desc ) )
        -: 2343:#endif
        -: 2344:
        -: 2345:// #included from: internal/catch_generators.hpp
        -: 2346:#define TWOBLUECUBES_CATCH_GENERATORS_HPP_INCLUDED
        -: 2347:
        -: 2348:#include <iterator>
        -: 2349:#include <vector>
        -: 2350:#include <string>
        -: 2351:#include <stdlib.h>
        -: 2352:
        -: 2353:namespace Catch {
        -: 2354:
        -: 2355:template<typename T>
        -: 2356:struct IGenerator {
        -: 2357:    virtual ~IGenerator() {}
        -: 2358:    virtual T getValue( std::size_t index ) const = 0;
        -: 2359:    virtual std::size_t size () const = 0;
        -: 2360:};
        -: 2361:
        -: 2362:template<typename T>
        -: 2363:class BetweenGenerator : public IGenerator<T> {
        -: 2364:public:
        -: 2365:    BetweenGenerator( T from, T to ) : m_from( from ), m_to( to ){}
        -: 2366:
        -: 2367:    virtual T getValue( std::size_t index ) const {
        -: 2368:        return m_from+static_cast<int>( index );
        -: 2369:    }
        -: 2370:
        -: 2371:    virtual std::size_t size() const {
        -: 2372:        return static_cast<std::size_t>( 1+m_to-m_from );
        -: 2373:    }
        -: 2374:
        -: 2375:private:
        -: 2376:
        -: 2377:    T m_from;
        -: 2378:    T m_to;
        -: 2379:};
        -: 2380:
        -: 2381:template<typename T>
        -: 2382:class ValuesGenerator : public IGenerator<T> {
        -: 2383:public:
        -: 2384:    ValuesGenerator(){}
        -: 2385:
        -: 2386:    void add( T value ) {
        -: 2387:        m_values.push_back( value );
        -: 2388:    }
        -: 2389:
        -: 2390:    virtual T getValue( std::size_t index ) const {
        -: 2391:        return m_values[index];
        -: 2392:    }
        -: 2393:
        -: 2394:    virtual std::size_t size() const {
        -: 2395:        return m_values.size();
        -: 2396:    }
        -: 2397:
        -: 2398:private:
        -: 2399:    std::vector<T> m_values;
        -: 2400:};
        -: 2401:
        -: 2402:template<typename T>
        -: 2403:class CompositeGenerator {
        -: 2404:public:
        -: 2405:    CompositeGenerator() : m_totalSize( 0 ) {}
        -: 2406:
        -: 2407:    // *** Move semantics, similar to auto_ptr ***
        -: 2408:    CompositeGenerator( CompositeGenerator& other )
        -: 2409:    :   m_fileInfo( other.m_fileInfo ),
        -: 2410:        m_totalSize( 0 )
        -: 2411:    {
        -: 2412:        move( other );
        -: 2413:    }
        -: 2414:
        -: 2415:    CompositeGenerator& setFileInfo( const char* fileInfo ) {
        -: 2416:        m_fileInfo = fileInfo;
        -: 2417:        return *this;
        -: 2418:    }
        -: 2419:
        -: 2420:    ~CompositeGenerator() {
        -: 2421:        deleteAll( m_composed );
        -: 2422:    }
        -: 2423:
        -: 2424:    operator T () const {
        -: 2425:        size_t overallIndex = getCurrentContext().getGeneratorIndex( m_fileInfo, m_totalSize );
        -: 2426:
        -: 2427:        typename std::vector<const IGenerator<T>*>::const_iterator it = m_composed.begin();
        -: 2428:        typename std::vector<const IGenerator<T>*>::const_iterator itEnd = m_composed.end();
        -: 2429:        for( size_t index = 0; it != itEnd; ++it )
        -: 2430:        {
        -: 2431:            const IGenerator<T>* generator = *it;
        -: 2432:            if( overallIndex >= index && overallIndex < index + generator->size() )
        -: 2433:            {
        -: 2434:                return generator->getValue( overallIndex-index );
        -: 2435:            }
        -: 2436:            index += generator->size();
        -: 2437:        }
        -: 2438:        CATCH_INTERNAL_ERROR( "Indexed past end of generated range" );
        -: 2439:        return T(); // Suppress spurious "not all control paths return a value" warning in Visual Studio - if you know how to fix this please do so
        -: 2440:    }
        -: 2441:
        -: 2442:    void add( const IGenerator<T>* generator ) {
        -: 2443:        m_totalSize += generator->size();
        -: 2444:        m_composed.push_back( generator );
        -: 2445:    }
        -: 2446:
        -: 2447:    CompositeGenerator& then( CompositeGenerator& other ) {
        -: 2448:        move( other );
        -: 2449:        return *this;
        -: 2450:    }
        -: 2451:
        -: 2452:    CompositeGenerator& then( T value ) {
        -: 2453:        ValuesGenerator<T>* valuesGen = new ValuesGenerator<T>();
        -: 2454:        valuesGen->add( value );
        -: 2455:        add( valuesGen );
        -: 2456:        return *this;
        -: 2457:    }
        -: 2458:
        -: 2459:private:
        -: 2460:
        -: 2461:    void move( CompositeGenerator& other ) {
        -: 2462:        std::copy( other.m_composed.begin(), other.m_composed.end(), std::back_inserter( m_composed ) );
        -: 2463:        m_totalSize += other.m_totalSize;
        -: 2464:        other.m_composed.clear();
        -: 2465:    }
        -: 2466:
        -: 2467:    std::vector<const IGenerator<T>*> m_composed;
        -: 2468:    std::string m_fileInfo;
        -: 2469:    size_t m_totalSize;
        -: 2470:};
        -: 2471:
        -: 2472:namespace Generators
        -: 2473:{
        -: 2474:    template<typename T>
        -: 2475:    CompositeGenerator<T> between( T from, T to ) {
        -: 2476:        CompositeGenerator<T> generators;
        -: 2477:        generators.add( new BetweenGenerator<T>( from, to ) );
        -: 2478:        return generators;
        -: 2479:    }
        -: 2480:
        -: 2481:    template<typename T>
        -: 2482:    CompositeGenerator<T> values( T val1, T val2 ) {
        -: 2483:        CompositeGenerator<T> generators;
        -: 2484:        ValuesGenerator<T>* valuesGen = new ValuesGenerator<T>();
        -: 2485:        valuesGen->add( val1 );
        -: 2486:        valuesGen->add( val2 );
        -: 2487:        generators.add( valuesGen );
        -: 2488:        return generators;
        -: 2489:    }
        -: 2490:
        -: 2491:    template<typename T>
        -: 2492:    CompositeGenerator<T> values( T val1, T val2, T val3 ){
        -: 2493:        CompositeGenerator<T> generators;
        -: 2494:        ValuesGenerator<T>* valuesGen = new ValuesGenerator<T>();
        -: 2495:        valuesGen->add( val1 );
        -: 2496:        valuesGen->add( val2 );
        -: 2497:        valuesGen->add( val3 );
        -: 2498:        generators.add( valuesGen );
        -: 2499:        return generators;
        -: 2500:    }
        -: 2501:
        -: 2502:    template<typename T>
        -: 2503:    CompositeGenerator<T> values( T val1, T val2, T val3, T val4 ) {
        -: 2504:        CompositeGenerator<T> generators;
        -: 2505:        ValuesGenerator<T>* valuesGen = new ValuesGenerator<T>();
        -: 2506:        valuesGen->add( val1 );
        -: 2507:        valuesGen->add( val2 );
        -: 2508:        valuesGen->add( val3 );
        -: 2509:        valuesGen->add( val4 );
        -: 2510:        generators.add( valuesGen );
        -: 2511:        return generators;
        -: 2512:    }
        -: 2513:
        -: 2514:} // end namespace Generators
        -: 2515:
        -: 2516:using namespace Generators;
        -: 2517:
        -: 2518:} // end namespace Catch
        -: 2519:
        -: 2520:#define INTERNAL_CATCH_LINESTR2( line ) #line
        -: 2521:#define INTERNAL_CATCH_LINESTR( line ) INTERNAL_CATCH_LINESTR2( line )
        -: 2522:
        -: 2523:#define INTERNAL_CATCH_GENERATE( expr ) expr.setFileInfo( __FILE__ "(" INTERNAL_CATCH_LINESTR( __LINE__ ) ")" )
        -: 2524:
        -: 2525:// #included from: internal/catch_interfaces_exception.h
        -: 2526:#define TWOBLUECUBES_CATCH_INTERFACES_EXCEPTION_H_INCLUDED
        -: 2527:
        -: 2528:#include <string>
        -: 2529:#include <vector>
        -: 2530:
        -: 2531:// #included from: catch_interfaces_registry_hub.h
        -: 2532:#define TWOBLUECUBES_CATCH_INTERFACES_REGISTRY_HUB_H_INCLUDED
        -: 2533:
        -: 2534:#include <string>
        -: 2535:
        -: 2536:namespace Catch {
        -: 2537:
        -: 2538:    class TestCase;
        -: 2539:    struct ITestCaseRegistry;
        -: 2540:    struct IExceptionTranslatorRegistry;
        -: 2541:    struct IExceptionTranslator;
        -: 2542:    struct IReporterRegistry;
        -: 2543:    struct IReporterFactory;
        -: 2544:
        1: 2545:    struct IRegistryHub {
        -: 2546:        virtual ~IRegistryHub();
        -: 2547:
        -: 2548:        virtual IReporterRegistry const& getReporterRegistry() const = 0;
        -: 2549:        virtual ITestCaseRegistry const& getTestCaseRegistry() const = 0;
        -: 2550:        virtual IExceptionTranslatorRegistry& getExceptionTranslatorRegistry() = 0;
        -: 2551:    };
        -: 2552:
        1: 2553:    struct IMutableRegistryHub {
        -: 2554:        virtual ~IMutableRegistryHub();
        -: 2555:        virtual void registerReporter( std::string const& name, Ptr<IReporterFactory> const& factory ) = 0;
        -: 2556:        virtual void registerListener( Ptr<IReporterFactory> const& factory ) = 0;
        -: 2557:        virtual void registerTest( TestCase const& testInfo ) = 0;
        -: 2558:        virtual void registerTranslator( const IExceptionTranslator* translator ) = 0;
        -: 2559:    };
        -: 2560:
        -: 2561:    IRegistryHub& getRegistryHub();
        -: 2562:    IMutableRegistryHub& getMutableRegistryHub();
        -: 2563:    void cleanUp();
        -: 2564:    std::string translateActiveException();
        -: 2565:
        -: 2566:}
        -: 2567:
        -: 2568:namespace Catch {
        -: 2569:
        -: 2570:    typedef std::string(*exceptionTranslateFunction)();
        -: 2571:
        -: 2572:    struct IExceptionTranslator;
        -: 2573:    typedef std::vector<const IExceptionTranslator*> ExceptionTranslators;
        -: 2574:
        -: 2575:    struct IExceptionTranslator {
        -: 2576:        virtual ~IExceptionTranslator();
        -: 2577:        virtual std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) const = 0;
        -: 2578:    };
        -: 2579:
        1: 2580:    struct IExceptionTranslatorRegistry {
        -: 2581:        virtual ~IExceptionTranslatorRegistry();
        -: 2582:
        -: 2583:        virtual std::string translateActiveException() const = 0;
        -: 2584:    };
        -: 2585:
        -: 2586:    class ExceptionTranslatorRegistrar {
        -: 2587:        template<typename T>
        -: 2588:        class ExceptionTranslator : public IExceptionTranslator {
        -: 2589:        public:
        -: 2590:
        -: 2591:            ExceptionTranslator( std::string(*translateFunction)( T& ) )
        -: 2592:            : m_translateFunction( translateFunction )
        -: 2593:            {}
        -: 2594:
        -: 2595:            virtual std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) const CATCH_OVERRIDE {
        -: 2596:                try {
        -: 2597:                    if( it == itEnd )
        -: 2598:                        throw;
        -: 2599:                    else
        -: 2600:                        return (*it)->translate( it+1, itEnd );
        -: 2601:                }
        -: 2602:                catch( T& ex ) {
        -: 2603:                    return m_translateFunction( ex );
        -: 2604:                }
        -: 2605:            }
        -: 2606:
        -: 2607:        protected:
        -: 2608:            std::string(*m_translateFunction)( T& );
        -: 2609:        };
        -: 2610:
        -: 2611:    public:
        -: 2612:        template<typename T>
        -: 2613:        ExceptionTranslatorRegistrar( std::string(*translateFunction)( T& ) ) {
        -: 2614:            getMutableRegistryHub().registerTranslator
        -: 2615:                ( new ExceptionTranslator<T>( translateFunction ) );
        -: 2616:        }
        -: 2617:    };
        -: 2618:}
        -: 2619:
        -: 2620:///////////////////////////////////////////////////////////////////////////////
        -: 2621:#define INTERNAL_CATCH_TRANSLATE_EXCEPTION2( translatorName, signature ) \
        -: 2622:    static std::string translatorName( signature ); \
        -: 2623:    namespace{ Catch::ExceptionTranslatorRegistrar INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionRegistrar )( &translatorName ); }\
        -: 2624:    static std::string translatorName( signature )
        -: 2625:
        -: 2626:#define INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION2( INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator ), signature )
        -: 2627:
        -: 2628:// #included from: internal/catch_approx.hpp
        -: 2629:#define TWOBLUECUBES_CATCH_APPROX_HPP_INCLUDED
        -: 2630:
        -: 2631:#include <cmath>
        -: 2632:#include <limits>
        -: 2633:
        -: 2634:namespace Catch {
        -: 2635:namespace Detail {
        -: 2636:
        -: 2637:    class Approx {
        -: 2638:    public:
        -: 2639:        explicit Approx ( double value )
        -: 2640:        :   m_epsilon( std::numeric_limits<float>::epsilon()*100 ),
        -: 2641:            m_scale( 1.0 ),
        -: 2642:            m_value( value )
        -: 2643:        {}
        -: 2644:
        -: 2645:        Approx( Approx const& other )
        -: 2646:        :   m_epsilon( other.m_epsilon ),
        -: 2647:            m_scale( other.m_scale ),
        -: 2648:            m_value( other.m_value )
        -: 2649:        {}
        -: 2650:
        -: 2651:        static Approx custom() {
        -: 2652:            return Approx( 0 );
        -: 2653:        }
        -: 2654:
        -: 2655:        Approx operator()( double value ) {
        -: 2656:            Approx approx( value );
        -: 2657:            approx.epsilon( m_epsilon );
        -: 2658:            approx.scale( m_scale );
        -: 2659:            return approx;
        -: 2660:        }
        -: 2661:
        -: 2662:        friend bool operator == ( double lhs, Approx const& rhs ) {
        -: 2663:            // Thanks to Richard Harris for his help refining this formula
        -: 2664:            return fabs( lhs - rhs.m_value ) < rhs.m_epsilon * (rhs.m_scale + (std::max)( fabs(lhs), fabs(rhs.m_value) ) );
        -: 2665:        }
        -: 2666:
        -: 2667:        friend bool operator == ( Approx const& lhs, double rhs ) {
        -: 2668:            return operator==( rhs, lhs );
        -: 2669:        }
        -: 2670:
        -: 2671:        friend bool operator != ( double lhs, Approx const& rhs ) {
        -: 2672:            return !operator==( lhs, rhs );
        -: 2673:        }
        -: 2674:
        -: 2675:        friend bool operator != ( Approx const& lhs, double rhs ) {
        -: 2676:            return !operator==( rhs, lhs );
        -: 2677:        }
        -: 2678:
        -: 2679:        friend bool operator <= ( double lhs, Approx const& rhs )
        -: 2680:        {
        -: 2681:          return lhs < rhs.m_value || lhs == rhs;
        -: 2682:        }
        -: 2683:
        -: 2684:        friend bool operator <= ( Approx const& lhs, double rhs )
        -: 2685:        {
        -: 2686:          return lhs.m_value < rhs || lhs == rhs;
        -: 2687:        }
        -: 2688:
        -: 2689:        friend bool operator >= ( double lhs, Approx const& rhs )
        -: 2690:        {
        -: 2691:          return lhs > rhs.m_value || lhs == rhs;
        -: 2692:        }
        -: 2693:
        -: 2694:        friend bool operator >= ( Approx const& lhs, double rhs )
        -: 2695:        {
        -: 2696:          return lhs.m_value > rhs || lhs == rhs;
        -: 2697:        }
        -: 2698:
        -: 2699:        Approx& epsilon( double newEpsilon ) {
        -: 2700:            m_epsilon = newEpsilon;
        -: 2701:            return *this;
        -: 2702:        }
        -: 2703:
        -: 2704:        Approx& scale( double newScale ) {
        -: 2705:            m_scale = newScale;
        -: 2706:            return *this;
        -: 2707:        }
        -: 2708:
        -: 2709:        std::string toString() const {
        -: 2710:            std::ostringstream oss;
        -: 2711:            oss << "Approx( " << Catch::toString( m_value ) << " )";
        -: 2712:            return oss.str();
        -: 2713:        }
        -: 2714:
        -: 2715:    private:
        -: 2716:        double m_epsilon;
        -: 2717:        double m_scale;
        -: 2718:        double m_value;
        -: 2719:    };
        -: 2720:}
        -: 2721:
        -: 2722:template<>
        -: 2723:inline std::string toString<Detail::Approx>( Detail::Approx const& value ) {
        -: 2724:    return value.toString();
        -: 2725:}
        -: 2726:
        -: 2727:} // end namespace Catch
        -: 2728:
        -: 2729:// #included from: internal/catch_interfaces_tag_alias_registry.h
        -: 2730:#define TWOBLUECUBES_CATCH_INTERFACES_TAG_ALIAS_REGISTRY_H_INCLUDED
        -: 2731:
        -: 2732:// #included from: catch_tag_alias.h
        -: 2733:#define TWOBLUECUBES_CATCH_TAG_ALIAS_H_INCLUDED
        -: 2734:
        -: 2735:#include <string>
        -: 2736:
        -: 2737:namespace Catch {
        -: 2738:
    #####: 2739:    struct TagAlias {
    #####: 2740:        TagAlias( std::string _tag, SourceLineInfo _lineInfo ) : tag( _tag ), lineInfo( _lineInfo ) {}
        -: 2741:
        -: 2742:        std::string tag;
        -: 2743:        SourceLineInfo lineInfo;
        -: 2744:    };
        -: 2745:
        -: 2746:    struct RegistrarForTagAliases {
        -: 2747:        RegistrarForTagAliases( char const* alias, char const* tag, SourceLineInfo const& lineInfo );
        -: 2748:    };
        -: 2749:
        -: 2750:} // end namespace Catch
        -: 2751:
        -: 2752:#define CATCH_REGISTER_TAG_ALIAS( alias, spec ) namespace{ Catch::RegistrarForTagAliases INTERNAL_CATCH_UNIQUE_NAME( AutoRegisterTagAlias )( alias, spec, CATCH_INTERNAL_LINEINFO ); }
        -: 2753:// #included from: catch_option.hpp
        -: 2754:#define TWOBLUECUBES_CATCH_OPTION_HPP_INCLUDED
        -: 2755:
        -: 2756:namespace Catch {
        -: 2757:
        -: 2758:    // An optional type
        -: 2759:    template<typename T>
        -: 2760:    class Option {
        -: 2761:    public:
        4: 2762:        Option() : nullableValue( CATCH_NULL ) {}
    #####: 2763:        Option( T const& _value )
    #####: 2764:        : nullableValue( new( storage ) T( _value ) )
    #####: 2765:        {}
        -: 2766:        Option( Option const& _other )
        -: 2767:        : nullableValue( _other ? new( storage ) T( *_other ) : CATCH_NULL )
        -: 2768:        {}
        -: 2769:
        4: 2770:        ~Option() {
        4: 2771:            reset();
        4: 2772:        }
        -: 2773:
        -: 2774:        Option& operator= ( Option const& _other ) {
        -: 2775:            if( &_other != this ) {
        -: 2776:                reset();
        -: 2777:                if( _other )
        -: 2778:                    nullableValue = new( storage ) T( *_other );
        -: 2779:            }
        -: 2780:            return *this;
        -: 2781:        }
        2: 2782:        Option& operator = ( T const& _value ) {
        2: 2783:            reset();
        2: 2784:            nullableValue = new( storage ) T( _value );
        2: 2785:            return *this;
        -: 2786:        }
        -: 2787:
       10: 2788:        void reset() {
       10: 2789:            if( nullableValue )
        2: 2790:                nullableValue->~T();
       10: 2791:            nullableValue = CATCH_NULL;
       10: 2792:        }
        -: 2793:
    #####: 2794:        T& operator*() { return *nullableValue; }
        -: 2795:        T const& operator*() const { return *nullableValue; }
    #####: 2796:        T* operator->() { return nullableValue; }
        -: 2797:        const T* operator->() const { return nullableValue; }
        -: 2798:
    #####: 2799:        T valueOr( T const& defaultValue ) const {
    #####: 2800:            return nullableValue ? *nullableValue : defaultValue;
        -: 2801:        }
        -: 2802:
        1: 2803:        bool some() const { return nullableValue != CATCH_NULL; }
        -: 2804:        bool none() const { return nullableValue == CATCH_NULL; }
        -: 2805:
        -: 2806:        bool operator !() const { return nullableValue == CATCH_NULL; }
        1: 2807:        operator SafeBool::type() const {
        1: 2808:            return SafeBool::makeSafe( some() );
        -: 2809:        }
        -: 2810:
        -: 2811:    private:
        -: 2812:        T* nullableValue;
        -: 2813:        char storage[sizeof(T)];
        -: 2814:    };
        -: 2815:
        -: 2816:} // end namespace Catch
        -: 2817:
        -: 2818:namespace Catch {
        -: 2819:
        1: 2820:    struct ITagAliasRegistry {
        -: 2821:        virtual ~ITagAliasRegistry();
        -: 2822:        virtual Option<TagAlias> find( std::string const& alias ) const = 0;
        -: 2823:        virtual std::string expandAliases( std::string const& unexpandedTestSpec ) const = 0;
        -: 2824:
        -: 2825:        static ITagAliasRegistry const& get();
        -: 2826:    };
        -: 2827:
        -: 2828:} // end namespace Catch
        -: 2829:
        -: 2830:// These files are included here so the single_include script doesn't put them
        -: 2831:// in the conditionally compiled sections
        -: 2832:// #included from: internal/catch_test_case_info.h
        -: 2833:#define TWOBLUECUBES_CATCH_TEST_CASE_INFO_H_INCLUDED
        -: 2834:
        -: 2835:#include <string>
        -: 2836:#include <set>
        -: 2837:
        -: 2838:#ifdef __clang__
        -: 2839:#pragma clang diagnostic push
        -: 2840:#pragma clang diagnostic ignored "-Wpadded"
        -: 2841:#endif
        -: 2842:
        -: 2843:namespace Catch {
        -: 2844:
        -: 2845:    struct ITestCase;
        -: 2846:
    #####: 2847:    struct TestCaseInfo {
        -: 2848:        enum SpecialProperties{
        -: 2849:            None = 0,
        -: 2850:            IsHidden = 1 << 1,
        -: 2851:            ShouldFail = 1 << 2,
        -: 2852:            MayFail = 1 << 3,
        -: 2853:            Throws = 1 << 4
        -: 2854:        };
        -: 2855:
        -: 2856:        TestCaseInfo(   std::string const& _name,
        -: 2857:                        std::string const& _className,
        -: 2858:                        std::string const& _description,
        -: 2859:                        std::set<std::string> const& _tags,
        -: 2860:                        SourceLineInfo const& _lineInfo );
        -: 2861:
        -: 2862:        TestCaseInfo( TestCaseInfo const& other );
        -: 2863:
        -: 2864:        friend void setTags( TestCaseInfo& testCaseInfo, std::set<std::string> const& tags );
        -: 2865:
        -: 2866:        bool isHidden() const;
        -: 2867:        bool throws() const;
        -: 2868:        bool okToFail() const;
        -: 2869:        bool expectedToFail() const;
        -: 2870:
        -: 2871:        std::string name;
        -: 2872:        std::string className;
        -: 2873:        std::string description;
        -: 2874:        std::set<std::string> tags;
        -: 2875:        std::set<std::string> lcaseTags;
        -: 2876:        std::string tagsAsString;
        -: 2877:        SourceLineInfo lineInfo;
        -: 2878:        SpecialProperties properties;
        -: 2879:    };
        -: 2880:
    #####: 2881:    class TestCase : public TestCaseInfo {
        -: 2882:    public:
        -: 2883:
        -: 2884:        TestCase( ITestCase* testCase, TestCaseInfo const& info );
        -: 2885:        TestCase( TestCase const& other );
        -: 2886:
        -: 2887:        TestCase withName( std::string const& _newName ) const;
        -: 2888:
        -: 2889:        void invoke() const;
        -: 2890:
        -: 2891:        TestCaseInfo const& getTestCaseInfo() const;
        -: 2892:
        -: 2893:        void swap( TestCase& other );
        -: 2894:        bool operator == ( TestCase const& other ) const;
        -: 2895:        bool operator < ( TestCase const& other ) const;
        -: 2896:        TestCase& operator = ( TestCase const& other );
        -: 2897:
        -: 2898:    private:
        -: 2899:        Ptr<ITestCase> test;
        -: 2900:    };
        -: 2901:
        -: 2902:    TestCase makeTestCase(  ITestCase* testCase,
        -: 2903:                            std::string const& className,
        -: 2904:                            std::string const& name,
        -: 2905:                            std::string const& description,
        -: 2906:                            SourceLineInfo const& lineInfo );
        -: 2907:}
        -: 2908:
        -: 2909:#ifdef __clang__
        -: 2910:#pragma clang diagnostic pop
        -: 2911:#endif
        -: 2912:
        -: 2913:
        -: 2914:#ifdef __OBJC__
        -: 2915:// #included from: internal/catch_objc.hpp
        -: 2916:#define TWOBLUECUBES_CATCH_OBJC_HPP_INCLUDED
        -: 2917:
        -: 2918:#import <objc/runtime.h>
        -: 2919:
        -: 2920:#include <string>
        -: 2921:
        -: 2922:// NB. Any general catch headers included here must be included
        -: 2923:// in catch.hpp first to make sure they are included by the single
        -: 2924:// header for non obj-usage
        -: 2925:
        -: 2926:///////////////////////////////////////////////////////////////////////////////
        -: 2927:// This protocol is really only here for (self) documenting purposes, since
        -: 2928:// all its methods are optional.
        -: 2929:@protocol OcFixture
        -: 2930:
        -: 2931:@optional
        -: 2932:
        -: 2933:-(void) setUp;
        -: 2934:-(void) tearDown;
        -: 2935:
        -: 2936:@end
        -: 2937:
        -: 2938:namespace Catch {
        -: 2939:
        -: 2940:    class OcMethod : public SharedImpl<ITestCase> {
        -: 2941:
        -: 2942:    public:
        -: 2943:        OcMethod( Class cls, SEL sel ) : m_cls( cls ), m_sel( sel ) {}
        -: 2944:
        -: 2945:        virtual void invoke() const {
        -: 2946:            id obj = [[m_cls alloc] init];
        -: 2947:
        -: 2948:            performOptionalSelector( obj, @selector(setUp)  );
        -: 2949:            performOptionalSelector( obj, m_sel );
        -: 2950:            performOptionalSelector( obj, @selector(tearDown)  );
        -: 2951:
        -: 2952:            arcSafeRelease( obj );
        -: 2953:        }
        -: 2954:    private:
        -: 2955:        virtual ~OcMethod() {}
        -: 2956:
        -: 2957:        Class m_cls;
        -: 2958:        SEL m_sel;
        -: 2959:    };
        -: 2960:
        -: 2961:    namespace Detail{
        -: 2962:
        -: 2963:        inline std::string getAnnotation(   Class cls,
        -: 2964:                                            std::string const& annotationName,
        -: 2965:                                            std::string const& testCaseName ) {
        -: 2966:            NSString* selStr = [[NSString alloc] initWithFormat:@"Catch_%s_%s", annotationName.c_str(), testCaseName.c_str()];
        -: 2967:            SEL sel = NSSelectorFromString( selStr );
        -: 2968:            arcSafeRelease( selStr );
        -: 2969:            id value = performOptionalSelector( cls, sel );
        -: 2970:            if( value )
        -: 2971:                return [(NSString*)value UTF8String];
        -: 2972:            return "";
        -: 2973:        }
        -: 2974:    }
        -: 2975:
        -: 2976:    inline size_t registerTestMethods() {
        -: 2977:        size_t noTestMethods = 0;
        -: 2978:        int noClasses = objc_getClassList( CATCH_NULL, 0 );
        -: 2979:
        -: 2980:        Class* classes = (CATCH_UNSAFE_UNRETAINED Class *)malloc( sizeof(Class) * noClasses);
        -: 2981:        objc_getClassList( classes, noClasses );
        -: 2982:
        -: 2983:        for( int c = 0; c < noClasses; c++ ) {
        -: 2984:            Class cls = classes[c];
        -: 2985:            {
        -: 2986:                u_int count;
        -: 2987:                Method* methods = class_copyMethodList( cls, &count );
        -: 2988:                for( u_int m = 0; m < count ; m++ ) {
        -: 2989:                    SEL selector = method_getName(methods[m]);
        -: 2990:                    std::string methodName = sel_getName(selector);
        -: 2991:                    if( startsWith( methodName, "Catch_TestCase_" ) ) {
        -: 2992:                        std::string testCaseName = methodName.substr( 15 );
        -: 2993:                        std::string name = Detail::getAnnotation( cls, "Name", testCaseName );
        -: 2994:                        std::string desc = Detail::getAnnotation( cls, "Description", testCaseName );
        -: 2995:                        const char* className = class_getName( cls );
        -: 2996:
        -: 2997:                        getMutableRegistryHub().registerTest( makeTestCase( new OcMethod( cls, selector ), className, name.c_str(), desc.c_str(), SourceLineInfo() ) );
        -: 2998:                        noTestMethods++;
        -: 2999:                    }
        -: 3000:                }
        -: 3001:                free(methods);
        -: 3002:            }
        -: 3003:        }
        -: 3004:        return noTestMethods;
        -: 3005:    }
        -: 3006:
        -: 3007:    namespace Matchers {
        -: 3008:        namespace Impl {
        -: 3009:        namespace NSStringMatchers {
        -: 3010:
        -: 3011:            template<typename MatcherT>
        -: 3012:            struct StringHolder : MatcherImpl<MatcherT, NSString*>{
        -: 3013:                StringHolder( NSString* substr ) : m_substr( [substr copy] ){}
        -: 3014:                StringHolder( StringHolder const& other ) : m_substr( [other.m_substr copy] ){}
        -: 3015:                StringHolder() {
        -: 3016:                    arcSafeRelease( m_substr );
        -: 3017:                }
        -: 3018:
        -: 3019:                NSString* m_substr;
        -: 3020:            };
        -: 3021:
        -: 3022:            struct Equals : StringHolder<Equals> {
        -: 3023:                Equals( NSString* substr ) : StringHolder( substr ){}
        -: 3024:
        -: 3025:                virtual bool match( ExpressionType const& str ) const {
        -: 3026:                    return  (str != nil || m_substr == nil ) &&
        -: 3027:                            [str isEqualToString:m_substr];
        -: 3028:                }
        -: 3029:
        -: 3030:                virtual std::string toString() const {
        -: 3031:                    return "equals string: " + Catch::toString( m_substr );
        -: 3032:                }
        -: 3033:            };
        -: 3034:
        -: 3035:            struct Contains : StringHolder<Contains> {
        -: 3036:                Contains( NSString* substr ) : StringHolder( substr ){}
        -: 3037:
        -: 3038:                virtual bool match( ExpressionType const& str ) const {
        -: 3039:                    return  (str != nil || m_substr == nil ) &&
        -: 3040:                            [str rangeOfString:m_substr].location != NSNotFound;
        -: 3041:                }
        -: 3042:
        -: 3043:                virtual std::string toString() const {
        -: 3044:                    return "contains string: " + Catch::toString( m_substr );
        -: 3045:                }
        -: 3046:            };
        -: 3047:
        -: 3048:            struct StartsWith : StringHolder<StartsWith> {
        -: 3049:                StartsWith( NSString* substr ) : StringHolder( substr ){}
        -: 3050:
        -: 3051:                virtual bool match( ExpressionType const& str ) const {
        -: 3052:                    return  (str != nil || m_substr == nil ) &&
        -: 3053:                            [str rangeOfString:m_substr].location == 0;
        -: 3054:                }
        -: 3055:
        -: 3056:                virtual std::string toString() const {
        -: 3057:                    return "starts with: " + Catch::toString( m_substr );
        -: 3058:                }
        -: 3059:            };
        -: 3060:            struct EndsWith : StringHolder<EndsWith> {
        -: 3061:                EndsWith( NSString* substr ) : StringHolder( substr ){}
        -: 3062:
        -: 3063:                virtual bool match( ExpressionType const& str ) const {
        -: 3064:                    return  (str != nil || m_substr == nil ) &&
        -: 3065:                            [str rangeOfString:m_substr].location == [str length] - [m_substr length];
        -: 3066:                }
        -: 3067:
        -: 3068:                virtual std::string toString() const {
        -: 3069:                    return "ends with: " + Catch::toString( m_substr );
        -: 3070:                }
        -: 3071:            };
        -: 3072:
        -: 3073:        } // namespace NSStringMatchers
        -: 3074:        } // namespace Impl
        -: 3075:
        -: 3076:        inline Impl::NSStringMatchers::Equals
        -: 3077:            Equals( NSString* substr ){ return Impl::NSStringMatchers::Equals( substr ); }
        -: 3078:
        -: 3079:        inline Impl::NSStringMatchers::Contains
        -: 3080:            Contains( NSString* substr ){ return Impl::NSStringMatchers::Contains( substr ); }
        -: 3081:
        -: 3082:        inline Impl::NSStringMatchers::StartsWith
        -: 3083:            StartsWith( NSString* substr ){ return Impl::NSStringMatchers::StartsWith( substr ); }
        -: 3084:
        -: 3085:        inline Impl::NSStringMatchers::EndsWith
        -: 3086:            EndsWith( NSString* substr ){ return Impl::NSStringMatchers::EndsWith( substr ); }
        -: 3087:
        -: 3088:    } // namespace Matchers
        -: 3089:
        -: 3090:    using namespace Matchers;
        -: 3091:
        -: 3092:} // namespace Catch
        -: 3093:
        -: 3094:///////////////////////////////////////////////////////////////////////////////
        -: 3095:#define OC_TEST_CASE( name, desc )\
        -: 3096:+(NSString*) INTERNAL_CATCH_UNIQUE_NAME( Catch_Name_test ) \
        -: 3097:{\
        -: 3098:return @ name; \
        -: 3099:}\
        -: 3100:+(NSString*) INTERNAL_CATCH_UNIQUE_NAME( Catch_Description_test ) \
        -: 3101:{ \
        -: 3102:return @ desc; \
        -: 3103:} \
        -: 3104:-(void) INTERNAL_CATCH_UNIQUE_NAME( Catch_TestCase_test )
        -: 3105:
        -: 3106:#endif
        -: 3107:
        -: 3108:#ifdef CATCH_IMPL
        -: 3109:// #included from: internal/catch_impl.hpp
        -: 3110:#define TWOBLUECUBES_CATCH_IMPL_HPP_INCLUDED
        -: 3111:
        -: 3112:// Collect all the implementation files together here
        -: 3113:// These are the equivalent of what would usually be cpp files
        -: 3114:
        -: 3115:#ifdef __clang__
        -: 3116:#pragma clang diagnostic push
        -: 3117:#pragma clang diagnostic ignored "-Wweak-vtables"
        -: 3118:#endif
        -: 3119:
        -: 3120:// #included from: ../catch_session.hpp
        -: 3121:#define TWOBLUECUBES_CATCH_RUNNER_HPP_INCLUDED
        -: 3122:
        -: 3123:// #included from: internal/catch_commandline.hpp
        -: 3124:#define TWOBLUECUBES_CATCH_COMMANDLINE_HPP_INCLUDED
        -: 3125:
        -: 3126:// #included from: catch_config.hpp
        -: 3127:#define TWOBLUECUBES_CATCH_CONFIG_HPP_INCLUDED
        -: 3128:
        -: 3129:// #included from: catch_test_spec_parser.hpp
        -: 3130:#define TWOBLUECUBES_CATCH_TEST_SPEC_PARSER_HPP_INCLUDED
        -: 3131:
        -: 3132:#ifdef __clang__
        -: 3133:#pragma clang diagnostic push
        -: 3134:#pragma clang diagnostic ignored "-Wpadded"
        -: 3135:#endif
        -: 3136:
        -: 3137:// #included from: catch_test_spec.hpp
        -: 3138:#define TWOBLUECUBES_CATCH_TEST_SPEC_HPP_INCLUDED
        -: 3139:
        -: 3140:#ifdef __clang__
        -: 3141:#pragma clang diagnostic push
        -: 3142:#pragma clang diagnostic ignored "-Wpadded"
        -: 3143:#endif
        -: 3144:
        -: 3145:// #included from: catch_wildcard_pattern.hpp
        -: 3146:#define TWOBLUECUBES_CATCH_WILDCARD_PATTERN_HPP_INCLUDED
        -: 3147:
        -: 3148:namespace Catch
        -: 3149:{
        -: 3150:    class WildcardPattern {
        -: 3151:        enum WildcardPosition {
        -: 3152:            NoWildcard = 0,
        -: 3153:            WildcardAtStart = 1,
        -: 3154:            WildcardAtEnd = 2,
        -: 3155:            WildcardAtBothEnds = WildcardAtStart | WildcardAtEnd
        -: 3156:        };
        -: 3157:
        -: 3158:    public:
        -: 3159:
    #####: 3160:        WildcardPattern( std::string const& pattern, CaseSensitive::Choice caseSensitivity )
        -: 3161:        :   m_caseSensitivity( caseSensitivity ),
        -: 3162:            m_wildcard( NoWildcard ),
    #####: 3163:            m_pattern( adjustCase( pattern ) )
        -: 3164:        {
    #####: 3165:            if( startsWith( m_pattern, "*" ) ) {
    #####: 3166:                m_pattern = m_pattern.substr( 1 );
    #####: 3167:                m_wildcard = WildcardAtStart;
        -: 3168:            }
    #####: 3169:            if( endsWith( m_pattern, "*" ) ) {
    #####: 3170:                m_pattern = m_pattern.substr( 0, m_pattern.size()-1 );
    #####: 3171:                m_wildcard = static_cast<WildcardPosition>( m_wildcard | WildcardAtEnd );
        -: 3172:            }
    #####: 3173:        }
        -: 3174:        virtual ~WildcardPattern();
    #####: 3175:        virtual bool matches( std::string const& str ) const {
    #####: 3176:            switch( m_wildcard ) {
        -: 3177:                case NoWildcard:
    #####: 3178:                    return m_pattern == adjustCase( str );
        -: 3179:                case WildcardAtStart:
    #####: 3180:                    return endsWith( adjustCase( str ), m_pattern );
        -: 3181:                case WildcardAtEnd:
    #####: 3182:                    return startsWith( adjustCase( str ), m_pattern );
        -: 3183:                case WildcardAtBothEnds:
    #####: 3184:                    return contains( adjustCase( str ), m_pattern );
        -: 3185:            }
        -: 3186:
        -: 3187:#ifdef __clang__
        -: 3188:#pragma clang diagnostic push
        -: 3189:#pragma clang diagnostic ignored "-Wunreachable-code"
        -: 3190:#endif
    #####: 3191:            throw std::logic_error( "Unknown enum" );
        -: 3192:#ifdef __clang__
        -: 3193:#pragma clang diagnostic pop
        -: 3194:#endif
        -: 3195:        }
        -: 3196:    private:
    #####: 3197:        std::string adjustCase( std::string const& str ) const {
    #####: 3198:            return m_caseSensitivity == CaseSensitive::No ? toLower( str ) : str;
        -: 3199:        }
        -: 3200:        CaseSensitive::Choice m_caseSensitivity;
        -: 3201:        WildcardPosition m_wildcard;
        -: 3202:        std::string m_pattern;
        -: 3203:    };
        -: 3204:}
        -: 3205:
        -: 3206:#include <string>
        -: 3207:#include <vector>
        -: 3208:
        -: 3209:namespace Catch {
        -: 3210:
        9: 3211:    class TestSpec {
        2: 3212:        struct Pattern : SharedImpl<> {
        -: 3213:            virtual ~Pattern();
        -: 3214:            virtual bool matches( TestCaseInfo const& testCase ) const = 0;
        -: 3215:        };
        -: 3216:        class NamePattern : public Pattern {
        -: 3217:        public:
    #####: 3218:            NamePattern( std::string const& name )
    #####: 3219:            : m_wildcardPattern( toLower( name ), CaseSensitive::No )
    #####: 3220:            {}
        -: 3221:            virtual ~NamePattern();
    #####: 3222:            virtual bool matches( TestCaseInfo const& testCase ) const {
    #####: 3223:                return m_wildcardPattern.matches( toLower( testCase.name ) );
        -: 3224:            }
        -: 3225:        private:
        -: 3226:            WildcardPattern m_wildcardPattern;
        -: 3227:        };
        -: 3228:
        -: 3229:        class TagPattern : public Pattern {
        -: 3230:        public:
        1: 3231:            TagPattern( std::string const& tag ) : m_tag( toLower( tag ) ) {}
        -: 3232:            virtual ~TagPattern();
    #####: 3233:            virtual bool matches( TestCaseInfo const& testCase ) const {
    #####: 3234:                return testCase.lcaseTags.find( m_tag ) != testCase.lcaseTags.end();
        -: 3235:            }
        -: 3236:        private:
        -: 3237:            std::string m_tag;
        -: 3238:        };
        -: 3239:
        -: 3240:        class ExcludedPattern : public Pattern {
        -: 3241:        public:
        1: 3242:            ExcludedPattern( Ptr<Pattern> const& underlyingPattern ) : m_underlyingPattern( underlyingPattern ) {}
        -: 3243:            virtual ~ExcludedPattern();
    #####: 3244:            virtual bool matches( TestCaseInfo const& testCase ) const { return !m_underlyingPattern->matches( testCase ); }
        -: 3245:        private:
        -: 3246:            Ptr<Pattern> m_underlyingPattern;
        -: 3247:        };
        -: 3248:
        9: 3249:        struct Filter {
        -: 3250:            std::vector<Ptr<Pattern> > m_patterns;
        -: 3251:
    #####: 3252:            bool matches( TestCaseInfo const& testCase ) const {
        -: 3253:                // All patterns in a filter must match for the filter to be a match
    #####: 3254:                for( std::vector<Ptr<Pattern> >::const_iterator it = m_patterns.begin(), itEnd = m_patterns.end(); it != itEnd; ++it ) {
    #####: 3255:                    if( !(*it)->matches( testCase ) )
    #####: 3256:                        return false;
        -: 3257:                }
    #####: 3258:                return true;
        -: 3259:            }
        -: 3260:        };
        -: 3261:
        -: 3262:    public:
        1: 3263:        bool hasFilters() const {
        1: 3264:            return !m_filters.empty();
        -: 3265:        }
    #####: 3266:        bool matches( TestCaseInfo const& testCase ) const {
        -: 3267:            // A TestSpec matches if any filter matches
    #####: 3268:            for( std::vector<Filter>::const_iterator it = m_filters.begin(), itEnd = m_filters.end(); it != itEnd; ++it )
    #####: 3269:                if( it->matches( testCase ) )
    #####: 3270:                    return true;
    #####: 3271:            return false;
        -: 3272:        }
        -: 3273:
        -: 3274:    private:
        -: 3275:        std::vector<Filter> m_filters;
        -: 3276:
        -: 3277:        friend class TestSpecParser;
        -: 3278:    };
        -: 3279:}
        -: 3280:
        -: 3281:#ifdef __clang__
        -: 3282:#pragma clang diagnostic pop
        -: 3283:#endif
        -: 3284:
        -: 3285:namespace Catch {
        -: 3286:
        1: 3287:    class TestSpecParser {
        -: 3288:        enum Mode{ None, Name, QuotedName, Tag, EscapedName };
        -: 3289:        Mode m_mode;
        -: 3290:        bool m_exclusion;
        -: 3291:        std::size_t m_start, m_pos;
        -: 3292:        std::string m_arg;
        -: 3293:        std::vector<std::size_t> m_escapeChars;
        -: 3294:        TestSpec::Filter m_currentFilter;
        -: 3295:        TestSpec m_testSpec;
        -: 3296:        ITagAliasRegistry const* m_tagAliases;
        -: 3297:
        -: 3298:    public:
        1: 3299:        TestSpecParser( ITagAliasRegistry const& tagAliases ) : m_tagAliases( &tagAliases ) {}
        -: 3300:
        1: 3301:        TestSpecParser& parse( std::string const& arg ) {
        1: 3302:            m_mode = None;
        1: 3303:            m_exclusion = false;
        1: 3304:            m_start = std::string::npos;
        1: 3305:            m_arg = m_tagAliases->expandAliases( arg );
        1: 3306:            m_escapeChars.clear();
        4: 3307:            for( m_pos = 0; m_pos < m_arg.size(); ++m_pos )
        3: 3308:                visitChar( m_arg[m_pos] );
        1: 3309:            if( m_mode == Name )
    #####: 3310:                addPattern<TestSpec::NamePattern>();
        1: 3311:            return *this;
        -: 3312:        }
        1: 3313:        TestSpec testSpec() {
        1: 3314:            addFilter();
        1: 3315:            return m_testSpec;
        -: 3316:        }
        -: 3317:    private:
        3: 3318:        void visitChar( char c ) {
        3: 3319:            if( m_mode == None ) {
        2: 3320:                switch( c ) {
    #####: 3321:                case ' ': return;
        1: 3322:                case '~': m_exclusion = true; return;
        1: 3323:                case '[': return startNewMode( Tag, ++m_pos );
    #####: 3324:                case '"': return startNewMode( QuotedName, ++m_pos );
    #####: 3325:                case '\\': return escape();
    #####: 3326:                default: startNewMode( Name, m_pos ); break;
        -: 3327:                }
        -: 3328:            }
        1: 3329:            if( m_mode == Name ) {
    #####: 3330:                if( c == ',' ) {
    #####: 3331:                    addPattern<TestSpec::NamePattern>();
    #####: 3332:                    addFilter();
        -: 3333:                }
    #####: 3334:                else if( c == '[' ) {
    #####: 3335:                    if( subString() == "exclude:" )
    #####: 3336:                        m_exclusion = true;
        -: 3337:                    else
    #####: 3338:                        addPattern<TestSpec::NamePattern>();
    #####: 3339:                    startNewMode( Tag, ++m_pos );
        -: 3340:                }
    #####: 3341:                else if( c == '\\' )
    #####: 3342:                    escape();
        -: 3343:            }
        1: 3344:            else if( m_mode == EscapedName )
    #####: 3345:                m_mode = Name;
        1: 3346:            else if( m_mode == QuotedName && c == '"' )
    #####: 3347:                addPattern<TestSpec::NamePattern>();
        1: 3348:            else if( m_mode == Tag && c == ']' )
        1: 3349:                addPattern<TestSpec::TagPattern>();
        -: 3350:        }
        1: 3351:        void startNewMode( Mode mode, std::size_t start ) {
        1: 3352:            m_mode = mode;
        1: 3353:            m_start = start;
        1: 3354:        }
    #####: 3355:        void escape() {
    #####: 3356:            m_mode = EscapedName;
    #####: 3357:            m_escapeChars.push_back( m_pos );
    #####: 3358:        }
        1: 3359:        std::string subString() const { return m_arg.substr( m_start, m_pos - m_start ); }
        -: 3360:        template<typename T>
        1: 3361:        void addPattern() {
        2: 3362:            std::string token = subString();
        1: 3363:            for( size_t i = 0; i < m_escapeChars.size(); ++i )
    #####: 3364:                token = token.substr( 0, m_escapeChars[i] ) + token.substr( m_escapeChars[i]+1 );
        1: 3365:            m_escapeChars.clear();
        1: 3366:            if( startsWith( token, "exclude:" ) ) {
    #####: 3367:                m_exclusion = true;
    #####: 3368:                token = token.substr( 8 );
        -: 3369:            }
        1: 3370:            if( !token.empty() ) {
        2: 3371:                Ptr<TestSpec::Pattern> pattern = new T( token );
        1: 3372:                if( m_exclusion )
        1: 3373:                    pattern = new TestSpec::ExcludedPattern( pattern );
        1: 3374:                m_currentFilter.m_patterns.push_back( pattern );
        -: 3375:            }
        1: 3376:            m_exclusion = false;
        1: 3377:            m_mode = None;
        1: 3378:        }
        1: 3379:        void addFilter() {
        1: 3380:            if( !m_currentFilter.m_patterns.empty() ) {
        1: 3381:                m_testSpec.m_filters.push_back( m_currentFilter );
        1: 3382:                m_currentFilter = TestSpec::Filter();
        -: 3383:            }
        1: 3384:        }
        -: 3385:    };
        -: 3386:    inline TestSpec parseTestSpec( std::string const& arg ) {
        -: 3387:        return TestSpecParser( ITagAliasRegistry::get() ).parse( arg ).testSpec();
        -: 3388:    }
        -: 3389:
        -: 3390:} // namespace Catch
        -: 3391:
        -: 3392:#ifdef __clang__
        -: 3393:#pragma clang diagnostic pop
        -: 3394:#endif
        -: 3395:
        -: 3396:// #included from: catch_interfaces_config.h
        -: 3397:#define TWOBLUECUBES_CATCH_INTERFACES_CONFIG_H_INCLUDED
        -: 3398:
        -: 3399:#include <iostream>
        -: 3400:#include <string>
        -: 3401:#include <vector>
        -: 3402:
        -: 3403:namespace Catch {
        -: 3404:
        -: 3405:    struct Verbosity { enum Level {
        -: 3406:        NoOutput = 0,
        -: 3407:        Quiet,
        -: 3408:        Normal
        -: 3409:    }; };
        -: 3410:
        -: 3411:    struct WarnAbout { enum What {
        -: 3412:        Nothing = 0x00,
        -: 3413:        NoAssertions = 0x01
        -: 3414:    }; };
        -: 3415:
        -: 3416:    struct ShowDurations { enum OrNot {
        -: 3417:        DefaultForReporter,
        -: 3418:        Always,
        -: 3419:        Never
        -: 3420:    }; };
        -: 3421:    struct RunTests { enum InWhatOrder {
        -: 3422:        InDeclarationOrder,
        -: 3423:        InLexicographicalOrder,
        -: 3424:        InRandomOrder
        -: 3425:    }; };
        -: 3426:    struct UseColour { enum YesOrNo {
        -: 3427:        Auto,
        -: 3428:        Yes,
        -: 3429:        No
        -: 3430:    }; };
        -: 3431:
        -: 3432:    class TestSpec;
        -: 3433:
        1: 3434:    struct IConfig : IShared {
        -: 3435:
        -: 3436:        virtual ~IConfig();
        -: 3437:
        -: 3438:        virtual bool allowThrows() const = 0;
        -: 3439:        virtual std::ostream& stream() const = 0;
        -: 3440:        virtual std::string name() const = 0;
        -: 3441:        virtual bool includeSuccessfulResults() const = 0;
        -: 3442:        virtual bool shouldDebugBreak() const = 0;
        -: 3443:        virtual bool warnAboutMissingAssertions() const = 0;
        -: 3444:        virtual int abortAfter() const = 0;
        -: 3445:        virtual bool showInvisibles() const = 0;
        -: 3446:        virtual ShowDurations::OrNot showDurations() const = 0;
        -: 3447:        virtual TestSpec const& testSpec() const = 0;
        -: 3448:        virtual RunTests::InWhatOrder runOrder() const = 0;
        -: 3449:        virtual unsigned int rngSeed() const = 0;
        -: 3450:        virtual UseColour::YesOrNo useColour() const = 0;
        -: 3451:    };
        -: 3452:}
        -: 3453:
        -: 3454:// #included from: catch_stream.h
        -: 3455:#define TWOBLUECUBES_CATCH_STREAM_H_INCLUDED
        -: 3456:
        -: 3457:// #included from: catch_streambuf.h
        -: 3458:#define TWOBLUECUBES_CATCH_STREAMBUF_H_INCLUDED
        -: 3459:
        -: 3460:#include <streambuf>
        -: 3461:
        -: 3462:namespace Catch {
        -: 3463:
    #####: 3464:    class StreamBufBase : public std::streambuf {
        -: 3465:    public:
        -: 3466:        virtual ~StreamBufBase() CATCH_NOEXCEPT;
        -: 3467:    };
        -: 3468:}
        -: 3469:
        -: 3470:#include <streambuf>
        -: 3471:#include <ostream>
        -: 3472:#include <fstream>
        -: 3473:#include <memory>
        -: 3474:
        -: 3475:namespace Catch {
        -: 3476:
        -: 3477:    std::ostream& cout();
        -: 3478:    std::ostream& cerr();
        -: 3479:
        1: 3480:    struct IStream {
        -: 3481:        virtual ~IStream() CATCH_NOEXCEPT;
        -: 3482:        virtual std::ostream& stream() const = 0;
        -: 3483:    };
        -: 3484:
        -: 3485:    class FileStream : public IStream {
        -: 3486:        mutable std::ofstream m_ofs;
        -: 3487:    public:
        -: 3488:        FileStream( std::string const& filename );
        -: 3489:        virtual ~FileStream() CATCH_NOEXCEPT;
        -: 3490:    public: // IStream
        -: 3491:        virtual std::ostream& stream() const CATCH_OVERRIDE;
        -: 3492:    };
        -: 3493:
        -: 3494:    class CoutStream : public IStream {
        -: 3495:        mutable std::ostream m_os;
        -: 3496:    public:
        -: 3497:        CoutStream();
        -: 3498:        virtual ~CoutStream() CATCH_NOEXCEPT;
        -: 3499:
        -: 3500:    public: // IStream
        -: 3501:        virtual std::ostream& stream() const CATCH_OVERRIDE;
        -: 3502:    };
        -: 3503:
        -: 3504:    class DebugOutStream : public IStream {
        -: 3505:        CATCH_AUTO_PTR( StreamBufBase ) m_streamBuf;
        -: 3506:        mutable std::ostream m_os;
        -: 3507:    public:
        -: 3508:        DebugOutStream();
        -: 3509:        virtual ~DebugOutStream() CATCH_NOEXCEPT;
        -: 3510:
        -: 3511:    public: // IStream
        -: 3512:        virtual std::ostream& stream() const CATCH_OVERRIDE;
        -: 3513:    };
        -: 3514:}
        -: 3515:
        -: 3516:#include <memory>
        -: 3517:#include <vector>
        -: 3518:#include <string>
        -: 3519:#include <iostream>
        -: 3520:#include <ctime>
        -: 3521:
        -: 3522:#ifndef CATCH_CONFIG_CONSOLE_WIDTH
        -: 3523:#define CATCH_CONFIG_CONSOLE_WIDTH 80
        -: 3524:#endif
        -: 3525:
        -: 3526:namespace Catch {
        -: 3527:
        3: 3528:    struct ConfigData {
        -: 3529:
        1: 3530:        ConfigData()
        -: 3531:        :   listTests( false ),
        -: 3532:            listTags( false ),
        -: 3533:            listReporters( false ),
        -: 3534:            listTestNamesOnly( false ),
        -: 3535:            showSuccessfulTests( false ),
        -: 3536:            shouldDebugBreak( false ),
        -: 3537:            noThrow( false ),
        -: 3538:            showHelp( false ),
        -: 3539:            showInvisibles( false ),
        -: 3540:            filenamesAsTags( false ),
        -: 3541:            abortAfter( -1 ),
        -: 3542:            rngSeed( 0 ),
        -: 3543:            verbosity( Verbosity::Normal ),
        -: 3544:            warnings( WarnAbout::Nothing ),
        -: 3545:            showDurations( ShowDurations::DefaultForReporter ),
        -: 3546:            runOrder( RunTests::InDeclarationOrder ),
        1: 3547:            useColour( UseColour::Auto )
        1: 3548:        {}
        -: 3549:
        -: 3550:        bool listTests;
        -: 3551:        bool listTags;
        -: 3552:        bool listReporters;
        -: 3553:        bool listTestNamesOnly;
        -: 3554:
        -: 3555:        bool showSuccessfulTests;
        -: 3556:        bool shouldDebugBreak;
        -: 3557:        bool noThrow;
        -: 3558:        bool showHelp;
        -: 3559:        bool showInvisibles;
        -: 3560:        bool filenamesAsTags;
        -: 3561:
        -: 3562:        int abortAfter;
        -: 3563:        unsigned int rngSeed;
        -: 3564:
        -: 3565:        Verbosity::Level verbosity;
        -: 3566:        WarnAbout::What warnings;
        -: 3567:        ShowDurations::OrNot showDurations;
        -: 3568:        RunTests::InWhatOrder runOrder;
        -: 3569:        UseColour::YesOrNo useColour;
        -: 3570:
        -: 3571:        std::string outputFilename;
        -: 3572:        std::string name;
        -: 3573:        std::string processName;
        -: 3574:
        -: 3575:        std::vector<std::string> reporterNames;
        -: 3576:        std::vector<std::string> testsOrTags;
        -: 3577:    };
        -: 3578:
        -: 3579:    class Config : public SharedImpl<IConfig> {
        -: 3580:    private:
        -: 3581:        Config( Config const& other );
        -: 3582:        Config& operator = ( Config const& other );
        -: 3583:        virtual void dummy();
        -: 3584:    public:
        -: 3585:
        -: 3586:        Config()
        -: 3587:        {}
        -: 3588:
        1: 3589:        Config( ConfigData const& data )
        -: 3590:        :   m_data( data ),
        1: 3591:            m_stream( openStream() )
        -: 3592:        {
        1: 3593:            if( !data.testsOrTags.empty() ) {
    #####: 3594:                TestSpecParser parser( ITagAliasRegistry::get() );
    #####: 3595:                for( std::size_t i = 0; i < data.testsOrTags.size(); ++i )
    #####: 3596:                    parser.parse( data.testsOrTags[i] );
    #####: 3597:                m_testSpec = parser.testSpec();
        -: 3598:            }
        1: 3599:        }
        -: 3600:
        2: 3601:        virtual ~Config() {
        2: 3602:        }
        -: 3603:
        -: 3604:        std::string const& getFilename() const {
        -: 3605:            return m_data.outputFilename ;
        -: 3606:        }
        -: 3607:
        1: 3608:        bool listTests() const { return m_data.listTests; }
        1: 3609:        bool listTestNamesOnly() const { return m_data.listTestNamesOnly; }
        1: 3610:        bool listTags() const { return m_data.listTags; }
        1: 3611:        bool listReporters() const { return m_data.listReporters; }
        -: 3612:
        -: 3613:        std::string getProcessName() const { return m_data.processName; }
        -: 3614:
    #####: 3615:        bool shouldDebugBreak() const { return m_data.shouldDebugBreak; }
        -: 3616:
        1: 3617:        std::vector<std::string> getReporterNames() const { return m_data.reporterNames; }
        -: 3618:
        2: 3619:        int abortAfter() const { return m_data.abortAfter; }
        -: 3620:
        1: 3621:        TestSpec const& testSpec() const { return m_testSpec; }
        -: 3622:
        -: 3623:        bool showHelp() const { return m_data.showHelp; }
    #####: 3624:        bool showInvisibles() const { return m_data.showInvisibles; }
        -: 3625:
        -: 3626:        // IConfig interface
    #####: 3627:        virtual bool allowThrows() const        { return !m_data.noThrow; }
        1: 3628:        virtual std::ostream& stream() const    { return m_stream->stream(); }
        3: 3629:        virtual std::string name() const        { return m_data.name.empty() ? m_data.processName : m_data.name; }
    #####: 3630:        virtual bool includeSuccessfulResults() const   { return m_data.showSuccessfulTests; }
    #####: 3631:        virtual bool warnAboutMissingAssertions() const { return m_data.warnings & WarnAbout::NoAssertions; }
    #####: 3632:        virtual ShowDurations::OrNot showDurations() const { return m_data.showDurations; }
        3: 3633:        virtual RunTests::InWhatOrder runOrder() const  { return m_data.runOrder; }
        1: 3634:        virtual unsigned int rngSeed() const    { return m_data.rngSeed; }
        1: 3635:        virtual UseColour::YesOrNo useColour() const { return m_data.useColour; }
        -: 3636:
        -: 3637:    private:
        -: 3638:
        1: 3639:        IStream const* openStream() {
        1: 3640:            if( m_data.outputFilename.empty() )
        1: 3641:                return new CoutStream();
    #####: 3642:            else if( m_data.outputFilename[0] == '%' ) {
    #####: 3643:                if( m_data.outputFilename == "%debug" )
    #####: 3644:                    return new DebugOutStream();
        -: 3645:                else
    #####: 3646:                    throw std::domain_error( "Unrecognised stream: " + m_data.outputFilename );
        -: 3647:            }
        -: 3648:            else
    #####: 3649:                return new FileStream( m_data.outputFilename );
        -: 3650:        }
        -: 3651:        ConfigData m_data;
        -: 3652:
        -: 3653:        CATCH_AUTO_PTR( IStream const ) m_stream;
        -: 3654:        TestSpec m_testSpec;
        -: 3655:    };
        -: 3656:
        -: 3657:} // end namespace Catch
        -: 3658:
        -: 3659:// #included from: catch_clara.h
        -: 3660:#define TWOBLUECUBES_CATCH_CLARA_H_INCLUDED
        -: 3661:
        -: 3662:// Use Catch's value for console width (store Clara's off to the side, if present)
        -: 3663:#ifdef CLARA_CONFIG_CONSOLE_WIDTH
        -: 3664:#define CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH CLARA_CONFIG_CONSOLE_WIDTH
        -: 3665:#undef CLARA_CONFIG_CONSOLE_WIDTH
        -: 3666:#endif
        -: 3667:#define CLARA_CONFIG_CONSOLE_WIDTH CATCH_CONFIG_CONSOLE_WIDTH
        -: 3668:
        -: 3669:// Declare Clara inside the Catch namespace
        -: 3670:#define STITCH_CLARA_OPEN_NAMESPACE namespace Catch {
        -: 3671:// #included from: ../external/clara.h
        -: 3672:
        -: 3673:// Version 0.0.2.4
        -: 3674:
        -: 3675:// Only use header guard if we are not using an outer namespace
        -: 3676:#if !defined(TWOBLUECUBES_CLARA_H_INCLUDED) || defined(STITCH_CLARA_OPEN_NAMESPACE)
        -: 3677:
        -: 3678:#ifndef STITCH_CLARA_OPEN_NAMESPACE
        -: 3679:#define TWOBLUECUBES_CLARA_H_INCLUDED
        -: 3680:#define STITCH_CLARA_OPEN_NAMESPACE
        -: 3681:#define STITCH_CLARA_CLOSE_NAMESPACE
        -: 3682:#else
        -: 3683:#define STITCH_CLARA_CLOSE_NAMESPACE }
        -: 3684:#endif
        -: 3685:
        -: 3686:#define STITCH_TBC_TEXT_FORMAT_OPEN_NAMESPACE STITCH_CLARA_OPEN_NAMESPACE
        -: 3687:
        -: 3688:// ----------- #included from tbc_text_format.h -----------
        -: 3689:
        -: 3690:// Only use header guard if we are not using an outer namespace
        -: 3691:#if !defined(TBC_TEXT_FORMAT_H_INCLUDED) || defined(STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE)
        -: 3692:#ifndef STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE
        -: 3693:#define TBC_TEXT_FORMAT_H_INCLUDED
        -: 3694:#endif
        -: 3695:
        -: 3696:#include <string>
        -: 3697:#include <vector>
        -: 3698:#include <sstream>
        -: 3699:#include <algorithm>
        -: 3700:
        -: 3701:// Use optional outer namespace
        -: 3702:#ifdef STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE
        -: 3703:namespace STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE {
        -: 3704:#endif
        -: 3705:
        -: 3706:namespace Tbc {
        -: 3707:
        -: 3708:#ifdef TBC_TEXT_FORMAT_CONSOLE_WIDTH
        -: 3709:    const unsigned int consoleWidth = TBC_TEXT_FORMAT_CONSOLE_WIDTH;
        -: 3710:#else
        -: 3711:    const unsigned int consoleWidth = 80;
        -: 3712:#endif
        -: 3713:
        -: 3714:    struct TextAttributes {
    #####: 3715:        TextAttributes()
        -: 3716:        :   initialIndent( std::string::npos ),
        -: 3717:            indent( 0 ),
        -: 3718:            width( consoleWidth-1 ),
    #####: 3719:            tabChar( '\t' )
    #####: 3720:        {}
        -: 3721:
        -: 3722:        TextAttributes& setInitialIndent( std::size_t _value )  { initialIndent = _value; return *this; }
    #####: 3723:        TextAttributes& setIndent( std::size_t _value )         { indent = _value; return *this; }
    #####: 3724:        TextAttributes& setWidth( std::size_t _value )          { width = _value; return *this; }
        -: 3725:        TextAttributes& setTabChar( char _value )               { tabChar = _value; return *this; }
        -: 3726:
        -: 3727:        std::size_t initialIndent;  // indent of first line, or npos
        -: 3728:        std::size_t indent;         // indent of subsequent lines, or all if initialIndent is npos
        -: 3729:        std::size_t width;          // maximum width of text, including indent. Longer text will wrap
        -: 3730:        char tabChar;               // If this char is seen the indent is changed to current pos
        -: 3731:    };
        -: 3732:
    #####: 3733:    class Text {
        -: 3734:    public:
    #####: 3735:        Text( std::string const& _str, TextAttributes const& _attr = TextAttributes() )
    #####: 3736:        : attr( _attr )
        -: 3737:        {
    #####: 3738:            std::string wrappableChars = " [({.,/|\\-";
    #####: 3739:            std::size_t indent = _attr.initialIndent != std::string::npos
        -: 3740:                ? _attr.initialIndent
    #####: 3741:                : _attr.indent;
    #####: 3742:            std::string remainder = _str;
        -: 3743:
    #####: 3744:            while( !remainder.empty() ) {
    #####: 3745:                if( lines.size() >= 1000 ) {
    #####: 3746:                    lines.push_back( "... message truncated due to excessive size" );
    #####: 3747:                    return;
        -: 3748:                }
    #####: 3749:                std::size_t tabPos = std::string::npos;
    #####: 3750:                std::size_t width = (std::min)( remainder.size(), _attr.width - indent );
    #####: 3751:                std::size_t pos = remainder.find_first_of( '\n' );
    #####: 3752:                if( pos <= width ) {
    #####: 3753:                    width = pos;
        -: 3754:                }
    #####: 3755:                pos = remainder.find_last_of( _attr.tabChar, width );
    #####: 3756:                if( pos != std::string::npos ) {
    #####: 3757:                    tabPos = pos;
    #####: 3758:                    if( remainder[width] == '\n' )
    #####: 3759:                        width--;
    #####: 3760:                    remainder = remainder.substr( 0, tabPos ) + remainder.substr( tabPos+1 );
        -: 3761:                }
        -: 3762:
    #####: 3763:                if( width == remainder.size() ) {
    #####: 3764:                    spliceLine( indent, remainder, width );
        -: 3765:                }
    #####: 3766:                else if( remainder[width] == '\n' ) {
    #####: 3767:                    spliceLine( indent, remainder, width );
    #####: 3768:                    if( width <= 1 || remainder.size() != 1 )
    #####: 3769:                        remainder = remainder.substr( 1 );
    #####: 3770:                    indent = _attr.indent;
        -: 3771:                }
        -: 3772:                else {
    #####: 3773:                    pos = remainder.find_last_of( wrappableChars, width );
    #####: 3774:                    if( pos != std::string::npos && pos > 0 ) {
    #####: 3775:                        spliceLine( indent, remainder, pos );
    #####: 3776:                        if( remainder[0] == ' ' )
    #####: 3777:                            remainder = remainder.substr( 1 );
        -: 3778:                    }
        -: 3779:                    else {
    #####: 3780:                        spliceLine( indent, remainder, width-1 );
    #####: 3781:                        lines.back() += "-";
        -: 3782:                    }
    #####: 3783:                    if( lines.size() == 1 )
    #####: 3784:                        indent = _attr.indent;
    #####: 3785:                    if( tabPos != std::string::npos )
    #####: 3786:                        indent += tabPos;
        -: 3787:                }
        -: 3788:            }
        -: 3789:        }
        -: 3790:
    #####: 3791:        void spliceLine( std::size_t _indent, std::string& _remainder, std::size_t _pos ) {
    #####: 3792:            lines.push_back( std::string( _indent, ' ' ) + _remainder.substr( 0, _pos ) );
    #####: 3793:            _remainder = _remainder.substr( _pos );
    #####: 3794:        }
        -: 3795:
        -: 3796:        typedef std::vector<std::string>::const_iterator const_iterator;
        -: 3797:
        -: 3798:        const_iterator begin() const { return lines.begin(); }
        -: 3799:        const_iterator end() const { return lines.end(); }
        -: 3800:        std::string const& last() const { return lines.back(); }
    #####: 3801:        std::size_t size() const { return lines.size(); }
    #####: 3802:        std::string const& operator[]( std::size_t _index ) const { return lines[_index]; }
        -: 3803:        std::string toString() const {
        -: 3804:            std::ostringstream oss;
        -: 3805:            oss << *this;
        -: 3806:            return oss.str();
        -: 3807:        }
        -: 3808:
        -: 3809:        inline friend std::ostream& operator << ( std::ostream& _stream, Text const& _text ) {
        -: 3810:            for( Text::const_iterator it = _text.begin(), itEnd = _text.end();
        -: 3811:                it != itEnd; ++it ) {
        -: 3812:                if( it != _text.begin() )
        -: 3813:                    _stream << "\n";
        -: 3814:                _stream << *it;
        -: 3815:            }
        -: 3816:            return _stream;
        -: 3817:        }
        -: 3818:
        -: 3819:    private:
        -: 3820:        std::string str;
        -: 3821:        TextAttributes attr;
        -: 3822:        std::vector<std::string> lines;
        -: 3823:    };
        -: 3824:
        -: 3825:} // end namespace Tbc
        -: 3826:
        -: 3827:#ifdef STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE
        -: 3828:} // end outer namespace
        -: 3829:#endif
        -: 3830:
        -: 3831:#endif // TBC_TEXT_FORMAT_H_INCLUDED
        -: 3832:
        -: 3833:// ----------- end of #include from tbc_text_format.h -----------
        -: 3834:// ........... back in clara.h
        -: 3835:
        -: 3836:#undef STITCH_TBC_TEXT_FORMAT_OPEN_NAMESPACE
        -: 3837:
        -: 3838:// ----------- #included from clara_compilers.h -----------
        -: 3839:
        -: 3840:#ifndef TWOBLUECUBES_CLARA_COMPILERS_H_INCLUDED
        -: 3841:#define TWOBLUECUBES_CLARA_COMPILERS_H_INCLUDED
        -: 3842:
        -: 3843:// Detect a number of compiler features - mostly C++11/14 conformance - by compiler
        -: 3844:// The following features are defined:
        -: 3845://
        -: 3846:// CLARA_CONFIG_CPP11_NULLPTR : is nullptr supported?
        -: 3847:// CLARA_CONFIG_CPP11_NOEXCEPT : is noexcept supported?
        -: 3848:// CLARA_CONFIG_CPP11_GENERATED_METHODS : The delete and default keywords for compiler generated methods
        -: 3849:// CLARA_CONFIG_CPP11_OVERRIDE : is override supported?
        -: 3850:// CLARA_CONFIG_CPP11_UNIQUE_PTR : is unique_ptr supported (otherwise use auto_ptr)
        -: 3851:
        -: 3852:// CLARA_CONFIG_CPP11_OR_GREATER : Is C++11 supported?
        -: 3853:
        -: 3854:// CLARA_CONFIG_VARIADIC_MACROS : are variadic macros supported?
        -: 3855:
        -: 3856:// In general each macro has a _NO_<feature name> form
        -: 3857:// (e.g. CLARA_CONFIG_CPP11_NO_NULLPTR) which disables the feature.
        -: 3858:// Many features, at point of detection, define an _INTERNAL_ macro, so they
        -: 3859:// can be combined, en-mass, with the _NO_ forms later.
        -: 3860:
        -: 3861:// All the C++11 features can be disabled with CLARA_CONFIG_NO_CPP11
        -: 3862:
        -: 3863:#ifdef __clang__
        -: 3864:
        -: 3865:#if __has_feature(cxx_nullptr)
        -: 3866:#define CLARA_INTERNAL_CONFIG_CPP11_NULLPTR
        -: 3867:#endif
        -: 3868:
        -: 3869:#if __has_feature(cxx_noexcept)
        -: 3870:#define CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT
        -: 3871:#endif
        -: 3872:
        -: 3873:#endif // __clang__
        -: 3874:
        -: 3875:////////////////////////////////////////////////////////////////////////////////
        -: 3876:// GCC
        -: 3877:#ifdef __GNUC__
        -: 3878:
        -: 3879:#if __GNUC__ == 4 && __GNUC_MINOR__ >= 6 && defined(__GXX_EXPERIMENTAL_CXX0X__)
        -: 3880:#define CLARA_INTERNAL_CONFIG_CPP11_NULLPTR
        -: 3881:#endif
        -: 3882:
        -: 3883:// - otherwise more recent versions define __cplusplus >= 201103L
        -: 3884:// and will get picked up below
        -: 3885:
        -: 3886:#endif // __GNUC__
        -: 3887:
        -: 3888:////////////////////////////////////////////////////////////////////////////////
        -: 3889:// Visual C++
        -: 3890:#ifdef _MSC_VER
        -: 3891:
        -: 3892:#if (_MSC_VER >= 1600)
        -: 3893:#define CLARA_INTERNAL_CONFIG_CPP11_NULLPTR
        -: 3894:#define CLARA_INTERNAL_CONFIG_CPP11_UNIQUE_PTR
        -: 3895:#endif
        -: 3896:
        -: 3897:#if (_MSC_VER >= 1900 ) // (VC++ 13 (VS2015))
        -: 3898:#define CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT
        -: 3899:#define CLARA_INTERNAL_CONFIG_CPP11_GENERATED_METHODS
        -: 3900:#endif
        -: 3901:
        -: 3902:#endif // _MSC_VER
        -: 3903:
        -: 3904:////////////////////////////////////////////////////////////////////////////////
        -: 3905:// C++ language feature support
        -: 3906:
        -: 3907:// catch all support for C++11
        -: 3908:#if defined(__cplusplus) && __cplusplus >= 201103L
        -: 3909:
        -: 3910:#define CLARA_CPP11_OR_GREATER
        -: 3911:
        -: 3912:#if !defined(CLARA_INTERNAL_CONFIG_CPP11_NULLPTR)
        -: 3913:#define CLARA_INTERNAL_CONFIG_CPP11_NULLPTR
        -: 3914:#endif
        -: 3915:
        -: 3916:#ifndef CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT
        -: 3917:#define CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT
        -: 3918:#endif
        -: 3919:
        -: 3920:#ifndef CLARA_INTERNAL_CONFIG_CPP11_GENERATED_METHODS
        -: 3921:#define CLARA_INTERNAL_CONFIG_CPP11_GENERATED_METHODS
        -: 3922:#endif
        -: 3923:
        -: 3924:#if !defined(CLARA_INTERNAL_CONFIG_CPP11_OVERRIDE)
        -: 3925:#define CLARA_INTERNAL_CONFIG_CPP11_OVERRIDE
        -: 3926:#endif
        -: 3927:#if !defined(CLARA_INTERNAL_CONFIG_CPP11_UNIQUE_PTR)
        -: 3928:#define CLARA_INTERNAL_CONFIG_CPP11_UNIQUE_PTR
        -: 3929:#endif
        -: 3930:
        -: 3931:#endif // __cplusplus >= 201103L
        -: 3932:
        -: 3933:// Now set the actual defines based on the above + anything the user has configured
        -: 3934:#if defined(CLARA_INTERNAL_CONFIG_CPP11_NULLPTR) && !defined(CLARA_CONFIG_CPP11_NO_NULLPTR) && !defined(CLARA_CONFIG_CPP11_NULLPTR) && !defined(CLARA_CONFIG_NO_CPP11)
        -: 3935:#define CLARA_CONFIG_CPP11_NULLPTR
        -: 3936:#endif
        -: 3937:#if defined(CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT) && !defined(CLARA_CONFIG_CPP11_NO_NOEXCEPT) && !defined(CLARA_CONFIG_CPP11_NOEXCEPT) && !defined(CLARA_CONFIG_NO_CPP11)
        -: 3938:#define CLARA_CONFIG_CPP11_NOEXCEPT
        -: 3939:#endif
        -: 3940:#if defined(CLARA_INTERNAL_CONFIG_CPP11_GENERATED_METHODS) && !defined(CLARA_CONFIG_CPP11_NO_GENERATED_METHODS) && !defined(CLARA_CONFIG_CPP11_GENERATED_METHODS) && !defined(CLARA_CONFIG_NO_CPP11)
        -: 3941:#define CLARA_CONFIG_CPP11_GENERATED_METHODS
        -: 3942:#endif
        -: 3943:#if defined(CLARA_INTERNAL_CONFIG_CPP11_OVERRIDE) && !defined(CLARA_CONFIG_NO_OVERRIDE) && !defined(CLARA_CONFIG_CPP11_OVERRIDE) && !defined(CLARA_CONFIG_NO_CPP11)
        -: 3944:#define CLARA_CONFIG_CPP11_OVERRIDE
        -: 3945:#endif
        -: 3946:#if defined(CLARA_INTERNAL_CONFIG_CPP11_UNIQUE_PTR) && !defined(CLARA_CONFIG_NO_UNIQUE_PTR) && !defined(CLARA_CONFIG_CPP11_UNIQUE_PTR) && !defined(CLARA_CONFIG_NO_CPP11)
        -: 3947:#define CLARA_CONFIG_CPP11_UNIQUE_PTR
        -: 3948:#endif
        -: 3949:
        -: 3950:// noexcept support:
        -: 3951:#if defined(CLARA_CONFIG_CPP11_NOEXCEPT) && !defined(CLARA_NOEXCEPT)
        -: 3952:#define CLARA_NOEXCEPT noexcept
        -: 3953:#  define CLARA_NOEXCEPT_IS(x) noexcept(x)
        -: 3954:#else
        -: 3955:#define CLARA_NOEXCEPT throw()
        -: 3956:#  define CLARA_NOEXCEPT_IS(x)
        -: 3957:#endif
        -: 3958:
        -: 3959:// nullptr support
        -: 3960:#ifdef CLARA_CONFIG_CPP11_NULLPTR
        -: 3961:#define CLARA_NULL nullptr
        -: 3962:#else
        -: 3963:#define CLARA_NULL NULL
        -: 3964:#endif
        -: 3965:
        -: 3966:// override support
        -: 3967:#ifdef CLARA_CONFIG_CPP11_OVERRIDE
        -: 3968:#define CLARA_OVERRIDE override
        -: 3969:#else
        -: 3970:#define CLARA_OVERRIDE
        -: 3971:#endif
        -: 3972:
        -: 3973:// unique_ptr support
        -: 3974:#ifdef CLARA_CONFIG_CPP11_UNIQUE_PTR
        -: 3975:#   define CLARA_AUTO_PTR( T ) std::unique_ptr<T>
        -: 3976:#else
        -: 3977:#   define CLARA_AUTO_PTR( T ) std::auto_ptr<T>
        -: 3978:#endif
        -: 3979:
        -: 3980:#endif // TWOBLUECUBES_CLARA_COMPILERS_H_INCLUDED
        -: 3981:
        -: 3982:// ----------- end of #include from clara_compilers.h -----------
        -: 3983:// ........... back in clara.h
        -: 3984:
        -: 3985:#include <map>
        -: 3986:#include <stdexcept>
        -: 3987:#include <memory>
        -: 3988:
        -: 3989:#if defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER)
        -: 3990:#define CLARA_PLATFORM_WINDOWS
        -: 3991:#endif
        -: 3992:
        -: 3993:// Use optional outer namespace
        -: 3994:#ifdef STITCH_CLARA_OPEN_NAMESPACE
        -: 3995:STITCH_CLARA_OPEN_NAMESPACE
        -: 3996:#endif
        -: 3997:
        -: 3998:namespace Clara {
        -: 3999:
        -: 4000:    struct UnpositionalTag {};
        -: 4001:
        -: 4002:    extern UnpositionalTag _;
        -: 4003:
        -: 4004:#ifdef CLARA_CONFIG_MAIN
        -: 4005:    UnpositionalTag _;
        -: 4006:#endif
        -: 4007:
        -: 4008:    namespace Detail {
        -: 4009:
        -: 4010:#ifdef CLARA_CONSOLE_WIDTH
        -: 4011:    const unsigned int consoleWidth = CLARA_CONFIG_CONSOLE_WIDTH;
        -: 4012:#else
        -: 4013:    const unsigned int consoleWidth = 80;
        -: 4014:#endif
        -: 4015:
        -: 4016:        using namespace Tbc;
        -: 4017:
       56: 4018:        inline bool startsWith( std::string const& str, std::string const& prefix ) {
       56: 4019:            return str.size() >= prefix.size() && str.substr( 0, prefix.size() ) == prefix;
        -: 4020:        }
        -: 4021:
        -: 4022:        template<typename T> struct RemoveConstRef{ typedef T type; };
        -: 4023:        template<typename T> struct RemoveConstRef<T&>{ typedef T type; };
        -: 4024:        template<typename T> struct RemoveConstRef<T const&>{ typedef T type; };
        -: 4025:        template<typename T> struct RemoveConstRef<T const>{ typedef T type; };
        -: 4026:
        -: 4027:        template<typename T>    struct IsBool       { static const bool value = false; };
        -: 4028:        template<>              struct IsBool<bool> { static const bool value = true; };
        -: 4029:
        -: 4030:        template<typename T>
    #####: 4031:        void convertInto( std::string const& _source, T& _dest ) {
    #####: 4032:            std::stringstream ss;
    #####: 4033:            ss << _source;
    #####: 4034:            ss >> _dest;
    #####: 4035:            if( ss.fail() )
    #####: 4036:                throw std::runtime_error( "Unable to convert " + _source + " to destination type" );
    #####: 4037:        }
        1: 4038:        inline void convertInto( std::string const& _source, std::string& _dest ) {
        1: 4039:            _dest = _source;
        1: 4040:        }
    #####: 4041:        char toLowerCh(char c) {
    #####: 4042:            return static_cast<char>( ::tolower( c ) );
        -: 4043:        }
    #####: 4044:        inline void convertInto( std::string const& _source, bool& _dest ) {
    #####: 4045:            std::string sourceLC = _source;
    #####: 4046:            std::transform( sourceLC.begin(), sourceLC.end(), sourceLC.begin(), toLowerCh );
    #####: 4047:            if( sourceLC == "y" || sourceLC == "1" || sourceLC == "true" || sourceLC == "yes" || sourceLC == "on" )
    #####: 4048:                _dest = true;
    #####: 4049:            else if( sourceLC == "n" || sourceLC == "0" || sourceLC == "false" || sourceLC == "no" || sourceLC == "off" )
    #####: 4050:                _dest = false;
        -: 4051:            else
    #####: 4052:                throw std::runtime_error( "Expected a boolean value but did not recognise:\n  '" + _source + "'" );
    #####: 4053:        }
        -: 4054:
        -: 4055:        template<typename ConfigT>
        -: 4056:        struct IArgFunction {
       80: 4057:            virtual ~IArgFunction() {}
        -: 4058:#ifdef CLARA_CONFIG_CPP11_GENERATED_METHODS
       25: 4059:            IArgFunction()                      = default;
       55: 4060:            IArgFunction( IArgFunction const& ) = default;
        -: 4061:#endif
        -: 4062:            virtual void set( ConfigT& config, std::string const& value ) const = 0;
        -: 4063:            virtual bool takesArg() const = 0;
        -: 4064:            virtual IArgFunction* clone() const = 0;
        -: 4065:        };
        -: 4066:
        -: 4067:        template<typename ConfigT>
        -: 4068:        class BoundArgFunction {
        -: 4069:        public:
       23: 4070:            BoundArgFunction() : functionObj( CLARA_NULL ) {}
       25: 4071:            BoundArgFunction( IArgFunction<ConfigT>* _functionObj ) : functionObj( _functionObj ) {}
       53: 4072:            BoundArgFunction( BoundArgFunction const& other ) : functionObj( other.functionObj ? other.functionObj->clone() : CLARA_NULL ) {}
       24: 4073:            BoundArgFunction& operator = ( BoundArgFunction const& other ) {
       24: 4074:                IArgFunction<ConfigT>* newFunctionObj = other.functionObj ? other.functionObj->clone() : CLARA_NULL;
       24: 4075:                delete functionObj;
       24: 4076:                functionObj = newFunctionObj;
       24: 4077:                return *this;
        -: 4078:            }
      101: 4079:            ~BoundArgFunction() { delete functionObj; }
        -: 4080:
        1: 4081:            void set( ConfigT& config, std::string const& value ) const {
        1: 4082:                functionObj->set( config, value );
        1: 4083:            }
        -: 4084:            bool takesArg() const { return functionObj->takesArg(); }
        -: 4085:
       22: 4086:            bool isSet() const {
       22: 4087:                return functionObj != CLARA_NULL;
        -: 4088:            }
        -: 4089:        private:
        -: 4090:            IArgFunction<ConfigT>* functionObj;
        -: 4091:        };
        -: 4092:
        -: 4093:        template<typename C>
        3: 4094:        struct NullBinder : IArgFunction<C>{
    #####: 4095:            virtual void set( C&, std::string const& ) const {}
    #####: 4096:            virtual bool takesArg() const { return true; }
    #####: 4097:            virtual IArgFunction<C>* clone() const { return new NullBinder( *this ); }
        -: 4098:        };
        -: 4099:
        -: 4100:        template<typename C, typename M>
      140: 4101:        struct BoundDataMember : IArgFunction<C>{
       13: 4102:            BoundDataMember( M C::* _member ) : member( _member ) {}
        1: 4103:            virtual void set( C& p, std::string const& stringValue ) const {
        1: 4104:                convertInto( stringValue, p.*member );
        1: 4105:            }
    #####: 4106:            virtual bool takesArg() const { return !IsBool<M>::value; }
       38: 4107:            virtual IArgFunction<C>* clone() const { return new BoundDataMember( *this ); }
        -: 4108:            M C::* member;
        -: 4109:        };
        -: 4110:        template<typename C, typename M>
        -: 4111:        struct BoundUnaryMethod : IArgFunction<C>{
        -: 4112:            BoundUnaryMethod( void (C::*_member)( M ) ) : member( _member ) {}
        -: 4113:            virtual void set( C& p, std::string const& stringValue ) const {
        -: 4114:                typename RemoveConstRef<M>::type value;
        -: 4115:                convertInto( stringValue, value );
        -: 4116:                (p.*member)( value );
        -: 4117:            }
        -: 4118:            virtual bool takesArg() const { return !IsBool<M>::value; }
        -: 4119:            virtual IArgFunction<C>* clone() const { return new BoundUnaryMethod( *this ); }
        -: 4120:            void (C::*member)( M );
        -: 4121:        };
        -: 4122:        template<typename C>
        -: 4123:        struct BoundNullaryMethod : IArgFunction<C>{
        -: 4124:            BoundNullaryMethod( void (C::*_member)() ) : member( _member ) {}
        -: 4125:            virtual void set( C& p, std::string const& stringValue ) const {
        -: 4126:                bool value;
        -: 4127:                convertInto( stringValue, value );
        -: 4128:                if( value )
        -: 4129:                    (p.*member)();
        -: 4130:            }
        -: 4131:            virtual bool takesArg() const { return false; }
        -: 4132:            virtual IArgFunction<C>* clone() const { return new BoundNullaryMethod( *this ); }
        -: 4133:            void (C::*member)();
        -: 4134:        };
        -: 4135:
        -: 4136:        template<typename C>
       13: 4137:        struct BoundUnaryFunction : IArgFunction<C>{
        2: 4138:            BoundUnaryFunction( void (*_function)( C& ) ) : function( _function ) {}
    #####: 4139:            virtual void set( C& obj, std::string const& stringValue ) const {
        -: 4140:                bool value;
    #####: 4141:                convertInto( stringValue, value );
    #####: 4142:                if( value )
    #####: 4143:                    function( obj );
    #####: 4144:            }
    #####: 4145:            virtual bool takesArg() const { return false; }
        3: 4146:            virtual IArgFunction<C>* clone() const { return new BoundUnaryFunction( *this ); }
        -: 4147:            void (*function)( C& );
        -: 4148:        };
        -: 4149:
        -: 4150:        template<typename C, typename T>
       60: 4151:        struct BoundBinaryFunction : IArgFunction<C>{
        9: 4152:            BoundBinaryFunction( void (*_function)( C&, T ) ) : function( _function ) {}
    #####: 4153:            virtual void set( C& obj, std::string const& stringValue ) const {
    #####: 4154:                typename RemoveConstRef<T>::type value;
    #####: 4155:                convertInto( stringValue, value );
    #####: 4156:                function( obj, value );
    #####: 4157:            }
    #####: 4158:            virtual bool takesArg() const { return !IsBool<T>::value; }
       14: 4159:            virtual IArgFunction<C>* clone() const { return new BoundBinaryFunction( *this ); }
        -: 4160:            void (*function)( C&, T );
        -: 4161:        };
        -: 4162:
        -: 4163:    } // namespace Detail
        -: 4164:
        1: 4165:    inline std::vector<std::string> argsToVector( int argc, char const* const* const argv ) {
        1: 4166:        std::vector<std::string> args( static_cast<std::size_t>( argc ) );
        2: 4167:        for( std::size_t i = 0; i < static_cast<std::size_t>( argc ); ++i )
        1: 4168:            args[i] = argv[i];
        -: 4169:
        1: 4170:        return args;
        -: 4171:    }
        -: 4172:
        -: 4173:    class Parser {
        -: 4174:        enum Mode { None, MaybeShortOpt, SlashOpt, ShortOpt, LongOpt, Positional };
        -: 4175:        Mode mode;
        -: 4176:        std::size_t from;
        -: 4177:        bool inQuotes;
        -: 4178:    public:
        -: 4179:
    #####: 4180:        struct Token {
        -: 4181:            enum Type { Positional, ShortOpt, LongOpt };
    #####: 4182:            Token( Type _type, std::string const& _data ) : type( _type ), data( _data ) {}
        -: 4183:            Type type;
        -: 4184:            std::string data;
        -: 4185:        };
        -: 4186:
        1: 4187:        Parser() : mode( None ), from( 0 ), inQuotes( false ){}
        -: 4188:
        1: 4189:        void parseIntoTokens( std::vector<std::string> const& args, std::vector<Token>& tokens ) {
        2: 4190:            const std::string doubleDash = "--";
        1: 4191:            for( std::size_t i = 1; i < args.size() && args[i] != doubleDash; ++i )
    #####: 4192:                parseIntoTokens( args[i], tokens);
        1: 4193:        }
        -: 4194:
    #####: 4195:        void parseIntoTokens( std::string const& arg, std::vector<Token>& tokens ) {
    #####: 4196:            for( std::size_t i = 0; i <= arg.size(); ++i ) {
    #####: 4197:                char c = arg[i];
    #####: 4198:                if( c == '"' )
    #####: 4199:                    inQuotes = !inQuotes;
    #####: 4200:                mode = handleMode( i, c, arg, tokens );
        -: 4201:            }
    #####: 4202:        }
    #####: 4203:        Mode handleMode( std::size_t i, char c, std::string const& arg, std::vector<Token>& tokens ) {
    #####: 4204:            switch( mode ) {
    #####: 4205:                case None: return handleNone( i, c );
    #####: 4206:                case MaybeShortOpt: return handleMaybeShortOpt( i, c );
        -: 4207:                case ShortOpt:
        -: 4208:                case LongOpt:
    #####: 4209:                case SlashOpt: return handleOpt( i, c, arg, tokens );
    #####: 4210:                case Positional: return handlePositional( i, c, arg, tokens );
    #####: 4211:                default: throw std::logic_error( "Unknown mode" );
        -: 4212:            }
        -: 4213:        }
        -: 4214:
    #####: 4215:        Mode handleNone( std::size_t i, char c ) {
    #####: 4216:            if( inQuotes ) {
    #####: 4217:                from = i;
    #####: 4218:                return Positional;
        -: 4219:            }
    #####: 4220:            switch( c ) {
    #####: 4221:                case '-': return MaybeShortOpt;
        -: 4222:#ifdef CLARA_PLATFORM_WINDOWS
        -: 4223:                case '/': from = i+1; return SlashOpt;
        -: 4224:#endif
    #####: 4225:                default: from = i; return Positional;
        -: 4226:            }
        -: 4227:        }
    #####: 4228:        Mode handleMaybeShortOpt( std::size_t i, char c ) {
    #####: 4229:            switch( c ) {
    #####: 4230:                case '-': from = i+1; return LongOpt;
    #####: 4231:                default: from = i; return ShortOpt;
        -: 4232:            }
        -: 4233:        }
    #####: 4234:        Mode handleOpt( std::size_t i, char c, std::string const& arg, std::vector<Token>& tokens ) {
    #####: 4235:            if( std::string( ":=\0", 3 ).find( c ) == std::string::npos )
    #####: 4236:                return mode;
        -: 4237:
    #####: 4238:            std::string optName = arg.substr( from, i-from );
    #####: 4239:            if( mode == ShortOpt )
    #####: 4240:                for( std::size_t j = 0; j < optName.size(); ++j )
    #####: 4241:                    tokens.push_back( Token( Token::ShortOpt, optName.substr( j, 1 ) ) );
    #####: 4242:            else if( mode == SlashOpt && optName.size() == 1 )
    #####: 4243:                tokens.push_back( Token( Token::ShortOpt, optName ) );
        -: 4244:            else
    #####: 4245:                tokens.push_back( Token( Token::LongOpt, optName ) );
    #####: 4246:            return None;
        -: 4247:        }
    #####: 4248:        Mode handlePositional( std::size_t i, char c, std::string const& arg, std::vector<Token>& tokens ) {
    #####: 4249:            if( inQuotes || std::string( "\0", 1 ).find( c ) == std::string::npos )
    #####: 4250:                return mode;
        -: 4251:
    #####: 4252:            std::string data = arg.substr( from, i-from );
    #####: 4253:            tokens.push_back( Token( Token::Positional, data ) );
    #####: 4254:            return None;
        -: 4255:        }
        -: 4256:    };
        -: 4257:
        -: 4258:    template<typename ConfigT>
      129: 4259:    struct CommonArgProperties {
       23: 4260:        CommonArgProperties() {}
        -: 4261:        CommonArgProperties( Detail::BoundArgFunction<ConfigT> const& _boundField ) : boundField( _boundField ) {}
        -: 4262:
        -: 4263:        Detail::BoundArgFunction<ConfigT> boundField;
        -: 4264:        std::string description;
        -: 4265:        std::string detail;
        -: 4266:        std::string placeholder; // Only value if boundField takes an arg
        -: 4267:
    #####: 4268:        bool takesArg() const {
    #####: 4269:            return !placeholder.empty();
        -: 4270:        }
       22: 4271:        void validate() const {
       22: 4272:            if( !boundField.isSet() )
    #####: 4273:                throw std::logic_error( "option not bound" );
       22: 4274:        }
        -: 4275:    };
      152: 4276:    struct OptionArgProperties {
        -: 4277:        std::vector<std::string> shortNames;
        -: 4278:        std::string longName;
        -: 4279:
    #####: 4280:        bool hasShortName( std::string const& shortName ) const {
    #####: 4281:            return std::find( shortNames.begin(), shortNames.end(), shortName ) != shortNames.end();
        -: 4282:        }
    #####: 4283:        bool hasLongName( std::string const& _longName ) const {
    #####: 4284:            return _longName == longName;
        -: 4285:        }
        -: 4286:    };
        -: 4287:    struct PositionalArgProperties {
       23: 4288:        PositionalArgProperties() : position( -1 ) {}
        -: 4289:        int position; // -1 means non-positional (floating)
        -: 4290:
        -: 4291:        bool isFixedPositional() const {
        -: 4292:            return position != -1;
        -: 4293:        }
        -: 4294:    };
        -: 4295:
        -: 4296:    template<typename ConfigT>
        1: 4297:    class CommandLine {
        -: 4298:
      129: 4299:        struct Arg : CommonArgProperties<ConfigT>, OptionArgProperties, PositionalArgProperties {
       23: 4300:            Arg() {}
        -: 4301:            Arg( Detail::BoundArgFunction<ConfigT> const& _boundField ) : CommonArgProperties<ConfigT>( _boundField ) {}
        -: 4302:
        -: 4303:            using CommonArgProperties<ConfigT>::placeholder; // !TBD
        -: 4304:
        -: 4305:            std::string dbgName() const {
        -: 4306:                if( !longName.empty() )
        -: 4307:                    return "--" + longName;
        -: 4308:                if( !shortNames.empty() )
        -: 4309:                    return "-" + shortNames[0];
        -: 4310:                return "positional args";
        -: 4311:            }
    #####: 4312:            std::string commands() const {
    #####: 4313:                std::ostringstream oss;
    #####: 4314:                bool first = true;
    #####: 4315:                std::vector<std::string>::const_iterator it = shortNames.begin(), itEnd = shortNames.end();
    #####: 4316:                for(; it != itEnd; ++it ) {
    #####: 4317:                    if( first )
    #####: 4318:                        first = false;
        -: 4319:                    else
    #####: 4320:                        oss << ", ";
    #####: 4321:                    oss << "-" << *it;
        -: 4322:                }
    #####: 4323:                if( !longName.empty() ) {
    #####: 4324:                    if( !first )
    #####: 4325:                        oss << ", ";
    #####: 4326:                    oss << "--" << longName;
        -: 4327:                }
    #####: 4328:                if( !placeholder.empty() )
    #####: 4329:                    oss << " <" << placeholder << ">";
    #####: 4330:                return oss.str();
        -: 4331:            }
        -: 4332:        };
        -: 4333:
        -: 4334:        typedef CLARA_AUTO_PTR( Arg ) ArgAutoPtr;
        -: 4335:
       39: 4336:        friend void addOptName( Arg& arg, std::string const& optName )
        -: 4337:        {
       39: 4338:            if( optName.empty() )
    #####: 4339:                return;
       39: 4340:            if( Detail::startsWith( optName, "--" ) ) {
       22: 4341:                if( !arg.longName.empty() )
    #####: 4342:                    throw std::logic_error( "Only one long opt may be specified. '"
        -: 4343:                        + arg.longName
        -: 4344:                        + "' already specified, now attempting to add '"
    #####: 4345:                        + optName + "'" );
       22: 4346:                arg.longName = optName.substr( 2 );
        -: 4347:            }
       17: 4348:            else if( Detail::startsWith( optName, "-" ) )
       17: 4349:                arg.shortNames.push_back( optName.substr( 1 ) );
        -: 4350:            else
    #####: 4351:                throw std::logic_error( "option must begin with - or --. Option was: '" + optName + "'" );
        -: 4352:        }
        -: 4353:        friend void setPositionalArg( Arg& arg, int position )
        -: 4354:        {
        -: 4355:            arg.position = position;
        -: 4356:        }
        -: 4357:
        -: 4358:        class ArgBuilder {
        -: 4359:        public:
       23: 4360:            ArgBuilder( Arg* arg ) : m_arg( arg ) {}
        -: 4361:
        -: 4362:            // Bind a non-boolean data member (requires placeholder string)
        -: 4363:            template<typename C, typename M>
        2: 4364:            void bind( M C::* field, std::string const& placeholder ) {
        2: 4365:                m_arg->boundField = new Detail::BoundDataMember<C,M>( field );
        2: 4366:                m_arg->placeholder = placeholder;
        2: 4367:            }
        -: 4368:            // Bind a boolean data member (no placeholder required)
        -: 4369:            template<typename C>
       10: 4370:            void bind( bool C::* field ) {
       10: 4371:                m_arg->boundField = new Detail::BoundDataMember<C,bool>( field );
       10: 4372:            }
        -: 4373:
        -: 4374:            // Bind a method taking a single, non-boolean argument (requires a placeholder string)
        -: 4375:            template<typename C, typename M>
        -: 4376:            void bind( void (C::* unaryMethod)( M ), std::string const& placeholder ) {
        -: 4377:                m_arg->boundField = new Detail::BoundUnaryMethod<C,M>( unaryMethod );
        -: 4378:                m_arg->placeholder = placeholder;
        -: 4379:            }
        -: 4380:
        -: 4381:            // Bind a method taking a single, boolean argument (no placeholder string required)
        -: 4382:            template<typename C>
        -: 4383:            void bind( void (C::* unaryMethod)( bool ) ) {
        -: 4384:                m_arg->boundField = new Detail::BoundUnaryMethod<C,bool>( unaryMethod );
        -: 4385:            }
        -: 4386:
        -: 4387:            // Bind a method that takes no arguments (will be called if opt is present)
        -: 4388:            template<typename C>
        -: 4389:            void bind( void (C::* nullaryMethod)() ) {
        -: 4390:                m_arg->boundField = new Detail::BoundNullaryMethod<C>( nullaryMethod );
        -: 4391:            }
        -: 4392:
        -: 4393:            // Bind a free function taking a single argument - the object to operate on (no placeholder string required)
        -: 4394:            template<typename C>
        2: 4395:            void bind( void (* unaryFunction)( C& ) ) {
        2: 4396:                m_arg->boundField = new Detail::BoundUnaryFunction<C>( unaryFunction );
        2: 4397:            }
        -: 4398:
        -: 4399:            // Bind a free function taking a single argument - the object to operate on (requires a placeholder string)
        -: 4400:            template<typename C, typename T>
        9: 4401:            void bind( void (* binaryFunction)( C&, T ), std::string const& placeholder ) {
        9: 4402:                m_arg->boundField = new Detail::BoundBinaryFunction<C, T>( binaryFunction );
        9: 4403:                m_arg->placeholder = placeholder;
        9: 4404:            }
        -: 4405:
       23: 4406:            ArgBuilder& describe( std::string const& description ) {
       23: 4407:                m_arg->description = description;
       23: 4408:                return *this;
        -: 4409:            }
        -: 4410:            ArgBuilder& detail( std::string const& detail ) {
        -: 4411:                m_arg->detail = detail;
        -: 4412:                return *this;
        -: 4413:            }
        -: 4414:
        -: 4415:        protected:
        -: 4416:            Arg* m_arg;
        -: 4417:        };
        -: 4418:
        -: 4419:        class OptBuilder : public ArgBuilder {
        -: 4420:        public:
       22: 4421:            OptBuilder( Arg* arg ) : ArgBuilder( arg ) {}
        -: 4422:            OptBuilder( OptBuilder& other ) : ArgBuilder( other ) {}
        -: 4423:
       17: 4424:            OptBuilder& operator[]( std::string const& optName ) {
       17: 4425:                addOptName( *ArgBuilder::m_arg, optName );
       17: 4426:                return *this;
        -: 4427:            }
        -: 4428:        };
        -: 4429:
        -: 4430:    public:
        -: 4431:
        1: 4432:        CommandLine()
        -: 4433:        :   m_boundProcessName( new Detail::NullBinder<ConfigT>() ),
        -: 4434:            m_highestSpecifiedArgPosition( 0 ),
        1: 4435:            m_throwOnUnrecognisedTokens( false )
        1: 4436:        {}
        -: 4437:        CommandLine( CommandLine const& other )
        -: 4438:        :   m_boundProcessName( other.m_boundProcessName ),
        -: 4439:            m_options ( other.m_options ),
        -: 4440:            m_positionalArgs( other.m_positionalArgs ),
        -: 4441:            m_highestSpecifiedArgPosition( other.m_highestSpecifiedArgPosition ),
        -: 4442:            m_throwOnUnrecognisedTokens( other.m_throwOnUnrecognisedTokens )
        -: 4443:        {
        -: 4444:            if( other.m_floatingArg.get() )
        -: 4445:                m_floatingArg.reset( new Arg( *other.m_floatingArg ) );
        -: 4446:        }
        -: 4447:
        1: 4448:        CommandLine& setThrowOnUnrecognisedTokens( bool shouldThrow = true ) {
        1: 4449:            m_throwOnUnrecognisedTokens = shouldThrow;
        1: 4450:            return *this;
        -: 4451:        }
        -: 4452:
       22: 4453:        OptBuilder operator[]( std::string const& optName ) {
       22: 4454:            m_options.push_back( Arg() );
       22: 4455:            addOptName( m_options.back(), optName );
       22: 4456:            OptBuilder builder( &m_options.back() );
       22: 4457:            return builder;
        -: 4458:        }
        -: 4459:
        -: 4460:        ArgBuilder operator[]( int position ) {
        -: 4461:            m_positionalArgs.insert( std::make_pair( position, Arg() ) );
        -: 4462:            if( position > m_highestSpecifiedArgPosition )
        -: 4463:                m_highestSpecifiedArgPosition = position;
        -: 4464:            setPositionalArg( m_positionalArgs[position], position );
        -: 4465:            ArgBuilder builder( &m_positionalArgs[position] );
        -: 4466:            return builder;
        -: 4467:        }
        -: 4468:
        -: 4469:        // Invoke this with the _ instance
        1: 4470:        ArgBuilder operator[]( UnpositionalTag ) {
        1: 4471:            if( m_floatingArg.get() )
    #####: 4472:                throw std::logic_error( "Only one unpositional argument can be added" );
        1: 4473:            m_floatingArg.reset( new Arg() );
        1: 4474:            ArgBuilder builder( m_floatingArg.get() );
        1: 4475:            return builder;
        -: 4476:        }
        -: 4477:
        -: 4478:        template<typename C, typename M>
        1: 4479:        void bindProcessName( M C::* field ) {
        1: 4480:            m_boundProcessName = new Detail::BoundDataMember<C,M>( field );
        1: 4481:        }
        -: 4482:        template<typename C, typename M>
        -: 4483:        void bindProcessName( void (C::*_unaryMethod)( M ) ) {
        -: 4484:            m_boundProcessName = new Detail::BoundUnaryMethod<C,M>( _unaryMethod );
        -: 4485:        }
        -: 4486:
    #####: 4487:        void optUsage( std::ostream& os, std::size_t indent = 0, std::size_t width = Detail::consoleWidth ) const {
    #####: 4488:            typename std::vector<Arg>::const_iterator itBegin = m_options.begin(), itEnd = m_options.end(), it;
    #####: 4489:            std::size_t maxWidth = 0;
    #####: 4490:            for( it = itBegin; it != itEnd; ++it )
    #####: 4491:                maxWidth = (std::max)( maxWidth, it->commands().size() );
        -: 4492:
    #####: 4493:            for( it = itBegin; it != itEnd; ++it ) {
        -: 4494:                Detail::Text usage( it->commands(), Detail::TextAttributes()
    #####: 4495:                                                        .setWidth( maxWidth+indent )
    #####: 4496:                                                        .setIndent( indent ) );
    #####: 4497:                Detail::Text desc( it->description, Detail::TextAttributes()
    #####: 4498:                                                        .setWidth( width - maxWidth - 3 ) );
        -: 4499:
    #####: 4500:                for( std::size_t i = 0; i < (std::max)( usage.size(), desc.size() ); ++i ) {
    #####: 4501:                    std::string usageCol = i < usage.size() ? usage[i] : "";
    #####: 4502:                    os << usageCol;
        -: 4503:
    #####: 4504:                    if( i < desc.size() && !desc[i].empty() )
    #####: 4505:                        os  << std::string( indent + 2 + maxWidth - usageCol.size(), ' ' )
    #####: 4506:                            << desc[i];
    #####: 4507:                    os << "\n";
        -: 4508:                }
        -: 4509:            }
    #####: 4510:        }
        -: 4511:        std::string optUsage() const {
        -: 4512:            std::ostringstream oss;
        -: 4513:            optUsage( oss );
        -: 4514:            return oss.str();
        -: 4515:        }
        -: 4516:
    #####: 4517:        void argSynopsis( std::ostream& os ) const {
    #####: 4518:            for( int i = 1; i <= m_highestSpecifiedArgPosition; ++i ) {
    #####: 4519:                if( i > 1 )
    #####: 4520:                    os << " ";
    #####: 4521:                typename std::map<int, Arg>::const_iterator it = m_positionalArgs.find( i );
    #####: 4522:                if( it != m_positionalArgs.end() )
    #####: 4523:                    os << "<" << it->second.placeholder << ">";
    #####: 4524:                else if( m_floatingArg.get() )
    #####: 4525:                    os << "<" << m_floatingArg->placeholder << ">";
        -: 4526:                else
    #####: 4527:                    throw std::logic_error( "non consecutive positional arguments with no floating args" );
        -: 4528:            }
        -: 4529:            // !TBD No indication of mandatory args
    #####: 4530:            if( m_floatingArg.get() ) {
    #####: 4531:                if( m_highestSpecifiedArgPosition > 1 )
    #####: 4532:                    os << " ";
    #####: 4533:                os << "[<" << m_floatingArg->placeholder << "> ...]";
        -: 4534:            }
    #####: 4535:        }
        -: 4536:        std::string argSynopsis() const {
        -: 4537:            std::ostringstream oss;
        -: 4538:            argSynopsis( oss );
        -: 4539:            return oss.str();
        -: 4540:        }
        -: 4541:
    #####: 4542:        void usage( std::ostream& os, std::string const& procName ) const {
    #####: 4543:            validate();
    #####: 4544:            os << "usage:\n  " << procName << " ";
    #####: 4545:            argSynopsis( os );
    #####: 4546:            if( !m_options.empty() ) {
    #####: 4547:                os << " [options]\n\nwhere options are: \n";
    #####: 4548:                optUsage( os, 2 );
        -: 4549:            }
    #####: 4550:            os << "\n";
    #####: 4551:        }
        -: 4552:        std::string usage( std::string const& procName ) const {
        -: 4553:            std::ostringstream oss;
        -: 4554:            usage( oss, procName );
        -: 4555:            return oss.str();
        -: 4556:        }
        -: 4557:
        -: 4558:        ConfigT parse( std::vector<std::string> const& args ) const {
        -: 4559:            ConfigT config;
        -: 4560:            parseInto( args, config );
        -: 4561:            return config;
        -: 4562:        }
        -: 4563:
        1: 4564:        std::vector<Parser::Token> parseInto( std::vector<std::string> const& args, ConfigT& config ) const {
        2: 4565:            std::string processName = args[0];
        1: 4566:            std::size_t lastSlash = processName.find_last_of( "/\\" );
        1: 4567:            if( lastSlash != std::string::npos )
        1: 4568:                processName = processName.substr( lastSlash+1 );
        1: 4569:            m_boundProcessName.set( config, processName );
        2: 4570:            std::vector<Parser::Token> tokens;
        1: 4571:            Parser parser;
        1: 4572:            parser.parseIntoTokens( args, tokens );
        2: 4573:            return populate( tokens, config );
        -: 4574:        }
        -: 4575:
        1: 4576:        std::vector<Parser::Token> populate( std::vector<Parser::Token> const& tokens, ConfigT& config ) const {
        1: 4577:            validate();
        1: 4578:            std::vector<Parser::Token> unusedTokens = populateOptions( tokens, config );
        1: 4579:            unusedTokens = populateFixedArgs( unusedTokens, config );
        1: 4580:            unusedTokens = populateFloatingArgs( unusedTokens, config );
        1: 4581:            return unusedTokens;
        -: 4582:        }
        -: 4583:
        1: 4584:        std::vector<Parser::Token> populateOptions( std::vector<Parser::Token> const& tokens, ConfigT& config ) const {
        1: 4585:            std::vector<Parser::Token> unusedTokens;
        2: 4586:            std::vector<std::string> errors;
        1: 4587:            for( std::size_t i = 0; i < tokens.size(); ++i ) {
    #####: 4588:                Parser::Token const& token = tokens[i];
    #####: 4589:                typename std::vector<Arg>::const_iterator it = m_options.begin(), itEnd = m_options.end();
    #####: 4590:                for(; it != itEnd; ++it ) {
    #####: 4591:                    Arg const& arg = *it;
        -: 4592:
        -: 4593:                    try {
    #####: 4594:                        if( ( token.type == Parser::Token::ShortOpt && arg.hasShortName( token.data ) ) ||
    #####: 4595:                            ( token.type == Parser::Token::LongOpt && arg.hasLongName( token.data ) ) ) {
    #####: 4596:                            if( arg.takesArg() ) {
    #####: 4597:                                if( i == tokens.size()-1 || tokens[i+1].type != Parser::Token::Positional )
    #####: 4598:                                    errors.push_back( "Expected argument to option: " + token.data );
        -: 4599:                                else
    #####: 4600:                                    arg.boundField.set( config, tokens[++i].data );
        -: 4601:                            }
        -: 4602:                            else {
    #####: 4603:                                arg.boundField.set( config, "true" );
        -: 4604:                            }
    #####: 4605:                            break;
        -: 4606:                        }
        -: 4607:                    }
    =====: 4608:                    catch( std::exception& ex ) {
    =====: 4609:                        errors.push_back( std::string( ex.what() ) + "\n- while parsing: (" + arg.commands() + ")" );
        -: 4610:                    }
        -: 4611:                }
    #####: 4612:                if( it == itEnd ) {
    #####: 4613:                    if( token.type == Parser::Token::Positional || !m_throwOnUnrecognisedTokens )
    #####: 4614:                        unusedTokens.push_back( token );
    #####: 4615:                    else if( errors.empty() && m_throwOnUnrecognisedTokens )
    #####: 4616:                        errors.push_back( "unrecognised option: " + token.data );
        -: 4617:                }
        -: 4618:            }
        1: 4619:            if( !errors.empty() ) {
    #####: 4620:                std::ostringstream oss;
    #####: 4621:                for( std::vector<std::string>::const_iterator it = errors.begin(), itEnd = errors.end();
        -: 4622:                        it != itEnd;
        -: 4623:                        ++it ) {
    #####: 4624:                    if( it != errors.begin() )
    #####: 4625:                        oss << "\n";
    #####: 4626:                    oss << *it;
        -: 4627:                }
    #####: 4628:                throw std::runtime_error( oss.str() );
        -: 4629:            }
        2: 4630:            return unusedTokens;
        -: 4631:        }
        1: 4632:        std::vector<Parser::Token> populateFixedArgs( std::vector<Parser::Token> const& tokens, ConfigT& config ) const {
        1: 4633:            std::vector<Parser::Token> unusedTokens;
        1: 4634:            int position = 1;
        1: 4635:            for( std::size_t i = 0; i < tokens.size(); ++i ) {
    #####: 4636:                Parser::Token const& token = tokens[i];
    #####: 4637:                typename std::map<int, Arg>::const_iterator it = m_positionalArgs.find( position );
    #####: 4638:                if( it != m_positionalArgs.end() )
    #####: 4639:                    it->second.boundField.set( config, token.data );
        -: 4640:                else
    #####: 4641:                    unusedTokens.push_back( token );
    #####: 4642:                if( token.type == Parser::Token::Positional )
    #####: 4643:                    position++;
        -: 4644:            }
        1: 4645:            return unusedTokens;
        -: 4646:        }
        1: 4647:        std::vector<Parser::Token> populateFloatingArgs( std::vector<Parser::Token> const& tokens, ConfigT& config ) const {
        1: 4648:            if( !m_floatingArg.get() )
    #####: 4649:                return tokens;
        2: 4650:            std::vector<Parser::Token> unusedTokens;
        1: 4651:            for( std::size_t i = 0; i < tokens.size(); ++i ) {
    #####: 4652:                Parser::Token const& token = tokens[i];
    #####: 4653:                if( token.type == Parser::Token::Positional )
    #####: 4654:                    m_floatingArg->boundField.set( config, token.data );
        -: 4655:                else
    #####: 4656:                    unusedTokens.push_back( token );
        -: 4657:            }
        1: 4658:            return unusedTokens;
        -: 4659:        }
        -: 4660:
        1: 4661:        void validate() const
        -: 4662:        {
        1: 4663:            if( m_options.empty() && m_positionalArgs.empty() && !m_floatingArg.get() )
    #####: 4664:                throw std::logic_error( "No options or arguments specified" );
        -: 4665:
       46: 4666:            for( typename std::vector<Arg>::const_iterator  it = m_options.begin(),
        1: 4667:                                                            itEnd = m_options.end();
        -: 4668:                    it != itEnd; ++it )
       22: 4669:                it->validate();
        1: 4670:        }
        -: 4671:
        -: 4672:    private:
        -: 4673:        Detail::BoundArgFunction<ConfigT> m_boundProcessName;
        -: 4674:        std::vector<Arg> m_options;
        -: 4675:        std::map<int, Arg> m_positionalArgs;
        -: 4676:        ArgAutoPtr m_floatingArg;
        -: 4677:        int m_highestSpecifiedArgPosition;
        -: 4678:        bool m_throwOnUnrecognisedTokens;
        -: 4679:    };
        -: 4680:
        -: 4681:} // end namespace Clara
        -: 4682:
        -: 4683:STITCH_CLARA_CLOSE_NAMESPACE
        -: 4684:#undef STITCH_CLARA_OPEN_NAMESPACE
        -: 4685:#undef STITCH_CLARA_CLOSE_NAMESPACE
        -: 4686:
        -: 4687:#endif // TWOBLUECUBES_CLARA_H_INCLUDED
        -: 4688:#undef STITCH_CLARA_OPEN_NAMESPACE
        -: 4689:
        -: 4690:// Restore Clara's value for console width, if present
        -: 4691:#ifdef CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
        -: 4692:#define CLARA_CONFIG_CONSOLE_WIDTH CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
        -: 4693:#undef CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
        -: 4694:#endif
        -: 4695:
        -: 4696:#include <fstream>
        -: 4697:
        -: 4698:namespace Catch {
        -: 4699:
    #####: 4700:    inline void abortAfterFirst( ConfigData& config ) { config.abortAfter = 1; }
    #####: 4701:    inline void abortAfterX( ConfigData& config, int x ) {
    #####: 4702:        if( x < 1 )
    #####: 4703:            throw std::runtime_error( "Value after -x or --abortAfter must be greater than zero" );
    #####: 4704:        config.abortAfter = x;
    #####: 4705:    }
    #####: 4706:    inline void addTestOrTags( ConfigData& config, std::string const& _testSpec ) { config.testsOrTags.push_back( _testSpec ); }
    #####: 4707:    inline void addReporterName( ConfigData& config, std::string const& _reporterName ) { config.reporterNames.push_back( _reporterName ); }
        -: 4708:
    #####: 4709:    inline void addWarning( ConfigData& config, std::string const& _warning ) {
    #####: 4710:        if( _warning == "NoAssertions" )
    #####: 4711:            config.warnings = static_cast<WarnAbout::What>( config.warnings | WarnAbout::NoAssertions );
        -: 4712:        else
    #####: 4713:            throw std::runtime_error( "Unrecognised warning: '" + _warning + "'" );
    #####: 4714:    }
    #####: 4715:    inline void setOrder( ConfigData& config, std::string const& order ) {
    #####: 4716:        if( startsWith( "declared", order ) )
    #####: 4717:            config.runOrder = RunTests::InDeclarationOrder;
    #####: 4718:        else if( startsWith( "lexical", order ) )
    #####: 4719:            config.runOrder = RunTests::InLexicographicalOrder;
    #####: 4720:        else if( startsWith( "random", order ) )
    #####: 4721:            config.runOrder = RunTests::InRandomOrder;
        -: 4722:        else
    #####: 4723:            throw std::runtime_error( "Unrecognised ordering: '" + order + "'" );
    #####: 4724:    }
    #####: 4725:    inline void setRngSeed( ConfigData& config, std::string const& seed ) {
    #####: 4726:        if( seed == "time" ) {
    #####: 4727:            config.rngSeed = static_cast<unsigned int>( std::time(0) );
        -: 4728:        }
        -: 4729:        else {
    #####: 4730:            std::stringstream ss;
    #####: 4731:            ss << seed;
    #####: 4732:            ss >> config.rngSeed;
    #####: 4733:            if( ss.fail() )
    #####: 4734:                throw std::runtime_error( "Argment to --rng-seed should be the word 'time' or a number" );
        -: 4735:        }
    #####: 4736:    }
        -: 4737:    inline void setVerbosity( ConfigData& config, int level ) {
        -: 4738:        // !TBD: accept strings?
        -: 4739:        config.verbosity = static_cast<Verbosity::Level>( level );
        -: 4740:    }
    #####: 4741:    inline void setShowDurations( ConfigData& config, bool _showDurations ) {
        -: 4742:        config.showDurations = _showDurations
        -: 4743:            ? ShowDurations::Always
    #####: 4744:            : ShowDurations::Never;
    #####: 4745:    }
    #####: 4746:    inline void setUseColour( ConfigData& config, std::string const& value ) {
    #####: 4747:        std::string mode = toLower( value );
        -: 4748:
    #####: 4749:        if( mode == "yes" )
    #####: 4750:            config.useColour = UseColour::Yes;
    #####: 4751:        else if( mode == "no" )
    #####: 4752:            config.useColour = UseColour::No;
    #####: 4753:        else if( mode == "auto" )
    #####: 4754:            config.useColour = UseColour::Auto;
        -: 4755:        else
    #####: 4756:            throw std::runtime_error( "colour mode must be one of: auto, yes or no" );
    #####: 4757:    }
    #####: 4758:    inline void forceColour( ConfigData& config ) {
    #####: 4759:        config.useColour = UseColour::Yes;
    #####: 4760:    }
    #####: 4761:    inline void loadTestNamesFromFile( ConfigData& config, std::string const& _filename ) {
    #####: 4762:        std::ifstream f( _filename.c_str() );
    #####: 4763:        if( !f.is_open() )
    #####: 4764:            throw std::domain_error( "Unable to load input file: " + _filename );
        -: 4765:
    #####: 4766:        std::string line;
    #####: 4767:        while( std::getline( f, line ) ) {
    #####: 4768:            line = trim(line);
    #####: 4769:            if( !line.empty() && !startsWith( line, "#" ) ) {
    #####: 4770:                if( !startsWith( line, "\"" ) )
    #####: 4771:                    line = "\"" + line + "\"";
    #####: 4772:                addTestOrTags( config, line + "," );
        -: 4773:            }
        -: 4774:        }
    #####: 4775:    }
        -: 4776:
        1: 4777:    inline Clara::CommandLine<ConfigData> makeCommandLineParser() {
        -: 4778:
        -: 4779:        using namespace Clara;
        1: 4780:        CommandLine<ConfigData> cli;
        -: 4781:
        1: 4782:        cli.bindProcessName( &ConfigData::processName );
        -: 4783:
        2: 4784:        cli["-?"]["-h"]["--help"]
        3: 4785:            .describe( "display usage information" )
        1: 4786:            .bind( &ConfigData::showHelp );
        -: 4787:
        2: 4788:        cli["-l"]["--list-tests"]
        3: 4789:            .describe( "list all/matching test cases" )
        1: 4790:            .bind( &ConfigData::listTests );
        -: 4791:
        2: 4792:        cli["-t"]["--list-tags"]
        3: 4793:            .describe( "list all/matching tags" )
        1: 4794:            .bind( &ConfigData::listTags );
        -: 4795:
        2: 4796:        cli["-s"]["--success"]
        3: 4797:            .describe( "include successful tests in output" )
        1: 4798:            .bind( &ConfigData::showSuccessfulTests );
        -: 4799:
        2: 4800:        cli["-b"]["--break"]
        3: 4801:            .describe( "break into debugger on failure" )
        1: 4802:            .bind( &ConfigData::shouldDebugBreak );
        -: 4803:
        2: 4804:        cli["-e"]["--nothrow"]
        3: 4805:            .describe( "skip exception tests" )
        1: 4806:            .bind( &ConfigData::noThrow );
        -: 4807:
        2: 4808:        cli["-i"]["--invisibles"]
        3: 4809:            .describe( "show invisibles (tabs, newlines)" )
        1: 4810:            .bind( &ConfigData::showInvisibles );
        -: 4811:
        2: 4812:        cli["-o"]["--out"]
        3: 4813:            .describe( "output filename" )
        3: 4814:            .bind( &ConfigData::outputFilename, "filename" );
        -: 4815:
        2: 4816:        cli["-r"]["--reporter"]
        -: 4817://            .placeholder( "name[:filename]" )
        3: 4818:            .describe( "reporter to use (defaults to console)" )
        3: 4819:            .bind( &addReporterName, "name" );
        -: 4820:
        2: 4821:        cli["-n"]["--name"]
        3: 4822:            .describe( "suite name" )
        3: 4823:            .bind( &ConfigData::name, "name" );
        -: 4824:
        2: 4825:        cli["-a"]["--abort"]
        3: 4826:            .describe( "abort at first failure" )
        1: 4827:            .bind( &abortAfterFirst );
        -: 4828:
        2: 4829:        cli["-x"]["--abortx"]
        3: 4830:            .describe( "abort after x failures" )
        3: 4831:            .bind( &abortAfterX, "no. failures" );
        -: 4832:
        2: 4833:        cli["-w"]["--warn"]
        3: 4834:            .describe( "enable warnings" )
        3: 4835:            .bind( &addWarning, "warning name" );
        -: 4836:
        -: 4837:// - needs updating if reinstated
        -: 4838://        cli.into( &setVerbosity )
        -: 4839://            .describe( "level of verbosity (0=no output)" )
        -: 4840://            .shortOpt( "v")
        -: 4841://            .longOpt( "verbosity" )
        -: 4842://            .placeholder( "level" );
        -: 4843:
        -: 4844:        cli[_]
        2: 4845:            .describe( "which test or tests to use" )
        3: 4846:            .bind( &addTestOrTags, "test name, pattern or tags" );
        -: 4847:
        2: 4848:        cli["-d"]["--durations"]
        3: 4849:            .describe( "show test durations" )
        3: 4850:            .bind( &setShowDurations, "yes|no" );
        -: 4851:
        2: 4852:        cli["-f"]["--input-file"]
        3: 4853:            .describe( "load test names to run from a file" )
        3: 4854:            .bind( &loadTestNamesFromFile, "filename" );
        -: 4855:
        2: 4856:        cli["-#"]["--filenames-as-tags"]
        3: 4857:            .describe( "adds a tag for the filename" )
        1: 4858:            .bind( &ConfigData::filenamesAsTags );
        -: 4859:
        -: 4860:        // Less common commands which don't have a short form
        -: 4861:        cli["--list-test-names-only"]
        2: 4862:            .describe( "list all/matching test cases names only" )
        1: 4863:            .bind( &ConfigData::listTestNamesOnly );
        -: 4864:
        -: 4865:        cli["--list-reporters"]
        2: 4866:            .describe( "list all reporters" )
        1: 4867:            .bind( &ConfigData::listReporters );
        -: 4868:
        -: 4869:        cli["--order"]
        2: 4870:            .describe( "test case order (defaults to decl)" )
        3: 4871:            .bind( &setOrder, "decl|lex|rand" );
        -: 4872:
        -: 4873:        cli["--rng-seed"]
        2: 4874:            .describe( "set a specific seed for random numbers" )
        3: 4875:            .bind( &setRngSeed, "'time'|number" );
        -: 4876:
        -: 4877:        cli["--force-colour"]
        2: 4878:            .describe( "force colourised output (deprecated)" )
        1: 4879:            .bind( &forceColour );
        -: 4880:
        -: 4881:        cli["--use-colour"]
        2: 4882:            .describe( "should output be colourised" )
        3: 4883:            .bind( &setUseColour, "yes|no" );
        -: 4884:
        1: 4885:        return cli;
        -: 4886:    }
        -: 4887:
        -: 4888:} // end namespace Catch
        -: 4889:
        -: 4890:// #included from: internal/catch_list.hpp
        -: 4891:#define TWOBLUECUBES_CATCH_LIST_HPP_INCLUDED
        -: 4892:
        -: 4893:// #included from: catch_text.h
        -: 4894:#define TWOBLUECUBES_CATCH_TEXT_H_INCLUDED
        -: 4895:
        -: 4896:#define TBC_TEXT_FORMAT_CONSOLE_WIDTH CATCH_CONFIG_CONSOLE_WIDTH
        -: 4897:
        -: 4898:#define CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE Catch
        -: 4899:// #included from: ../external/tbc_text_format.h
        -: 4900:// Only use header guard if we are not using an outer namespace
        -: 4901:#ifndef CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE
        -: 4902:# ifdef TWOBLUECUBES_TEXT_FORMAT_H_INCLUDED
        -: 4903:#  ifndef TWOBLUECUBES_TEXT_FORMAT_H_ALREADY_INCLUDED
        -: 4904:#   define TWOBLUECUBES_TEXT_FORMAT_H_ALREADY_INCLUDED
        -: 4905:#  endif
        -: 4906:# else
        -: 4907:#  define TWOBLUECUBES_TEXT_FORMAT_H_INCLUDED
        -: 4908:# endif
        -: 4909:#endif
        -: 4910:#ifndef TWOBLUECUBES_TEXT_FORMAT_H_ALREADY_INCLUDED
        -: 4911:#include <string>
        -: 4912:#include <vector>
        -: 4913:#include <sstream>
        -: 4914:
        -: 4915:// Use optional outer namespace
        -: 4916:#ifdef CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE
        -: 4917:namespace CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE {
        -: 4918:#endif
        -: 4919:
        -: 4920:namespace Tbc {
        -: 4921:
        -: 4922:#ifdef TBC_TEXT_FORMAT_CONSOLE_WIDTH
        -: 4923:    const unsigned int consoleWidth = TBC_TEXT_FORMAT_CONSOLE_WIDTH;
        -: 4924:#else
        -: 4925:    const unsigned int consoleWidth = 80;
        -: 4926:#endif
        -: 4927:
        -: 4928:    struct TextAttributes {
    #####: 4929:        TextAttributes()
        -: 4930:        :   initialIndent( std::string::npos ),
        -: 4931:            indent( 0 ),
        -: 4932:            width( consoleWidth-1 ),
    #####: 4933:            tabChar( '\t' )
    #####: 4934:        {}
        -: 4935:
    #####: 4936:        TextAttributes& setInitialIndent( std::size_t _value )  { initialIndent = _value; return *this; }
    #####: 4937:        TextAttributes& setIndent( std::size_t _value )         { indent = _value; return *this; }
    #####: 4938:        TextAttributes& setWidth( std::size_t _value )          { width = _value; return *this; }
        -: 4939:        TextAttributes& setTabChar( char _value )               { tabChar = _value; return *this; }
        -: 4940:
        -: 4941:        std::size_t initialIndent;  // indent of first line, or npos
        -: 4942:        std::size_t indent;         // indent of subsequent lines, or all if initialIndent is npos
        -: 4943:        std::size_t width;          // maximum width of text, including indent. Longer text will wrap
        -: 4944:        char tabChar;               // If this char is seen the indent is changed to current pos
        -: 4945:    };
        -: 4946:
    #####: 4947:    class Text {
        -: 4948:    public:
    #####: 4949:        Text( std::string const& _str, TextAttributes const& _attr = TextAttributes() )
    #####: 4950:        : attr( _attr )
        -: 4951:        {
    #####: 4952:            std::string wrappableChars = " [({.,/|\\-";
    #####: 4953:            std::size_t indent = _attr.initialIndent != std::string::npos
        -: 4954:                ? _attr.initialIndent
    #####: 4955:                : _attr.indent;
    #####: 4956:            std::string remainder = _str;
        -: 4957:
    #####: 4958:            while( !remainder.empty() ) {
    #####: 4959:                if( lines.size() >= 1000 ) {
    #####: 4960:                    lines.push_back( "... message truncated due to excessive size" );
    #####: 4961:                    return;
        -: 4962:                }
    #####: 4963:                std::size_t tabPos = std::string::npos;
    #####: 4964:                std::size_t width = (std::min)( remainder.size(), _attr.width - indent );
    #####: 4965:                std::size_t pos = remainder.find_first_of( '\n' );
    #####: 4966:                if( pos <= width ) {
    #####: 4967:                    width = pos;
        -: 4968:                }
    #####: 4969:                pos = remainder.find_last_of( _attr.tabChar, width );
    #####: 4970:                if( pos != std::string::npos ) {
    #####: 4971:                    tabPos = pos;
    #####: 4972:                    if( remainder[width] == '\n' )
    #####: 4973:                        width--;
    #####: 4974:                    remainder = remainder.substr( 0, tabPos ) + remainder.substr( tabPos+1 );
        -: 4975:                }
        -: 4976:
    #####: 4977:                if( width == remainder.size() ) {
    #####: 4978:                    spliceLine( indent, remainder, width );
        -: 4979:                }
    #####: 4980:                else if( remainder[width] == '\n' ) {
    #####: 4981:                    spliceLine( indent, remainder, width );
    #####: 4982:                    if( width <= 1 || remainder.size() != 1 )
    #####: 4983:                        remainder = remainder.substr( 1 );
    #####: 4984:                    indent = _attr.indent;
        -: 4985:                }
        -: 4986:                else {
    #####: 4987:                    pos = remainder.find_last_of( wrappableChars, width );
    #####: 4988:                    if( pos != std::string::npos && pos > 0 ) {
    #####: 4989:                        spliceLine( indent, remainder, pos );
    #####: 4990:                        if( remainder[0] == ' ' )
    #####: 4991:                            remainder = remainder.substr( 1 );
        -: 4992:                    }
        -: 4993:                    else {
    #####: 4994:                        spliceLine( indent, remainder, width-1 );
    #####: 4995:                        lines.back() += "-";
        -: 4996:                    }
    #####: 4997:                    if( lines.size() == 1 )
    #####: 4998:                        indent = _attr.indent;
    #####: 4999:                    if( tabPos != std::string::npos )
    #####: 5000:                        indent += tabPos;
        -: 5001:                }
        -: 5002:            }
        -: 5003:        }
        -: 5004:
    #####: 5005:        void spliceLine( std::size_t _indent, std::string& _remainder, std::size_t _pos ) {
    #####: 5006:            lines.push_back( std::string( _indent, ' ' ) + _remainder.substr( 0, _pos ) );
    #####: 5007:            _remainder = _remainder.substr( _pos );
    #####: 5008:        }
        -: 5009:
        -: 5010:        typedef std::vector<std::string>::const_iterator const_iterator;
        -: 5011:
    #####: 5012:        const_iterator begin() const { return lines.begin(); }
    #####: 5013:        const_iterator end() const { return lines.end(); }
        -: 5014:        std::string const& last() const { return lines.back(); }
        -: 5015:        std::size_t size() const { return lines.size(); }
        -: 5016:        std::string const& operator[]( std::size_t _index ) const { return lines[_index]; }
        -: 5017:        std::string toString() const {
        -: 5018:            std::ostringstream oss;
        -: 5019:            oss << *this;
        -: 5020:            return oss.str();
        -: 5021:        }
        -: 5022:
    #####: 5023:        inline friend std::ostream& operator << ( std::ostream& _stream, Text const& _text ) {
    #####: 5024:            for( Text::const_iterator it = _text.begin(), itEnd = _text.end();
        -: 5025:                it != itEnd; ++it ) {
    #####: 5026:                if( it != _text.begin() )
    #####: 5027:                    _stream << "\n";
    #####: 5028:                _stream << *it;
        -: 5029:            }
    #####: 5030:            return _stream;
        -: 5031:        }
        -: 5032:
        -: 5033:    private:
        -: 5034:        std::string str;
        -: 5035:        TextAttributes attr;
        -: 5036:        std::vector<std::string> lines;
        -: 5037:    };
        -: 5038:
        -: 5039:} // end namespace Tbc
        -: 5040:
        -: 5041:#ifdef CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE
        -: 5042:} // end outer namespace
        -: 5043:#endif
        -: 5044:
        -: 5045:#endif // TWOBLUECUBES_TEXT_FORMAT_H_ALREADY_INCLUDED
        -: 5046:#undef CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE
        -: 5047:
        -: 5048:namespace Catch {
        -: 5049:    using Tbc::Text;
        -: 5050:    using Tbc::TextAttributes;
        -: 5051:}
        -: 5052:
        -: 5053:// #included from: catch_console_colour.hpp
        -: 5054:#define TWOBLUECUBES_CATCH_CONSOLE_COLOUR_HPP_INCLUDED
        -: 5055:
        -: 5056:namespace Catch {
        -: 5057:
        -: 5058:    struct Colour {
        -: 5059:        enum Code {
        -: 5060:            None = 0,
        -: 5061:
        -: 5062:            White,
        -: 5063:            Red,
        -: 5064:            Green,
        -: 5065:            Blue,
        -: 5066:            Cyan,
        -: 5067:            Yellow,
        -: 5068:            Grey,
        -: 5069:
        -: 5070:            Bright = 0x10,
        -: 5071:
        -: 5072:            BrightRed = Bright | Red,
        -: 5073:            BrightGreen = Bright | Green,
        -: 5074:            LightGrey = Bright | Grey,
        -: 5075:            BrightWhite = Bright | White,
        -: 5076:
        -: 5077:            // By intention
        -: 5078:            FileName = LightGrey,
        -: 5079:            Warning = Yellow,
        -: 5080:            ResultError = BrightRed,
        -: 5081:            ResultSuccess = BrightGreen,
        -: 5082:            ResultExpectedFailure = Warning,
        -: 5083:
        -: 5084:            Error = BrightRed,
        -: 5085:            Success = Green,
        -: 5086:
        -: 5087:            OriginalExpression = Cyan,
        -: 5088:            ReconstructedExpression = Yellow,
        -: 5089:
        -: 5090:            SecondaryText = LightGrey,
        -: 5091:            Headers = White
        -: 5092:        };
        -: 5093:
        -: 5094:        // Use constructed object for RAII guard
        -: 5095:        Colour( Code _colourCode );
        -: 5096:        Colour( Colour const& other );
        -: 5097:        ~Colour();
        -: 5098:
        -: 5099:        // Use static method for one-shot changes
        -: 5100:        static void use( Code _colourCode );
        -: 5101:
        -: 5102:    private:
        -: 5103:        bool m_moved;
        -: 5104:    };
        -: 5105:
        2: 5106:    inline std::ostream& operator << ( std::ostream& os, Colour const& ) { return os; }
        -: 5107:
        -: 5108:} // end namespace Catch
        -: 5109:
        -: 5110:// #included from: catch_interfaces_reporter.h
        -: 5111:#define TWOBLUECUBES_CATCH_INTERFACES_REPORTER_H_INCLUDED
        -: 5112:
        -: 5113:#include <string>
        -: 5114:#include <ostream>
        -: 5115:#include <map>
        -: 5116:#include <assert.h>
        -: 5117:
        -: 5118:namespace Catch
        -: 5119:{
        1: 5120:    struct ReporterConfig {
        1: 5121:        explicit ReporterConfig( Ptr<IConfig const> const& _fullConfig )
        1: 5122:        :   m_stream( &_fullConfig->stream() ), m_fullConfig( _fullConfig ) {}
        -: 5123:
        -: 5124:        ReporterConfig( Ptr<IConfig const> const& _fullConfig, std::ostream& _stream )
        -: 5125:        :   m_stream( &_stream ), m_fullConfig( _fullConfig ) {}
        -: 5126:
        1: 5127:        std::ostream& stream() const    { return *m_stream; }
        1: 5128:        Ptr<IConfig const> fullConfig() const { return m_fullConfig; }
        -: 5129:
        -: 5130:    private:
        -: 5131:        std::ostream* m_stream;
        -: 5132:        Ptr<IConfig const> m_fullConfig;
        -: 5133:    };
        -: 5134:
        -: 5135:    struct ReporterPreferences {
        1: 5136:        ReporterPreferences()
        1: 5137:        : shouldRedirectStdOut( false )
        1: 5138:        {}
        -: 5139:
        -: 5140:        bool shouldRedirectStdOut;
        -: 5141:    };
        -: 5142:
        -: 5143:    template<typename T>
        3: 5144:    struct LazyStat : Option<T> {
        3: 5145:        LazyStat() : used( false ) {}
        2: 5146:        LazyStat& operator=( T const& _value ) {
        2: 5147:            Option<T>::operator=( _value );
        2: 5148:            used = false;
        2: 5149:            return *this;
        -: 5150:        }
        4: 5151:        void reset() {
        4: 5152:            Option<T>::reset();
        4: 5153:            used = false;
        4: 5154:        }
        -: 5155:        bool used;
        -: 5156:    };
        -: 5157:
        5: 5158:    struct TestRunInfo {
        1: 5159:        TestRunInfo( std::string const& _name ) : name( _name ) {}
        -: 5160:        std::string name;
        -: 5161:    };
        6: 5162:    struct GroupInfo {
        2: 5163:        GroupInfo(  std::string const& _name,
        -: 5164:                    std::size_t _groupIndex,
        -: 5165:                    std::size_t _groupsCount )
        -: 5166:        :   name( _name ),
        -: 5167:            groupIndex( _groupIndex ),
        2: 5168:            groupsCounts( _groupsCount )
        2: 5169:        {}
        -: 5170:
        -: 5171:        std::string name;
        -: 5172:        std::size_t groupIndex;
        -: 5173:        std::size_t groupsCounts;
        -: 5174:    };
        -: 5175:
        -: 5176:    struct AssertionStats {
    #####: 5177:        AssertionStats( AssertionResult const& _assertionResult,
        -: 5178:                        std::vector<MessageInfo> const& _infoMessages,
        -: 5179:                        Totals const& _totals )
        -: 5180:        :   assertionResult( _assertionResult ),
        -: 5181:            infoMessages( _infoMessages ),
    #####: 5182:            totals( _totals )
        -: 5183:        {
    #####: 5184:            if( assertionResult.hasMessage() ) {
        -: 5185:                // Copy message into messages list.
        -: 5186:                // !TBD This should have been done earlier, somewhere
    #####: 5187:                MessageBuilder builder( assertionResult.getTestMacroName(), assertionResult.getSourceInfo(), assertionResult.getResultType() );
    #####: 5188:                builder << assertionResult.getMessage();
    #####: 5189:                builder.m_info.message = builder.m_stream.str();
        -: 5190:
    #####: 5191:                infoMessages.push_back( builder.m_info );
        -: 5192:            }
    #####: 5193:        }
        -: 5194:        virtual ~AssertionStats();
        -: 5195:
        -: 5196:#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
    #####: 5197:        AssertionStats( AssertionStats const& )              = default;
    #####: 5198:        AssertionStats( AssertionStats && )                  = default;
        -: 5199:        AssertionStats& operator = ( AssertionStats const& ) = default;
        -: 5200:        AssertionStats& operator = ( AssertionStats && )     = default;
        -: 5201:#  endif
        -: 5202:
        -: 5203:        AssertionResult assertionResult;
        -: 5204:        std::vector<MessageInfo> infoMessages;
        -: 5205:        Totals totals;
        -: 5206:    };
        -: 5207:
    #####: 5208:    struct SectionStats {
    #####: 5209:        SectionStats(   SectionInfo const& _sectionInfo,
        -: 5210:                        Counts const& _assertions,
        -: 5211:                        double _durationInSeconds,
        -: 5212:                        bool _missingAssertions )
        -: 5213:        :   sectionInfo( _sectionInfo ),
        -: 5214:            assertions( _assertions ),
        -: 5215:            durationInSeconds( _durationInSeconds ),
    #####: 5216:            missingAssertions( _missingAssertions )
    #####: 5217:        {}
        -: 5218:        virtual ~SectionStats();
        -: 5219:#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
    #####: 5220:        SectionStats( SectionStats const& )              = default;
        -: 5221:        SectionStats( SectionStats && )                  = default;
        -: 5222:        SectionStats& operator = ( SectionStats const& ) = default;
        -: 5223:        SectionStats& operator = ( SectionStats && )     = default;
        -: 5224:#  endif
        -: 5225:
        -: 5226:        SectionInfo sectionInfo;
        -: 5227:        Counts assertions;
        -: 5228:        double durationInSeconds;
        -: 5229:        bool missingAssertions;
        -: 5230:    };
        -: 5231:
        -: 5232:    struct TestCaseStats {
    #####: 5233:        TestCaseStats(  TestCaseInfo const& _testInfo,
        -: 5234:                        Totals const& _totals,
        -: 5235:                        std::string const& _stdOut,
        -: 5236:                        std::string const& _stdErr,
        -: 5237:                        bool _aborting )
        -: 5238:        : testInfo( _testInfo ),
        -: 5239:            totals( _totals ),
        -: 5240:            stdOut( _stdOut ),
        -: 5241:            stdErr( _stdErr ),
    #####: 5242:            aborting( _aborting )
    #####: 5243:        {}
        -: 5244:        virtual ~TestCaseStats();
        -: 5245:
        -: 5246:#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
    #####: 5247:        TestCaseStats( TestCaseStats const& )              = default;
        -: 5248:        TestCaseStats( TestCaseStats && )                  = default;
        -: 5249:        TestCaseStats& operator = ( TestCaseStats const& ) = default;
        -: 5250:        TestCaseStats& operator = ( TestCaseStats && )     = default;
        -: 5251:#  endif
        -: 5252:
        -: 5253:        TestCaseInfo testInfo;
        -: 5254:        Totals totals;
        -: 5255:        std::string stdOut;
        -: 5256:        std::string stdErr;
        -: 5257:        bool aborting;
        -: 5258:    };
        -: 5259:
        -: 5260:    struct TestGroupStats {
        1: 5261:        TestGroupStats( GroupInfo const& _groupInfo,
        -: 5262:                        Totals const& _totals,
        -: 5263:                        bool _aborting )
        -: 5264:        :   groupInfo( _groupInfo ),
        -: 5265:            totals( _totals ),
        1: 5266:            aborting( _aborting )
        1: 5267:        {}
        -: 5268:        TestGroupStats( GroupInfo const& _groupInfo )
        -: 5269:        :   groupInfo( _groupInfo ),
        -: 5270:            aborting( false )
        -: 5271:        {}
        -: 5272:        virtual ~TestGroupStats();
        -: 5273:
        -: 5274:#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
    #####: 5275:        TestGroupStats( TestGroupStats const& )              = default;
        -: 5276:        TestGroupStats( TestGroupStats && )                  = default;
        -: 5277:        TestGroupStats& operator = ( TestGroupStats const& ) = default;
        -: 5278:        TestGroupStats& operator = ( TestGroupStats && )     = default;
        -: 5279:#  endif
        -: 5280:
        -: 5281:        GroupInfo groupInfo;
        -: 5282:        Totals totals;
        -: 5283:        bool aborting;
        -: 5284:    };
        -: 5285:
        -: 5286:    struct TestRunStats {
        1: 5287:        TestRunStats(   TestRunInfo const& _runInfo,
        -: 5288:                        Totals const& _totals,
        -: 5289:                        bool _aborting )
        -: 5290:        :   runInfo( _runInfo ),
        -: 5291:            totals( _totals ),
        1: 5292:            aborting( _aborting )
        1: 5293:        {}
        -: 5294:        virtual ~TestRunStats();
        -: 5295:
        -: 5296:#  ifndef CATCH_CONFIG_CPP11_GENERATED_METHODS
        -: 5297:        TestRunStats( TestRunStats const& _other )
        -: 5298:        :   runInfo( _other.runInfo ),
        -: 5299:            totals( _other.totals ),
        -: 5300:            aborting( _other.aborting )
        -: 5301:        {}
        -: 5302:#  else
    #####: 5303:        TestRunStats( TestRunStats const& )              = default;
        -: 5304:        TestRunStats( TestRunStats && )                  = default;
        -: 5305:        TestRunStats& operator = ( TestRunStats const& ) = default;
        -: 5306:        TestRunStats& operator = ( TestRunStats && )     = default;
        -: 5307:#  endif
        -: 5308:
        -: 5309:        TestRunInfo runInfo;
        -: 5310:        Totals totals;
        -: 5311:        bool aborting;
        -: 5312:    };
        -: 5313:
        -: 5314:    class MultipleReporters;
        -: 5315:
        1: 5316:    struct IStreamingReporter : IShared {
        -: 5317:        virtual ~IStreamingReporter();
        -: 5318:
        -: 5319:        // Implementing class must also provide the following static method:
        -: 5320:        // static std::string getDescription();
        -: 5321:
        -: 5322:        virtual ReporterPreferences getPreferences() const = 0;
        -: 5323:
        -: 5324:        virtual void noMatchingTestCases( std::string const& spec ) = 0;
        -: 5325:
        -: 5326:        virtual void testRunStarting( TestRunInfo const& testRunInfo ) = 0;
        -: 5327:        virtual void testGroupStarting( GroupInfo const& groupInfo ) = 0;
        -: 5328:
        -: 5329:        virtual void testCaseStarting( TestCaseInfo const& testInfo ) = 0;
        -: 5330:        virtual void sectionStarting( SectionInfo const& sectionInfo ) = 0;
        -: 5331:
        -: 5332:        virtual void assertionStarting( AssertionInfo const& assertionInfo ) = 0;
        -: 5333:
        -: 5334:        // The return value indicates if the messages buffer should be cleared:
        -: 5335:        virtual bool assertionEnded( AssertionStats const& assertionStats ) = 0;
        -: 5336:
        -: 5337:        virtual void sectionEnded( SectionStats const& sectionStats ) = 0;
        -: 5338:        virtual void testCaseEnded( TestCaseStats const& testCaseStats ) = 0;
        -: 5339:        virtual void testGroupEnded( TestGroupStats const& testGroupStats ) = 0;
        -: 5340:        virtual void testRunEnded( TestRunStats const& testRunStats ) = 0;
        -: 5341:
        -: 5342:        virtual void skipTest( TestCaseInfo const& testInfo ) = 0;
        -: 5343:
    #####: 5344:        virtual MultipleReporters* tryAsMulti() { return CATCH_NULL; }
        -: 5345:    };
        -: 5346:
        4: 5347:    struct IReporterFactory : IShared {
        -: 5348:        virtual ~IReporterFactory();
        -: 5349:        virtual IStreamingReporter* create( ReporterConfig const& config ) const = 0;
        -: 5350:        virtual std::string getDescription() const = 0;
        -: 5351:    };
        -: 5352:
        1: 5353:    struct IReporterRegistry {
        -: 5354:        typedef std::map<std::string, Ptr<IReporterFactory> > FactoryMap;
        -: 5355:        typedef std::vector<Ptr<IReporterFactory> > Listeners;
        -: 5356:
        -: 5357:        virtual ~IReporterRegistry();
        -: 5358:        virtual IStreamingReporter* create( std::string const& name, Ptr<IConfig const> const& config ) const = 0;
        -: 5359:        virtual FactoryMap const& getFactories() const = 0;
        -: 5360:        virtual Listeners const& getListeners() const = 0;
        -: 5361:    };
        -: 5362:
        -: 5363:    Ptr<IStreamingReporter> addReporter( Ptr<IStreamingReporter> const& existingReporter, Ptr<IStreamingReporter> const& additionalReporter );
        -: 5364:
        -: 5365:}
        -: 5366:
        -: 5367:#include <limits>
        -: 5368:#include <algorithm>
        -: 5369:
        -: 5370:namespace Catch {
        -: 5371:
    #####: 5372:    inline std::size_t listTests( Config const& config ) {
        -: 5373:
    #####: 5374:        TestSpec testSpec = config.testSpec();
    #####: 5375:        if( config.testSpec().hasFilters() )
    #####: 5376:            Catch::cout() << "Matching test cases:\n";
        -: 5377:        else {
    #####: 5378:            Catch::cout() << "All available test cases:\n";
    #####: 5379:            testSpec = TestSpecParser( ITagAliasRegistry::get() ).parse( "*" ).testSpec();
        -: 5380:        }
        -: 5381:
    #####: 5382:        std::size_t matchedTests = 0;
    #####: 5383:        TextAttributes nameAttr, tagsAttr;
    #####: 5384:        nameAttr.setInitialIndent( 2 ).setIndent( 4 );
    #####: 5385:        tagsAttr.setIndent( 6 );
        -: 5386:
    #####: 5387:        std::vector<TestCase> matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );
    #####: 5388:        for( std::vector<TestCase>::const_iterator it = matchedTestCases.begin(), itEnd = matchedTestCases.end();
        -: 5389:                it != itEnd;
        -: 5390:                ++it ) {
    #####: 5391:            matchedTests++;
    #####: 5392:            TestCaseInfo const& testCaseInfo = it->getTestCaseInfo();
    #####: 5393:            Colour::Code colour = testCaseInfo.isHidden()
        -: 5394:                ? Colour::SecondaryText
    #####: 5395:                : Colour::None;
    #####: 5396:            Colour colourGuard( colour );
        -: 5397:
    #####: 5398:            Catch::cout() << Text( testCaseInfo.name, nameAttr ) << std::endl;
    #####: 5399:            if( !testCaseInfo.tags.empty() )
    #####: 5400:                Catch::cout() << Text( testCaseInfo.tagsAsString, tagsAttr ) << std::endl;
        -: 5401:        }
        -: 5402:
    #####: 5403:        if( !config.testSpec().hasFilters() )
    #####: 5404:            Catch::cout() << pluralise( matchedTests, "test case" ) << "\n" << std::endl;
        -: 5405:        else
    #####: 5406:            Catch::cout() << pluralise( matchedTests, "matching test case" ) << "\n" << std::endl;
    #####: 5407:        return matchedTests;
        -: 5408:    }
        -: 5409:
    #####: 5410:    inline std::size_t listTestsNamesOnly( Config const& config ) {
    #####: 5411:        TestSpec testSpec = config.testSpec();
    #####: 5412:        if( !config.testSpec().hasFilters() )
    #####: 5413:            testSpec = TestSpecParser( ITagAliasRegistry::get() ).parse( "*" ).testSpec();
    #####: 5414:        std::size_t matchedTests = 0;
    #####: 5415:        std::vector<TestCase> matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );
    #####: 5416:        for( std::vector<TestCase>::const_iterator it = matchedTestCases.begin(), itEnd = matchedTestCases.end();
        -: 5417:                it != itEnd;
        -: 5418:                ++it ) {
    #####: 5419:            matchedTests++;
    #####: 5420:            TestCaseInfo const& testCaseInfo = it->getTestCaseInfo();
    #####: 5421:            if( startsWith( testCaseInfo.name, "#" ) )
    #####: 5422:               Catch::cout() << "\"" << testCaseInfo.name << "\"" << std::endl;
        -: 5423:            else
    #####: 5424:               Catch::cout() << testCaseInfo.name << std::endl;
        -: 5425:        }
    #####: 5426:        return matchedTests;
        -: 5427:    }
        -: 5428:
    #####: 5429:    struct TagInfo {
    #####: 5430:        TagInfo() : count ( 0 ) {}
    #####: 5431:        void add( std::string const& spelling ) {
    #####: 5432:            ++count;
    #####: 5433:            spellings.insert( spelling );
    #####: 5434:        }
    #####: 5435:        std::string all() const {
    #####: 5436:            std::string out;
    #####: 5437:            for( std::set<std::string>::const_iterator it = spellings.begin(), itEnd = spellings.end();
        -: 5438:                        it != itEnd;
        -: 5439:                        ++it )
    #####: 5440:                out += "[" + *it + "]";
    #####: 5441:            return out;
        -: 5442:        }
        -: 5443:        std::set<std::string> spellings;
        -: 5444:        std::size_t count;
        -: 5445:    };
        -: 5446:
    #####: 5447:    inline std::size_t listTags( Config const& config ) {
    #####: 5448:        TestSpec testSpec = config.testSpec();
    #####: 5449:        if( config.testSpec().hasFilters() )
    #####: 5450:            Catch::cout() << "Tags for matching test cases:\n";
        -: 5451:        else {
    #####: 5452:            Catch::cout() << "All available tags:\n";
    #####: 5453:            testSpec = TestSpecParser( ITagAliasRegistry::get() ).parse( "*" ).testSpec();
        -: 5454:        }
        -: 5455:
    #####: 5456:        std::map<std::string, TagInfo> tagCounts;
        -: 5457:
    #####: 5458:        std::vector<TestCase> matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );
    #####: 5459:        for( std::vector<TestCase>::const_iterator it = matchedTestCases.begin(), itEnd = matchedTestCases.end();
        -: 5460:                it != itEnd;
        -: 5461:                ++it ) {
    #####: 5462:            for( std::set<std::string>::const_iterator  tagIt = it->getTestCaseInfo().tags.begin(),
    #####: 5463:                                                        tagItEnd = it->getTestCaseInfo().tags.end();
        -: 5464:                    tagIt != tagItEnd;
        -: 5465:                    ++tagIt ) {
    #####: 5466:                std::string tagName = *tagIt;
    #####: 5467:                std::string lcaseTagName = toLower( tagName );
    #####: 5468:                std::map<std::string, TagInfo>::iterator countIt = tagCounts.find( lcaseTagName );
    #####: 5469:                if( countIt == tagCounts.end() )
    #####: 5470:                    countIt = tagCounts.insert( std::make_pair( lcaseTagName, TagInfo() ) ).first;
    #####: 5471:                countIt->second.add( tagName );
        -: 5472:            }
        -: 5473:        }
        -: 5474:
    #####: 5475:        for( std::map<std::string, TagInfo>::const_iterator countIt = tagCounts.begin(),
    #####: 5476:                                                            countItEnd = tagCounts.end();
        -: 5477:                countIt != countItEnd;
        -: 5478:                ++countIt ) {
    #####: 5479:            std::ostringstream oss;
    #####: 5480:            oss << "  " << std::setw(2) << countIt->second.count << "  ";
    #####: 5481:            Text wrapper( countIt->second.all(), TextAttributes()
    #####: 5482:                                                    .setInitialIndent( 0 )
    #####: 5483:                                                    .setIndent( oss.str().size() )
    #####: 5484:                                                    .setWidth( CATCH_CONFIG_CONSOLE_WIDTH-10 ) );
    #####: 5485:            Catch::cout() << oss.str() << wrapper << "\n";
        -: 5486:        }
    #####: 5487:        Catch::cout() << pluralise( tagCounts.size(), "tag" ) << "\n" << std::endl;
    #####: 5488:        return tagCounts.size();
        -: 5489:    }
        -: 5490:
    #####: 5491:    inline std::size_t listReporters( Config const& /*config*/ ) {
    #####: 5492:        Catch::cout() << "Available reporters:\n";
    #####: 5493:        IReporterRegistry::FactoryMap const& factories = getRegistryHub().getReporterRegistry().getFactories();
    #####: 5494:        IReporterRegistry::FactoryMap::const_iterator itBegin = factories.begin(), itEnd = factories.end(), it;
    #####: 5495:        std::size_t maxNameLen = 0;
    #####: 5496:        for(it = itBegin; it != itEnd; ++it )
    #####: 5497:            maxNameLen = (std::max)( maxNameLen, it->first.size() );
        -: 5498:
    #####: 5499:        for(it = itBegin; it != itEnd; ++it ) {
    #####: 5500:            Text wrapper( it->second->getDescription(), TextAttributes()
    #####: 5501:                                                        .setInitialIndent( 0 )
    #####: 5502:                                                        .setIndent( 7+maxNameLen )
    #####: 5503:                                                        .setWidth( CATCH_CONFIG_CONSOLE_WIDTH - maxNameLen-8 ) );
    #####: 5504:            Catch::cout() << "  "
    #####: 5505:                    << it->first
    #####: 5506:                    << ":"
    #####: 5507:                    << std::string( maxNameLen - it->first.size() + 2, ' ' )
    #####: 5508:                    << wrapper << "\n";
        -: 5509:        }
    #####: 5510:        Catch::cout() << std::endl;
    #####: 5511:        return factories.size();
        -: 5512:    }
        -: 5513:
        1: 5514:    inline Option<std::size_t> list( Config const& config ) {
        1: 5515:        Option<std::size_t> listedCount;
        1: 5516:        if( config.listTests() )
    #####: 5517:            listedCount = listedCount.valueOr(0) + listTests( config );
        1: 5518:        if( config.listTestNamesOnly() )
    #####: 5519:            listedCount = listedCount.valueOr(0) + listTestsNamesOnly( config );
        1: 5520:        if( config.listTags() )
    #####: 5521:            listedCount = listedCount.valueOr(0) + listTags( config );
        1: 5522:        if( config.listReporters() )
    #####: 5523:            listedCount = listedCount.valueOr(0) + listReporters( config );
        1: 5524:        return listedCount;
        -: 5525:    }
        -: 5526:
        -: 5527:} // end namespace Catch
        -: 5528:
        -: 5529:// #included from: internal/catch_run_context.hpp
        -: 5530:#define TWOBLUECUBES_CATCH_RUNNER_IMPL_HPP_INCLUDED
        -: 5531:
        -: 5532:// #included from: catch_test_case_tracker.hpp
        -: 5533:#define TWOBLUECUBES_CATCH_TEST_CASE_TRACKER_HPP_INCLUDED
        -: 5534:
        -: 5535:#include <map>
        -: 5536:#include <string>
        -: 5537:#include <assert.h>
        -: 5538:#include <vector>
        -: 5539:
        -: 5540:namespace Catch {
        -: 5541:namespace TestCaseTracking {
        -: 5542:
    #####: 5543:    struct ITracker : SharedImpl<> {
        -: 5544:        virtual ~ITracker();
        -: 5545:
        -: 5546:        // static queries
        -: 5547:        virtual std::string name() const = 0;
        -: 5548:
        -: 5549:        // dynamic queries
        -: 5550:        virtual bool isComplete() const = 0; // Successfully completed or failed
        -: 5551:        virtual bool isSuccessfullyCompleted() const = 0;
        -: 5552:        virtual bool isOpen() const = 0; // Started but not complete
        -: 5553:        virtual bool hasChildren() const = 0;
        -: 5554:
        -: 5555:        virtual ITracker& parent() = 0;
        -: 5556:
        -: 5557:        // actions
        -: 5558:        virtual void close() = 0; // Successfully complete
        -: 5559:        virtual void fail() = 0;
        -: 5560:        virtual void markAsNeedingAnotherRun() = 0;
        -: 5561:
        -: 5562:        virtual void addChild( Ptr<ITracker> const& child ) = 0;
        -: 5563:        virtual ITracker* findChild( std::string const& name ) = 0;
        -: 5564:        virtual void openChild() = 0;
        -: 5565:
        -: 5566:        // Debug/ checking
        -: 5567:        virtual bool isSectionTracker() const = 0;
        -: 5568:        virtual bool isIndexTracker() const = 0;
        -: 5569:    };
        -: 5570:
        1: 5571:    class TrackerContext {
        -: 5572:
        -: 5573:        enum RunState {
        -: 5574:            NotStarted,
        -: 5575:            Executing,
        -: 5576:            CompletedCycle
        -: 5577:        };
        -: 5578:
        -: 5579:        Ptr<ITracker> m_rootTracker;
        -: 5580:        ITracker* m_currentTracker;
        -: 5581:        RunState m_runState;
        -: 5582:
        -: 5583:    public:
        -: 5584:
        -: 5585:        static TrackerContext& instance() {
        -: 5586:            static TrackerContext s_instance;
        -: 5587:            return s_instance;
        -: 5588:        }
        -: 5589:
        1: 5590:        TrackerContext()
        -: 5591:        :   m_currentTracker( CATCH_NULL ),
        1: 5592:            m_runState( NotStarted )
        1: 5593:        {}
        -: 5594:
        -: 5595:        ITracker& startRun();
        -: 5596:
        -: 5597:        void endRun() {
        -: 5598:            m_rootTracker.reset();
        -: 5599:            m_currentTracker = CATCH_NULL;
        -: 5600:            m_runState = NotStarted;
        -: 5601:        }
        -: 5602:
    #####: 5603:        void startCycle() {
    #####: 5604:            m_currentTracker = m_rootTracker.get();
    #####: 5605:            m_runState = Executing;
    #####: 5606:        }
    #####: 5607:        void completeCycle() {
    #####: 5608:            m_runState = CompletedCycle;
    #####: 5609:        }
        -: 5610:
    #####: 5611:        bool completedCycle() const {
    #####: 5612:            return m_runState == CompletedCycle;
        -: 5613:        }
    #####: 5614:        ITracker& currentTracker() {
    #####: 5615:            return *m_currentTracker;
        -: 5616:        }
    #####: 5617:        void setCurrentTracker( ITracker* tracker ) {
    #####: 5618:            m_currentTracker = tracker;
    #####: 5619:        }
        -: 5620:    };
        -: 5621:
        -: 5622:    class TrackerBase : public ITracker {
        -: 5623:    protected:
        -: 5624:        enum CycleState {
        -: 5625:            NotStarted,
        -: 5626:            Executing,
        -: 5627:            ExecutingChildren,
        -: 5628:            NeedsAnotherRun,
        -: 5629:            CompletedSuccessfully,
        -: 5630:            Failed
        -: 5631:        };
    #####: 5632:        class TrackerHasName {
        -: 5633:            std::string m_name;
        -: 5634:        public:
    #####: 5635:            TrackerHasName( std::string const& name ) : m_name( name ) {}
    #####: 5636:            bool operator ()( Ptr<ITracker> const& tracker ) {
    #####: 5637:                return tracker->name() == m_name;
        -: 5638:            }
        -: 5639:        };
        -: 5640:        typedef std::vector<Ptr<ITracker> > Children;
        -: 5641:        std::string m_name;
        -: 5642:        TrackerContext& m_ctx;
        -: 5643:        ITracker* m_parent;
        -: 5644:        Children m_children;
        -: 5645:        CycleState m_runState;
        -: 5646:    public:
    #####: 5647:        TrackerBase( std::string const& name, TrackerContext& ctx, ITracker* parent )
        -: 5648:        :   m_name( name ),
        -: 5649:            m_ctx( ctx ),
        -: 5650:            m_parent( parent ),
    #####: 5651:            m_runState( NotStarted )
    #####: 5652:        {}
        -: 5653:        virtual ~TrackerBase();
        -: 5654:
    #####: 5655:        virtual std::string name() const CATCH_OVERRIDE {
    #####: 5656:            return m_name;
        -: 5657:        }
    #####: 5658:        virtual bool isComplete() const CATCH_OVERRIDE {
    #####: 5659:            return m_runState == CompletedSuccessfully || m_runState == Failed;
        -: 5660:        }
    #####: 5661:        virtual bool isSuccessfullyCompleted() const CATCH_OVERRIDE {
    #####: 5662:            return m_runState == CompletedSuccessfully;
        -: 5663:        }
    #####: 5664:        virtual bool isOpen() const CATCH_OVERRIDE {
    #####: 5665:            return m_runState != NotStarted && !isComplete();
        -: 5666:        }
    #####: 5667:        virtual bool hasChildren() const CATCH_OVERRIDE {
    #####: 5668:            return !m_children.empty();
        -: 5669:        }
        -: 5670:
    #####: 5671:        virtual void addChild( Ptr<ITracker> const& child ) CATCH_OVERRIDE {
    #####: 5672:            m_children.push_back( child );
    #####: 5673:        }
        -: 5674:
    #####: 5675:        virtual ITracker* findChild( std::string const& name ) CATCH_OVERRIDE {
    #####: 5676:            Children::const_iterator it = std::find_if( m_children.begin(), m_children.end(), TrackerHasName( name ) );
    #####: 5677:            return( it != m_children.end() )
    #####: 5678:                ? it->get()
    #####: 5679:                : CATCH_NULL;
        -: 5680:        }
    #####: 5681:        virtual ITracker& parent() CATCH_OVERRIDE {
    #####: 5682:            assert( m_parent ); // Should always be non-null except for root
    #####: 5683:            return *m_parent;
        -: 5684:        }
        -: 5685:
    #####: 5686:        virtual void openChild() CATCH_OVERRIDE {
    #####: 5687:            if( m_runState != ExecutingChildren ) {
    #####: 5688:                m_runState = ExecutingChildren;
    #####: 5689:                if( m_parent )
    #####: 5690:                    m_parent->openChild();
        -: 5691:            }
    #####: 5692:        }
        -: 5693:
    #####: 5694:        virtual bool isSectionTracker() const CATCH_OVERRIDE { return false; }
    #####: 5695:        virtual bool isIndexTracker() const CATCH_OVERRIDE { return false; }
        -: 5696:
    #####: 5697:        void open() {
    #####: 5698:            m_runState = Executing;
    #####: 5699:            moveToThis();
    #####: 5700:            if( m_parent )
    #####: 5701:                m_parent->openChild();
    #####: 5702:        }
        -: 5703:
    #####: 5704:        virtual void close() CATCH_OVERRIDE {
        -: 5705:
        -: 5706:            // Close any still open children (e.g. generators)
    #####: 5707:            while( &m_ctx.currentTracker() != this )
    #####: 5708:                m_ctx.currentTracker().close();
        -: 5709:
    #####: 5710:            switch( m_runState ) {
        -: 5711:                case NotStarted:
        -: 5712:                case CompletedSuccessfully:
        -: 5713:                case Failed:
    #####: 5714:                    throw std::logic_error( "Illogical state" );
        -: 5715:
        -: 5716:                case NeedsAnotherRun:
    #####: 5717:                    break;;
        -: 5718:
        -: 5719:                case Executing:
    #####: 5720:                    m_runState = CompletedSuccessfully;
    #####: 5721:                    break;
        -: 5722:                case ExecutingChildren:
    #####: 5723:                    if( m_children.empty() || m_children.back()->isComplete() )
    #####: 5724:                        m_runState = CompletedSuccessfully;
    #####: 5725:                    break;
        -: 5726:
        -: 5727:                default:
    #####: 5728:                    throw std::logic_error( "Unexpected state" );
        -: 5729:            }
    #####: 5730:            moveToParent();
    #####: 5731:            m_ctx.completeCycle();
    #####: 5732:        }
    #####: 5733:        virtual void fail() CATCH_OVERRIDE {
    #####: 5734:            m_runState = Failed;
    #####: 5735:            if( m_parent )
    #####: 5736:                m_parent->markAsNeedingAnotherRun();
    #####: 5737:            moveToParent();
    #####: 5738:            m_ctx.completeCycle();
    #####: 5739:        }
    #####: 5740:        virtual void markAsNeedingAnotherRun() CATCH_OVERRIDE {
    #####: 5741:            m_runState = NeedsAnotherRun;
    #####: 5742:        }
        -: 5743:    private:
    #####: 5744:        void moveToParent() {
    #####: 5745:            assert( m_parent );
    #####: 5746:            m_ctx.setCurrentTracker( m_parent );
    #####: 5747:        }
    #####: 5748:        void moveToThis() {
    #####: 5749:            m_ctx.setCurrentTracker( this );
    #####: 5750:        }
        -: 5751:    };
        -: 5752:
        -: 5753:    class SectionTracker : public TrackerBase {
        -: 5754:    public:
    #####: 5755:        SectionTracker( std::string const& name, TrackerContext& ctx, ITracker* parent )
    #####: 5756:        :   TrackerBase( name, ctx, parent )
    #####: 5757:        {}
        -: 5758:        virtual ~SectionTracker();
        -: 5759:
    #####: 5760:        virtual bool isSectionTracker() const CATCH_OVERRIDE { return true; }
        -: 5761:
    #####: 5762:        static SectionTracker& acquire( TrackerContext& ctx, std::string const& name ) {
    #####: 5763:            SectionTracker* section = CATCH_NULL;
        -: 5764:
    #####: 5765:            ITracker& currentTracker = ctx.currentTracker();
    #####: 5766:            if( ITracker* childTracker = currentTracker.findChild( name ) ) {
    #####: 5767:                assert( childTracker );
    #####: 5768:                assert( childTracker->isSectionTracker() );
    #####: 5769:                section = static_cast<SectionTracker*>( childTracker );
        -: 5770:            }
        -: 5771:            else {
    #####: 5772:                section = new SectionTracker( name, ctx, &currentTracker );
    #####: 5773:                currentTracker.addChild( section );
        -: 5774:            }
    #####: 5775:            if( !ctx.completedCycle() && !section->isComplete() ) {
        -: 5776:
    #####: 5777:                section->open();
        -: 5778:            }
    #####: 5779:            return *section;
        -: 5780:        }
        -: 5781:    };
        -: 5782:
        -: 5783:    class IndexTracker : public TrackerBase {
        -: 5784:        int m_size;
        -: 5785:        int m_index;
        -: 5786:    public:
        -: 5787:        IndexTracker( std::string const& name, TrackerContext& ctx, ITracker* parent, int size )
        -: 5788:        :   TrackerBase( name, ctx, parent ),
        -: 5789:            m_size( size ),
        -: 5790:            m_index( -1 )
        -: 5791:        {}
        -: 5792:        virtual ~IndexTracker();
        -: 5793:
    #####: 5794:        virtual bool isIndexTracker() const CATCH_OVERRIDE { return true; }
        -: 5795:
        -: 5796:        static IndexTracker& acquire( TrackerContext& ctx, std::string const& name, int size ) {
        -: 5797:            IndexTracker* tracker = CATCH_NULL;
        -: 5798:
        -: 5799:            ITracker& currentTracker = ctx.currentTracker();
        -: 5800:            if( ITracker* childTracker = currentTracker.findChild( name ) ) {
        -: 5801:                assert( childTracker );
        -: 5802:                assert( childTracker->isIndexTracker() );
        -: 5803:                tracker = static_cast<IndexTracker*>( childTracker );
        -: 5804:            }
        -: 5805:            else {
        -: 5806:                tracker = new IndexTracker( name, ctx, &currentTracker, size );
        -: 5807:                currentTracker.addChild( tracker );
        -: 5808:            }
        -: 5809:
        -: 5810:            if( !ctx.completedCycle() && !tracker->isComplete() ) {
        -: 5811:                if( tracker->m_runState != ExecutingChildren && tracker->m_runState != NeedsAnotherRun )
        -: 5812:                    tracker->moveNext();
        -: 5813:                tracker->open();
        -: 5814:            }
        -: 5815:
        -: 5816:            return *tracker;
        -: 5817:        }
        -: 5818:
        -: 5819:        int index() const { return m_index; }
        -: 5820:
        -: 5821:        void moveNext() {
        -: 5822:            m_index++;
        -: 5823:            m_children.clear();
        -: 5824:        }
        -: 5825:
    #####: 5826:        virtual void close() CATCH_OVERRIDE {
    #####: 5827:            TrackerBase::close();
    #####: 5828:            if( m_runState == CompletedSuccessfully && m_index < m_size-1 )
    #####: 5829:                m_runState = Executing;
    #####: 5830:        }
        -: 5831:    };
        -: 5832:
    #####: 5833:    inline ITracker& TrackerContext::startRun() {
    #####: 5834:        m_rootTracker = new SectionTracker( "{root}", *this, CATCH_NULL );
    #####: 5835:        m_currentTracker = CATCH_NULL;
    #####: 5836:        m_runState = Executing;
    #####: 5837:        return *m_rootTracker;
        -: 5838:    }
        -: 5839:
        -: 5840:} // namespace TestCaseTracking
        -: 5841:
        -: 5842:using TestCaseTracking::ITracker;
        -: 5843:using TestCaseTracking::TrackerContext;
        -: 5844:using TestCaseTracking::SectionTracker;
        -: 5845:using TestCaseTracking::IndexTracker;
        -: 5846:
        -: 5847:} // namespace Catch
        -: 5848:
        -: 5849:// #included from: catch_fatal_condition.hpp
        -: 5850:#define TWOBLUECUBES_CATCH_FATAL_CONDITION_H_INCLUDED
        -: 5851:
        -: 5852:namespace Catch {
        -: 5853:
        -: 5854:    // Report the error condition then exit the process
    #####: 5855:    inline void fatal( std::string const& message, int exitCode ) {
    #####: 5856:        IContext& context = Catch::getCurrentContext();
    #####: 5857:        IResultCapture* resultCapture = context.getResultCapture();
    #####: 5858:        resultCapture->handleFatalErrorCondition( message );
        -: 5859:
    #####: 5860:		if( Catch::alwaysTrue() ) // avoids "no return" warnings
    #####: 5861:            exit( exitCode );
    #####: 5862:    }
        -: 5863:
        -: 5864:} // namespace Catch
        -: 5865:
        -: 5866:#if defined ( CATCH_PLATFORM_WINDOWS ) /////////////////////////////////////////
        -: 5867:
        -: 5868:namespace Catch {
        -: 5869:
        -: 5870:    struct FatalConditionHandler {
        -: 5871:		void reset() {}
        -: 5872:	};
        -: 5873:
        -: 5874:} // namespace Catch
        -: 5875:
        -: 5876:#else // Not Windows - assumed to be POSIX compatible //////////////////////////
        -: 5877:
        -: 5878:#include <signal.h>
        -: 5879:
        -: 5880:namespace Catch {
        -: 5881:
        -: 5882:    struct SignalDefs { int id; const char* name; };
        -: 5883:    extern SignalDefs signalDefs[];
        -: 5884:    SignalDefs signalDefs[] = {
        -: 5885:            { SIGINT,  "SIGINT - Terminal interrupt signal" },
        -: 5886:            { SIGILL,  "SIGILL - Illegal instruction signal" },
        -: 5887:            { SIGFPE,  "SIGFPE - Floating point error signal" },
        -: 5888:            { SIGSEGV, "SIGSEGV - Segmentation violation signal" },
        -: 5889:            { SIGTERM, "SIGTERM - Termination request signal" },
        -: 5890:            { SIGABRT, "SIGABRT - Abort (abnormal termination) signal" }
        -: 5891:        };
        -: 5892:
        -: 5893:    struct FatalConditionHandler {
        -: 5894:
    #####: 5895:        static void handleSignal( int sig ) {
    #####: 5896:            for( std::size_t i = 0; i < sizeof(signalDefs)/sizeof(SignalDefs); ++i )
    #####: 5897:                if( sig == signalDefs[i].id )
    #####: 5898:                    fatal( signalDefs[i].name, -sig );
    #####: 5899:            fatal( "<unknown signal>", -sig );
    #####: 5900:        }
        -: 5901:
    #####: 5902:        FatalConditionHandler() : m_isSet( true ) {
    #####: 5903:            for( std::size_t i = 0; i < sizeof(signalDefs)/sizeof(SignalDefs); ++i )
    #####: 5904:                signal( signalDefs[i].id, handleSignal );
    #####: 5905:        }
    #####: 5906:        ~FatalConditionHandler() {
    #####: 5907:            reset();
    #####: 5908:        }
    #####: 5909:        void reset() {
    #####: 5910:            if( m_isSet ) {
    #####: 5911:                for( std::size_t i = 0; i < sizeof(signalDefs)/sizeof(SignalDefs); ++i )
    #####: 5912:                    signal( signalDefs[i].id, SIG_DFL );
    #####: 5913:                m_isSet = false;
        -: 5914:            }
    #####: 5915:        }
        -: 5916:
        -: 5917:        bool m_isSet;
        -: 5918:    };
        -: 5919:
        -: 5920:} // namespace Catch
        -: 5921:
        -: 5922:#endif // not Windows
        -: 5923:
        -: 5924:#include <set>
        -: 5925:#include <string>
        -: 5926:
        -: 5927:namespace Catch {
        -: 5928:
        -: 5929:    class StreamRedirect {
        -: 5930:
        -: 5931:    public:
    #####: 5932:        StreamRedirect( std::ostream& stream, std::string& targetString )
        -: 5933:        :   m_stream( stream ),
    #####: 5934:            m_prevBuf( stream.rdbuf() ),
    #####: 5935:            m_targetString( targetString )
        -: 5936:        {
    #####: 5937:            stream.rdbuf( m_oss.rdbuf() );
    #####: 5938:        }
        -: 5939:
    #####: 5940:        ~StreamRedirect() {
    #####: 5941:            m_targetString += m_oss.str();
    #####: 5942:            m_stream.rdbuf( m_prevBuf );
    #####: 5943:        }
        -: 5944:
        -: 5945:    private:
        -: 5946:        std::ostream& m_stream;
        -: 5947:        std::streambuf* m_prevBuf;
        -: 5948:        std::ostringstream m_oss;
        -: 5949:        std::string& m_targetString;
        -: 5950:    };
        -: 5951:
        -: 5952:    ///////////////////////////////////////////////////////////////////////////
        -: 5953:
        -: 5954:    class RunContext : public IResultCapture, public IRunner {
        -: 5955:
        -: 5956:        RunContext( RunContext const& );
        -: 5957:        void operator =( RunContext const& );
        -: 5958:
        -: 5959:    public:
        -: 5960:
        1: 5961:        explicit RunContext( Ptr<IConfig const> const& _config, Ptr<IStreamingReporter> const& reporter )
        2: 5962:        :   m_runInfo( _config->name() ),
        1: 5963:            m_context( getCurrentMutableContext() ),
        -: 5964:            m_activeTestCase( CATCH_NULL ),
        -: 5965:            m_config( _config ),
        3: 5966:            m_reporter( reporter )
        -: 5967:        {
        1: 5968:            m_context.setRunner( this );
        1: 5969:            m_context.setConfig( m_config );
        1: 5970:            m_context.setResultCapture( this );
        1: 5971:            m_reporter->testRunStarting( m_runInfo );
        1: 5972:        }
        -: 5973:
        2: 5974:        virtual ~RunContext() {
        1: 5975:            m_reporter->testRunEnded( TestRunStats( m_runInfo, m_totals, aborting() ) );
        1: 5976:        }
        -: 5977:
        1: 5978:        void testGroupStarting( std::string const& testSpec, std::size_t groupIndex, std::size_t groupsCount ) {
        1: 5979:            m_reporter->testGroupStarting( GroupInfo( testSpec, groupIndex, groupsCount ) );
        1: 5980:        }
        1: 5981:        void testGroupEnded( std::string const& testSpec, Totals const& totals, std::size_t groupIndex, std::size_t groupsCount ) {
        1: 5982:            m_reporter->testGroupEnded( TestGroupStats( GroupInfo( testSpec, groupIndex, groupsCount ), totals, aborting() ) );
        1: 5983:        }
        -: 5984:
    #####: 5985:        Totals runTest( TestCase const& testCase ) {
    #####: 5986:            Totals prevTotals = m_totals;
        -: 5987:
    #####: 5988:            std::string redirectedCout;
    #####: 5989:            std::string redirectedCerr;
        -: 5990:
    #####: 5991:            TestCaseInfo testInfo = testCase.getTestCaseInfo();
        -: 5992:
    #####: 5993:            m_reporter->testCaseStarting( testInfo );
        -: 5994:
    #####: 5995:            m_activeTestCase = &testCase;
        -: 5996:
    #####: 5997:            do {
    #####: 5998:                m_trackerContext.startRun();
    #####: 5999:                do {
    #####: 6000:                    m_trackerContext.startCycle();
    #####: 6001:                    m_testCaseTracker = &SectionTracker::acquire( m_trackerContext, testInfo.name );
    #####: 6002:                    runCurrentTest( redirectedCout, redirectedCerr );
        -: 6003:                }
    #####: 6004:                while( !m_testCaseTracker->isSuccessfullyCompleted() && !aborting() );
        -: 6005:            }
        -: 6006:            // !TBD: deprecated - this will be replaced by indexed trackers
    #####: 6007:            while( getCurrentContext().advanceGeneratorsForCurrentTest() && !aborting() );
        -: 6008:
    #####: 6009:            Totals deltaTotals = m_totals.delta( prevTotals );
    #####: 6010:            if( testInfo.expectedToFail() && deltaTotals.testCases.passed > 0 ) {
    #####: 6011:                deltaTotals.assertions.failed++;
    #####: 6012:                deltaTotals.testCases.passed--;
    #####: 6013:                deltaTotals.testCases.failed++;
        -: 6014:            }
    #####: 6015:            m_totals.testCases += deltaTotals.testCases;
    #####: 6016:            m_reporter->testCaseEnded( TestCaseStats(   testInfo,
        -: 6017:                                                        deltaTotals,
        -: 6018:                                                        redirectedCout,
        -: 6019:                                                        redirectedCerr,
    #####: 6020:                                                        aborting() ) );
        -: 6021:
    #####: 6022:            m_activeTestCase = CATCH_NULL;
    #####: 6023:            m_testCaseTracker = CATCH_NULL;
        -: 6024:
    #####: 6025:            return deltaTotals;
        -: 6026:        }
        -: 6027:
        -: 6028:        Ptr<IConfig const> config() const {
        -: 6029:            return m_config;
        -: 6030:        }
        -: 6031:
        -: 6032:    private: // IResultCapture
        -: 6033:
    #####: 6034:        virtual void assertionEnded( AssertionResult const& result ) {
    #####: 6035:            if( result.getResultType() == ResultWas::Ok ) {
    #####: 6036:                m_totals.assertions.passed++;
        -: 6037:            }
    #####: 6038:            else if( !result.isOk() ) {
    #####: 6039:                m_totals.assertions.failed++;
        -: 6040:            }
        -: 6041:
    #####: 6042:            if( m_reporter->assertionEnded( AssertionStats( result, m_messages, m_totals ) ) )
    #####: 6043:                m_messages.clear();
        -: 6044:
        -: 6045:            // Reset working state
    #####: 6046:            m_lastAssertionInfo = AssertionInfo( "", m_lastAssertionInfo.lineInfo, "{Unknown expression after the reported line}" , m_lastAssertionInfo.resultDisposition );
    #####: 6047:            m_lastResult = result;
    #####: 6048:        }
        -: 6049:
    #####: 6050:        virtual bool sectionStarted (
        -: 6051:            SectionInfo const& sectionInfo,
        -: 6052:            Counts& assertions
        -: 6053:        )
        -: 6054:        {
    #####: 6055:            std::ostringstream oss;
    #####: 6056:            oss << sectionInfo.name << "@" << sectionInfo.lineInfo;
        -: 6057:
    #####: 6058:            ITracker& sectionTracker = SectionTracker::acquire( m_trackerContext, oss.str() );
    #####: 6059:            if( !sectionTracker.isOpen() )
    #####: 6060:                return false;
    #####: 6061:            m_activeSections.push_back( &sectionTracker );
        -: 6062:
    #####: 6063:            m_lastAssertionInfo.lineInfo = sectionInfo.lineInfo;
        -: 6064:
    #####: 6065:            m_reporter->sectionStarting( sectionInfo );
        -: 6066:
    #####: 6067:            assertions = m_totals.assertions;
        -: 6068:
    #####: 6069:            return true;
        -: 6070:        }
    #####: 6071:        bool testForMissingAssertions( Counts& assertions ) {
    #####: 6072:            if( assertions.total() != 0 )
    #####: 6073:                return false;
    #####: 6074:            if( !m_config->warnAboutMissingAssertions() )
    #####: 6075:                return false;
    #####: 6076:            if( m_trackerContext.currentTracker().hasChildren() )
    #####: 6077:                return false;
    #####: 6078:            m_totals.assertions.failed++;
    #####: 6079:            assertions.failed++;
    #####: 6080:            return true;
        -: 6081:        }
        -: 6082:
    #####: 6083:        virtual void sectionEnded( SectionEndInfo const& endInfo ) {
    #####: 6084:            Counts assertions = m_totals.assertions - endInfo.prevAssertions;
    #####: 6085:            bool missingAssertions = testForMissingAssertions( assertions );
        -: 6086:
    #####: 6087:            if( !m_activeSections.empty() ) {
    #####: 6088:                m_activeSections.back()->close();
    #####: 6089:                m_activeSections.pop_back();
        -: 6090:            }
        -: 6091:
    #####: 6092:            m_reporter->sectionEnded( SectionStats( endInfo.sectionInfo, assertions, endInfo.durationInSeconds, missingAssertions ) );
    #####: 6093:            m_messages.clear();
    #####: 6094:        }
        -: 6095:
    #####: 6096:        virtual void sectionEndedEarly( SectionEndInfo const& endInfo ) {
    #####: 6097:            if( m_unfinishedSections.empty() )
    #####: 6098:                m_activeSections.back()->fail();
        -: 6099:            else
    #####: 6100:                m_activeSections.back()->close();
    #####: 6101:            m_activeSections.pop_back();
        -: 6102:
    #####: 6103:            m_unfinishedSections.push_back( endInfo );
    #####: 6104:        }
        -: 6105:
    #####: 6106:        virtual void pushScopedMessage( MessageInfo const& message ) {
    #####: 6107:            m_messages.push_back( message );
    #####: 6108:        }
        -: 6109:
    #####: 6110:        virtual void popScopedMessage( MessageInfo const& message ) {
    #####: 6111:            m_messages.erase( std::remove( m_messages.begin(), m_messages.end(), message ), m_messages.end() );
    #####: 6112:        }
        -: 6113:
    #####: 6114:        virtual std::string getCurrentTestName() const {
    #####: 6115:            return m_activeTestCase
    #####: 6116:                ? m_activeTestCase->getTestCaseInfo().name
    #####: 6117:                : "";
        -: 6118:        }
        -: 6119:
    #####: 6120:        virtual const AssertionResult* getLastResult() const {
    #####: 6121:            return &m_lastResult;
        -: 6122:        }
        -: 6123:
    #####: 6124:        virtual void handleFatalErrorCondition( std::string const& message ) {
    #####: 6125:            ResultBuilder resultBuilder = makeUnexpectedResultBuilder();
    #####: 6126:            resultBuilder.setResultType( ResultWas::FatalErrorCondition );
    #####: 6127:            resultBuilder << message;
    #####: 6128:            resultBuilder.captureExpression();
        -: 6129:
    #####: 6130:            handleUnfinishedSections();
        -: 6131:
        -: 6132:            // Recreate section for test case (as we will lose the one that was in scope)
    #####: 6133:            TestCaseInfo const& testCaseInfo = m_activeTestCase->getTestCaseInfo();
    #####: 6134:            SectionInfo testCaseSection( testCaseInfo.lineInfo, testCaseInfo.name, testCaseInfo.description );
        -: 6135:
    #####: 6136:            Counts assertions;
    #####: 6137:            assertions.failed = 1;
    #####: 6138:            SectionStats testCaseSectionStats( testCaseSection, assertions, 0, false );
    #####: 6139:            m_reporter->sectionEnded( testCaseSectionStats );
        -: 6140:
    #####: 6141:            TestCaseInfo testInfo = m_activeTestCase->getTestCaseInfo();
        -: 6142:
    #####: 6143:            Totals deltaTotals;
    #####: 6144:            deltaTotals.testCases.failed = 1;
    #####: 6145:            m_reporter->testCaseEnded( TestCaseStats(   testInfo,
        -: 6146:                                                        deltaTotals,
        -: 6147:                                                        "",
        -: 6148:                                                        "",
    #####: 6149:                                                        false ) );
    #####: 6150:            m_totals.testCases.failed++;
    #####: 6151:            testGroupEnded( "", m_totals, 1, 1 );
    #####: 6152:            m_reporter->testRunEnded( TestRunStats( m_runInfo, m_totals, false ) );
    #####: 6153:        }
        -: 6154:
        -: 6155:    public:
        -: 6156:        // !TBD We need to do this another way!
        2: 6157:        bool aborting() const {
        2: 6158:            return m_totals.assertions.failed == static_cast<std::size_t>( m_config->abortAfter() );
        -: 6159:        }
        -: 6160:
        -: 6161:    private:
        -: 6162:
    #####: 6163:        void runCurrentTest( std::string& redirectedCout, std::string& redirectedCerr ) {
    #####: 6164:            TestCaseInfo const& testCaseInfo = m_activeTestCase->getTestCaseInfo();
    #####: 6165:            SectionInfo testCaseSection( testCaseInfo.lineInfo, testCaseInfo.name, testCaseInfo.description );
    #####: 6166:            m_reporter->sectionStarting( testCaseSection );
    #####: 6167:            Counts prevAssertions = m_totals.assertions;
    #####: 6168:            double duration = 0;
        -: 6169:            try {
    #####: 6170:                m_lastAssertionInfo = AssertionInfo( "TEST_CASE", testCaseInfo.lineInfo, "", ResultDisposition::Normal );
        -: 6171:
    #####: 6172:                seedRng( *m_config );
        -: 6173:
    #####: 6174:                Timer timer;
    #####: 6175:                timer.start();
    #####: 6176:                if( m_reporter->getPreferences().shouldRedirectStdOut ) {
    #####: 6177:                    StreamRedirect coutRedir( Catch::cout(), redirectedCout );
    #####: 6178:                    StreamRedirect cerrRedir( Catch::cerr(), redirectedCerr );
    #####: 6179:                    invokeActiveTestCase();
        -: 6180:                }
        -: 6181:                else {
    #####: 6182:                    invokeActiveTestCase();
        -: 6183:                }
    #####: 6184:                duration = timer.getElapsedSeconds();
        -: 6185:            }
    =====: 6186:            catch( TestFailureException& ) {
        -: 6187:                // This just means the test was aborted due to failure
        -: 6188:            }
    =====: 6189:            catch(...) {
    =====: 6190:                makeUnexpectedResultBuilder().useActiveException();
        -: 6191:            }
    #####: 6192:            m_testCaseTracker->close();
    #####: 6193:            handleUnfinishedSections();
    #####: 6194:            m_messages.clear();
        -: 6195:
    #####: 6196:            Counts assertions = m_totals.assertions - prevAssertions;
    #####: 6197:            bool missingAssertions = testForMissingAssertions( assertions );
        -: 6198:
    #####: 6199:            if( testCaseInfo.okToFail() ) {
    #####: 6200:                std::swap( assertions.failedButOk, assertions.failed );
    #####: 6201:                m_totals.assertions.failed -= assertions.failedButOk;
    #####: 6202:                m_totals.assertions.failedButOk += assertions.failedButOk;
        -: 6203:            }
        -: 6204:
    #####: 6205:            SectionStats testCaseSectionStats( testCaseSection, assertions, duration, missingAssertions );
    #####: 6206:            m_reporter->sectionEnded( testCaseSectionStats );
    #####: 6207:        }
        -: 6208:
    #####: 6209:        void invokeActiveTestCase() {
    #####: 6210:            FatalConditionHandler fatalConditionHandler; // Handle signals
    #####: 6211:            m_activeTestCase->invoke();
    #####: 6212:            fatalConditionHandler.reset();
    #####: 6213:        }
        -: 6214:
        -: 6215:    private:
        -: 6216:
    #####: 6217:        ResultBuilder makeUnexpectedResultBuilder() const {
        -: 6218:            return ResultBuilder(   m_lastAssertionInfo.macroName.c_str(),
        -: 6219:                                    m_lastAssertionInfo.lineInfo,
        -: 6220:                                    m_lastAssertionInfo.capturedExpression.c_str(),
    #####: 6221:                                    m_lastAssertionInfo.resultDisposition );
        -: 6222:        }
        -: 6223:
    #####: 6224:        void handleUnfinishedSections() {
        -: 6225:            // If sections ended prematurely due to an exception we stored their
        -: 6226:            // infos here so we can tear them down outside the unwind process.
    #####: 6227:            for( std::vector<SectionEndInfo>::const_reverse_iterator it = m_unfinishedSections.rbegin(),
    #####: 6228:                        itEnd = m_unfinishedSections.rend();
        -: 6229:                    it != itEnd;
        -: 6230:                    ++it )
    #####: 6231:                sectionEnded( *it );
    #####: 6232:            m_unfinishedSections.clear();
    #####: 6233:        }
        -: 6234:
        -: 6235:        TestRunInfo m_runInfo;
        -: 6236:        IMutableContext& m_context;
        -: 6237:        TestCase const* m_activeTestCase;
        -: 6238:        ITracker* m_testCaseTracker;
        -: 6239:        ITracker* m_currentSectionTracker;
        -: 6240:        AssertionResult m_lastResult;
        -: 6241:
        -: 6242:        Ptr<IConfig const> m_config;
        -: 6243:        Totals m_totals;
        -: 6244:        Ptr<IStreamingReporter> m_reporter;
        -: 6245:        std::vector<MessageInfo> m_messages;
        -: 6246:        AssertionInfo m_lastAssertionInfo;
        -: 6247:        std::vector<SectionEndInfo> m_unfinishedSections;
        -: 6248:        std::vector<ITracker*> m_activeSections;
        -: 6249:        TrackerContext m_trackerContext;
        -: 6250:    };
        -: 6251:
    #####: 6252:    IResultCapture& getResultCapture() {
    #####: 6253:        if( IResultCapture* capture = getCurrentContext().getResultCapture() )
    #####: 6254:            return *capture;
        -: 6255:        else
    #####: 6256:            throw std::logic_error( "No result capture instance" );
        -: 6257:    }
        -: 6258:
        -: 6259:} // end namespace Catch
        -: 6260:
        -: 6261:// #included from: internal/catch_version.h
        -: 6262:#define TWOBLUECUBES_CATCH_VERSION_H_INCLUDED
        -: 6263:
        -: 6264:namespace Catch {
        -: 6265:
        -: 6266:    // Versioning information
        1: 6267:    struct Version {
        -: 6268:        Version(    unsigned int _majorVersion,
        -: 6269:                    unsigned int _minorVersion,
        -: 6270:                    unsigned int _patchNumber,
        -: 6271:                    std::string const& _branchName,
        -: 6272:                    unsigned int _buildNumber );
        -: 6273:
        -: 6274:        unsigned int const majorVersion;
        -: 6275:        unsigned int const minorVersion;
        -: 6276:        unsigned int const patchNumber;
        -: 6277:
        -: 6278:        // buildNumber is only used if branchName is not null
        -: 6279:        std::string const branchName;
        -: 6280:        unsigned int const buildNumber;
        -: 6281:
        -: 6282:        friend std::ostream& operator << ( std::ostream& os, Version const& version );
        -: 6283:
        -: 6284:    private:
        -: 6285:        void operator=( Version const& );
        -: 6286:    };
        -: 6287:
        -: 6288:    extern Version libraryVersion;
        -: 6289:}
        -: 6290:
        -: 6291:#include <fstream>
        -: 6292:#include <stdlib.h>
        -: 6293:#include <limits>
        -: 6294:
        -: 6295:namespace Catch {
        -: 6296:
        1: 6297:    Ptr<IStreamingReporter> createReporter( std::string const& reporterName, Ptr<Config> const& config ) {
        1: 6298:        Ptr<IStreamingReporter> reporter = getRegistryHub().getReporterRegistry().create( reporterName, config.get() );
        1: 6299:        if( !reporter ) {
    #####: 6300:            std::ostringstream oss;
    #####: 6301:            oss << "No reporter registered with name: '" << reporterName << "'";
    #####: 6302:            throw std::domain_error( oss.str() );
        -: 6303:        }
        1: 6304:        return reporter;
        -: 6305:    }
        -: 6306:
        1: 6307:    Ptr<IStreamingReporter> makeReporter( Ptr<Config> const& config ) {
        2: 6308:        std::vector<std::string> reporters = config->getReporterNames();
        1: 6309:        if( reporters.empty() )
        1: 6310:            reporters.push_back( "console" );
        -: 6311:
        1: 6312:        Ptr<IStreamingReporter> reporter;
        2: 6313:        for( std::vector<std::string>::const_iterator it = reporters.begin(), itEnd = reporters.end();
        -: 6314:                it != itEnd;
        -: 6315:                ++it )
        1: 6316:            reporter = addReporter( reporter, createReporter( *it, config ) );
        2: 6317:        return reporter;
        -: 6318:    }
        1: 6319:    Ptr<IStreamingReporter> addListeners( Ptr<IConfig const> const& config, Ptr<IStreamingReporter> reporters ) {
        2: 6320:        IReporterRegistry::Listeners listeners = getRegistryHub().getReporterRegistry().getListeners();
        1: 6321:        for( IReporterRegistry::Listeners::const_iterator it = listeners.begin(), itEnd = listeners.end();
        -: 6322:                it != itEnd;
        -: 6323:                ++it )
    #####: 6324:            reporters = addReporter(reporters, (*it)->create( ReporterConfig( config ) ) );
        2: 6325:        return reporters;
        -: 6326:    }
        -: 6327:
        1: 6328:    Totals runTests( Ptr<Config> const& config ) {
        -: 6329:
        2: 6330:        Ptr<IConfig const> iconfig = config.get();
        -: 6331:
        2: 6332:        Ptr<IStreamingReporter> reporter = makeReporter( config );
        1: 6333:        reporter = addListeners( iconfig, reporter );
        -: 6334:
        2: 6335:        RunContext context( iconfig, reporter );
        -: 6336:
        1: 6337:        Totals totals;
        -: 6338:
        1: 6339:        context.testGroupStarting( config->name(), 1, 1 );
        -: 6340:
        2: 6341:        TestSpec testSpec = config->testSpec();
        1: 6342:        if( !testSpec.hasFilters() )
        1: 6343:            testSpec = TestSpecParser( ITagAliasRegistry::get() ).parse( "~[.]" ).testSpec(); // All not hidden tests
        -: 6344:
        1: 6345:        std::vector<TestCase> const& allTestCases = getAllTestCasesSorted( *iconfig );
        1: 6346:        for( std::vector<TestCase>::const_iterator it = allTestCases.begin(), itEnd = allTestCases.end();
        -: 6347:                it != itEnd;
        -: 6348:                ++it ) {
    #####: 6349:            if( !context.aborting() && matchTest( *it, testSpec, *iconfig ) )
    #####: 6350:                totals += context.runTest( *it );
        -: 6351:            else
    #####: 6352:                reporter->skipTest( *it );
        -: 6353:        }
        -: 6354:
        1: 6355:        context.testGroupEnded( iconfig->name(), totals, 1, 1 );
        2: 6356:        return totals;
        -: 6357:    }
        -: 6358:
    #####: 6359:    void applyFilenamesAsTags( IConfig const& config ) {
    #####: 6360:        std::vector<TestCase> const& tests = getAllTestCasesSorted( config );
    #####: 6361:        for(std::size_t i = 0; i < tests.size(); ++i ) {
    #####: 6362:            TestCase& test = const_cast<TestCase&>( tests[i] );
    #####: 6363:            std::set<std::string> tags = test.tags;
        -: 6364:
    #####: 6365:            std::string filename = test.lineInfo.file;
    #####: 6366:            std::string::size_type lastSlash = filename.find_last_of( "\\/" );
    #####: 6367:            if( lastSlash != std::string::npos )
    #####: 6368:                filename = filename.substr( lastSlash+1 );
        -: 6369:
    #####: 6370:            std::string::size_type lastDot = filename.find_last_of( "." );
    #####: 6371:            if( lastDot != std::string::npos )
    #####: 6372:                filename = filename.substr( 0, lastDot );
        -: 6373:
    #####: 6374:            tags.insert( "#" + filename );
    #####: 6375:            setTags( test, tags );
        -: 6376:        }
    #####: 6377:    }
        -: 6378:
        -: 6379:    class Session : NonCopyable {
        -: 6380:        static bool alreadyInstantiated;
        -: 6381:
        -: 6382:    public:
        -: 6383:
        -: 6384:        struct OnUnusedOptions { enum DoWhat { Ignore, Fail }; };
        -: 6385:
        1: 6386:        Session()
        1: 6387:        : m_cli( makeCommandLineParser() ) {
        1: 6388:            if( alreadyInstantiated ) {
    #####: 6389:                std::string msg = "Only one instance of Catch::Session can ever be used";
    #####: 6390:                Catch::cerr() << msg << std::endl;
    #####: 6391:                throw std::logic_error( msg );
        -: 6392:            }
        1: 6393:            alreadyInstantiated = true;
        1: 6394:        }
        2: 6395:        ~Session() {
        1: 6396:            Catch::cleanUp();
        1: 6397:        }
        -: 6398:
    #####: 6399:        void showHelp( std::string const& processName ) {
    #####: 6400:            Catch::cout() << "\nCatch v" << libraryVersion << "\n";
        -: 6401:
    #####: 6402:            m_cli.usage( Catch::cout(), processName );
    #####: 6403:            Catch::cout() << "For more detail usage please see the project docs\n" << std::endl;
    #####: 6404:        }
        -: 6405:
        1: 6406:        int applyCommandLine( int argc, char const* const* const argv, OnUnusedOptions::DoWhat unusedOptionBehaviour = OnUnusedOptions::Fail ) {
        -: 6407:            try {
        1: 6408:                m_cli.setThrowOnUnrecognisedTokens( unusedOptionBehaviour == OnUnusedOptions::Fail );
        1: 6409:                m_unusedTokens = m_cli.parseInto( Clara::argsToVector( argc, argv ), m_configData );
        1: 6410:                if( m_configData.showHelp )
    #####: 6411:                    showHelp( m_configData.processName );
        1: 6412:                m_config.reset();
        -: 6413:            }
    =====: 6414:            catch( std::exception& ex ) {
        -: 6415:                {
    =====: 6416:                    Colour colourGuard( Colour::Red );
    =====: 6417:                    Catch::cerr()
    =====: 6418:                        << "\nError(s) in input:\n"
    =====: 6419:                        << Text( ex.what(), TextAttributes().setIndent(2) )
    =====: 6420:                        << "\n\n";
        -: 6421:                }
    =====: 6422:                m_cli.usage( Catch::cout(), m_configData.processName );
    =====: 6423:                return (std::numeric_limits<int>::max)();
        -: 6424:            }
        1: 6425:            return 0;
        -: 6426:        }
        -: 6427:
        -: 6428:        void useConfigData( ConfigData const& _configData ) {
        -: 6429:            m_configData = _configData;
        -: 6430:            m_config.reset();
        -: 6431:        }
        -: 6432:
        1: 6433:        int run( int argc, char const* const* const argv ) {
        -: 6434:
        1: 6435:            int returnCode = applyCommandLine( argc, argv );
        1: 6436:            if( returnCode == 0 )
        1: 6437:                returnCode = run();
        1: 6438:            return returnCode;
        -: 6439:        }
        -: 6440:
        1: 6441:        int run() {
        1: 6442:            if( m_configData.showHelp )
    #####: 6443:                return 0;
        -: 6444:
        -: 6445:            try
        -: 6446:            {
        1: 6447:                config(); // Force config to be constructed
        -: 6448:
        1: 6449:                seedRng( *m_config );
        -: 6450:
        1: 6451:                if( m_configData.filenamesAsTags )
    #####: 6452:                    applyFilenamesAsTags( *m_config );
        -: 6453:
        -: 6454:                // Handle list request
        2: 6455:                if( Option<std::size_t> listed = list( config() ) )
    #####: 6456:                    return static_cast<int>( *listed );
        -: 6457:
        1: 6458:                return static_cast<int>( runTests( m_config ).assertions.failed );
        -: 6459:            }
    =====: 6460:            catch( std::exception& ex ) {
    =====: 6461:                Catch::cerr() << ex.what() << std::endl;
    =====: 6462:                return (std::numeric_limits<int>::max)();
        -: 6463:            }
        -: 6464:        }
        -: 6465:
        -: 6466:        Clara::CommandLine<ConfigData> const& cli() const {
        -: 6467:            return m_cli;
        -: 6468:        }
        -: 6469:        std::vector<Clara::Parser::Token> const& unusedTokens() const {
        -: 6470:            return m_unusedTokens;
        -: 6471:        }
        -: 6472:        ConfigData& configData() {
        -: 6473:            return m_configData;
        -: 6474:        }
        2: 6475:        Config& config() {
        2: 6476:            if( !m_config )
        1: 6477:                m_config = new Config( m_configData );
        2: 6478:            return *m_config;
        -: 6479:        }
        -: 6480:    private:
        -: 6481:        Clara::CommandLine<ConfigData> m_cli;
        -: 6482:        std::vector<Clara::Parser::Token> m_unusedTokens;
        -: 6483:        ConfigData m_configData;
        -: 6484:        Ptr<Config> m_config;
        -: 6485:    };
        -: 6486:
        -: 6487:    bool Session::alreadyInstantiated = false;
        -: 6488:
        -: 6489:} // end namespace Catch
        -: 6490:
        -: 6491:// #included from: catch_registry_hub.hpp
        -: 6492:#define TWOBLUECUBES_CATCH_REGISTRY_HUB_HPP_INCLUDED
        -: 6493:
        -: 6494:// #included from: catch_test_case_registry_impl.hpp
        -: 6495:#define TWOBLUECUBES_CATCH_TEST_CASE_REGISTRY_IMPL_HPP_INCLUDED
        -: 6496:
        -: 6497:#include <vector>
        -: 6498:#include <set>
        -: 6499:#include <sstream>
        -: 6500:#include <iostream>
        -: 6501:#include <algorithm>
        -: 6502:
        -: 6503:namespace Catch {
        -: 6504:
        -: 6505:    struct RandomNumberGenerator {
        -: 6506:        typedef std::ptrdiff_t result_type;
        -: 6507:
        -: 6508:        result_type operator()( result_type n ) const { return std::rand() % n; }
        -: 6509:
        -: 6510:#ifdef CATCH_CONFIG_CPP11_SHUFFLE
        -: 6511:        static constexpr result_type min() { return 0; }
    #####: 6512:        static constexpr result_type max() { return 1000000; }
    #####: 6513:        result_type operator()() const { return std::rand() % max(); }
        -: 6514:#endif
        -: 6515:        template<typename V>
    #####: 6516:        static void shuffle( V& vector ) {
        -: 6517:            RandomNumberGenerator rng;
        -: 6518:#ifdef CATCH_CONFIG_CPP11_SHUFFLE
    #####: 6519:            std::shuffle( vector.begin(), vector.end(), rng );
        -: 6520:#else
        -: 6521:            std::random_shuffle( vector.begin(), vector.end(), rng );
        -: 6522:#endif
    #####: 6523:        }
        -: 6524:    };
        -: 6525:
        1: 6526:    inline std::vector<TestCase> sortTests( IConfig const& config, std::vector<TestCase> const& unsortedTestCases ) {
        -: 6527:
        1: 6528:        std::vector<TestCase> sorted = unsortedTestCases;
        -: 6529:
        1: 6530:        switch( config.runOrder() ) {
        -: 6531:            case RunTests::InLexicographicalOrder:
    #####: 6532:                std::sort( sorted.begin(), sorted.end() );
    #####: 6533:                break;
        -: 6534:            case RunTests::InRandomOrder:
        -: 6535:                {
    #####: 6536:                    seedRng( config );
    #####: 6537:                    RandomNumberGenerator::shuffle( sorted );
        -: 6538:                }
    #####: 6539:                break;
        -: 6540:            case RunTests::InDeclarationOrder:
        -: 6541:                // already in declaration order
        1: 6542:                break;
        -: 6543:        }
        1: 6544:        return sorted;
        -: 6545:    }
    #####: 6546:    bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config ) {
    #####: 6547:        return testSpec.matches( testCase ) && ( config.allowThrows() || !testCase.throws() );
        -: 6548:    }
        -: 6549:
        1: 6550:    void enforceNoDuplicateTestCases( std::vector<TestCase> const& functions ) {
        2: 6551:        std::set<TestCase> seenFunctions;
        1: 6552:        for( std::vector<TestCase>::const_iterator it = functions.begin(), itEnd = functions.end();
        -: 6553:            it != itEnd;
        -: 6554:            ++it ) {
    #####: 6555:            std::pair<std::set<TestCase>::const_iterator, bool> prev = seenFunctions.insert( *it );
    #####: 6556:            if( !prev.second ) {
    #####: 6557:                std::ostringstream ss;
        -: 6558:
    #####: 6559:                ss  << Colour( Colour::Red )
    #####: 6560:                    << "error: TEST_CASE( \"" << it->name << "\" ) already defined.\n"
    #####: 6561:                    << "\tFirst seen at " << prev.first->getTestCaseInfo().lineInfo << "\n"
    #####: 6562:                    << "\tRedefined at " << it->getTestCaseInfo().lineInfo << std::endl;
        -: 6563:
    #####: 6564:                throw std::runtime_error(ss.str());
        -: 6565:            }
        -: 6566:        }
        1: 6567:    }
        -: 6568:
    #####: 6569:    std::vector<TestCase> filterTests( std::vector<TestCase> const& testCases, TestSpec const& testSpec, IConfig const& config ) {
    #####: 6570:        std::vector<TestCase> filtered;
    #####: 6571:        filtered.reserve( testCases.size() );
    #####: 6572:        for( std::vector<TestCase>::const_iterator it = testCases.begin(), itEnd = testCases.end();
        -: 6573:                it != itEnd;
        -: 6574:                ++it )
    #####: 6575:            if( matchTest( *it, testSpec, config ) )
    #####: 6576:                filtered.push_back( *it );
    #####: 6577:        return filtered;
        -: 6578:    }
        1: 6579:    std::vector<TestCase> const& getAllTestCasesSorted( IConfig const& config ) {
        1: 6580:        return getRegistryHub().getTestCaseRegistry().getAllTestsSorted( config );
        -: 6581:    }
        -: 6582:
        -: 6583:    class TestRegistry : public ITestCaseRegistry {
        -: 6584:    public:
        1: 6585:        TestRegistry()
        -: 6586:        :   m_currentSortOrder( RunTests::InDeclarationOrder ),
        1: 6587:            m_unnamedCount( 0 )
        1: 6588:        {}
        -: 6589:        virtual ~TestRegistry();
        -: 6590:
    #####: 6591:        virtual void registerTest( TestCase const& testCase ) {
    #####: 6592:            std::string name = testCase.getTestCaseInfo().name;
    #####: 6593:            if( name == "" ) {
    #####: 6594:                std::ostringstream oss;
    #####: 6595:                oss << "Anonymous test case " << ++m_unnamedCount;
    #####: 6596:                return registerTest( testCase.withName( oss.str() ) );
        -: 6597:            }
    #####: 6598:            m_functions.push_back( testCase );
        -: 6599:        }
        -: 6600:
    #####: 6601:        virtual std::vector<TestCase> const& getAllTests() const {
    #####: 6602:            return m_functions;
        -: 6603:        }
        1: 6604:        virtual std::vector<TestCase> const& getAllTestsSorted( IConfig const& config ) const {
        1: 6605:            if( m_sortedFunctions.empty() )
        1: 6606:                enforceNoDuplicateTestCases( m_functions );
        -: 6607:
        1: 6608:            if(  m_currentSortOrder != config.runOrder() || m_sortedFunctions.empty() ) {
        1: 6609:                m_sortedFunctions = sortTests( config, m_functions );
        1: 6610:                m_currentSortOrder = config.runOrder();
        -: 6611:            }
        1: 6612:            return m_sortedFunctions;
        -: 6613:        }
        -: 6614:
        -: 6615:    private:
        -: 6616:        std::vector<TestCase> m_functions;
        -: 6617:        mutable RunTests::InWhatOrder m_currentSortOrder;
        -: 6618:        mutable std::vector<TestCase> m_sortedFunctions;
        -: 6619:        size_t m_unnamedCount;
        -: 6620:        std::ios_base::Init m_ostreamInit; // Forces cout/ cerr to be initialised
        -: 6621:    };
        -: 6622:
        -: 6623:    ///////////////////////////////////////////////////////////////////////////
        -: 6624:
        -: 6625:    class FreeFunctionTestCase : public SharedImpl<ITestCase> {
        -: 6626:    public:
        -: 6627:
    #####: 6628:        FreeFunctionTestCase( TestFunction fun ) : m_fun( fun ) {}
        -: 6629:
    #####: 6630:        virtual void invoke() const {
    #####: 6631:            m_fun();
    #####: 6632:        }
        -: 6633:
        -: 6634:    private:
        -: 6635:        virtual ~FreeFunctionTestCase();
        -: 6636:
        -: 6637:        TestFunction m_fun;
        -: 6638:    };
        -: 6639:
    #####: 6640:    inline std::string extractClassName( std::string const& classOrQualifiedMethodName ) {
    #####: 6641:        std::string className = classOrQualifiedMethodName;
    #####: 6642:        if( startsWith( className, "&" ) )
        -: 6643:        {
    #####: 6644:            std::size_t lastColons = className.rfind( "::" );
    #####: 6645:            std::size_t penultimateColons = className.rfind( "::", lastColons-1 );
    #####: 6646:            if( penultimateColons == std::string::npos )
    #####: 6647:                penultimateColons = 1;
    #####: 6648:            className = className.substr( penultimateColons, lastColons-penultimateColons );
        -: 6649:        }
    #####: 6650:        return className;
        -: 6651:    }
        -: 6652:
    #####: 6653:    void registerTestCase
        -: 6654:        (   ITestCase* testCase,
        -: 6655:            char const* classOrQualifiedMethodName,
        -: 6656:            NameAndDesc const& nameAndDesc,
        -: 6657:            SourceLineInfo const& lineInfo ) {
        -: 6658:
    #####: 6659:        getMutableRegistryHub().registerTest
        -: 6660:            ( makeTestCase
    #####: 6661:                (   testCase,
    #####: 6662:                    extractClassName( classOrQualifiedMethodName ),
    #####: 6663:                    nameAndDesc.name,
    #####: 6664:                    nameAndDesc.description,
    #####: 6665:                    lineInfo ) );
    #####: 6666:    }
    #####: 6667:    void registerTestCaseFunction
        -: 6668:        (   TestFunction function,
        -: 6669:            SourceLineInfo const& lineInfo,
        -: 6670:            NameAndDesc const& nameAndDesc ) {
    #####: 6671:        registerTestCase( new FreeFunctionTestCase( function ), "", nameAndDesc, lineInfo );
    #####: 6672:    }
        -: 6673:
        -: 6674:    ///////////////////////////////////////////////////////////////////////////
        -: 6675:
    #####: 6676:    AutoReg::AutoReg
        -: 6677:        (   TestFunction function,
        -: 6678:            SourceLineInfo const& lineInfo,
        -: 6679:            NameAndDesc const& nameAndDesc ) {
    #####: 6680:        registerTestCaseFunction( function, lineInfo, nameAndDesc );
    #####: 6681:    }
        -: 6682:
    #####: 6683:    AutoReg::~AutoReg() {}
        -: 6684:
        -: 6685:} // end namespace Catch
        -: 6686:
        -: 6687:// #included from: catch_reporter_registry.hpp
        -: 6688:#define TWOBLUECUBES_CATCH_REPORTER_REGISTRY_HPP_INCLUDED
        -: 6689:
        -: 6690:#include <map>
        -: 6691:
        -: 6692:namespace Catch {
        -: 6693:
        1: 6694:    class ReporterRegistry : public IReporterRegistry {
        -: 6695:
        -: 6696:    public:
        -: 6697:
        1: 6698:        virtual ~ReporterRegistry() CATCH_OVERRIDE {}
        -: 6699:
        1: 6700:        virtual IStreamingReporter* create( std::string const& name, Ptr<IConfig const> const& config ) const CATCH_OVERRIDE {
        1: 6701:            FactoryMap::const_iterator it =  m_factories.find( name );
        1: 6702:            if( it == m_factories.end() )
    #####: 6703:                return CATCH_NULL;
        1: 6704:            return it->second->create( ReporterConfig( config ) );
        -: 6705:        }
        -: 6706:
        4: 6707:        void registerReporter( std::string const& name, Ptr<IReporterFactory> const& factory ) {
        4: 6708:            m_factories.insert( std::make_pair( name, factory ) );
        4: 6709:        }
    #####: 6710:        void registerListener( Ptr<IReporterFactory> const& factory ) {
    #####: 6711:            m_listeners.push_back( factory );
    #####: 6712:        }
        -: 6713:
    #####: 6714:        virtual FactoryMap const& getFactories() const CATCH_OVERRIDE {
    #####: 6715:            return m_factories;
        -: 6716:        }
        1: 6717:        virtual Listeners const& getListeners() const CATCH_OVERRIDE {
        1: 6718:            return m_listeners;
        -: 6719:        }
        -: 6720:
        -: 6721:    private:
        -: 6722:        FactoryMap m_factories;
        -: 6723:        Listeners m_listeners;
        -: 6724:    };
        -: 6725:}
        -: 6726:
        -: 6727:// #included from: catch_exception_translator_registry.hpp
        -: 6728:#define TWOBLUECUBES_CATCH_EXCEPTION_TRANSLATOR_REGISTRY_HPP_INCLUDED
        -: 6729:
        -: 6730:#ifdef __OBJC__
        -: 6731:#import "Foundation/Foundation.h"
        -: 6732:#endif
        -: 6733:
        -: 6734:namespace Catch {
        -: 6735:
        1: 6736:    class ExceptionTranslatorRegistry : public IExceptionTranslatorRegistry {
        -: 6737:    public:
        2: 6738:        ~ExceptionTranslatorRegistry() {
        1: 6739:            deleteAll( m_translators );
        1: 6740:        }
        -: 6741:
    #####: 6742:        virtual void registerTranslator( const IExceptionTranslator* translator ) {
    #####: 6743:            m_translators.push_back( translator );
    #####: 6744:        }
        -: 6745:
    #####: 6746:        virtual std::string translateActiveException() const {
        -: 6747:            try {
        -: 6748:#ifdef __OBJC__
        -: 6749:                // In Objective-C try objective-c exceptions first
        -: 6750:                @try {
        -: 6751:                    return tryTranslators();
        -: 6752:                }
        -: 6753:                @catch (NSException *exception) {
        -: 6754:                    return Catch::toString( [exception description] );
        -: 6755:                }
        -: 6756:#else
    #####: 6757:                return tryTranslators();
        -: 6758:#endif
        -: 6759:            }
    =====: 6760:            catch( TestFailureException& ) {
    =====: 6761:                throw;
        -: 6762:            }
    =====: 6763:            catch( std::exception& ex ) {
    =====: 6764:                return ex.what();
        -: 6765:            }
    =====: 6766:            catch( std::string& msg ) {
    =====: 6767:                return msg;
        -: 6768:            }
    =====: 6769:            catch( const char* msg ) {
    =====: 6770:                return msg;
        -: 6771:            }
    =====: 6772:            catch(...) {
    =====: 6773:                return "Unknown exception";
        -: 6774:            }
        -: 6775:        }
        -: 6776:
    #####: 6777:        std::string tryTranslators() const {
    #####: 6778:            if( m_translators.empty() )
    #####: 6779:                throw;
        -: 6780:            else
    #####: 6781:                return m_translators[0]->translate( m_translators.begin()+1, m_translators.end() );
        -: 6782:        }
        -: 6783:
        -: 6784:    private:
        -: 6785:        std::vector<const IExceptionTranslator*> m_translators;
        -: 6786:    };
        -: 6787:}
        -: 6788:
        -: 6789:namespace Catch {
        -: 6790:
        -: 6791:    namespace {
        -: 6792:
        2: 6793:        class RegistryHub : public IRegistryHub, public IMutableRegistryHub {
        -: 6794:
        -: 6795:            RegistryHub( RegistryHub const& );
        -: 6796:            void operator=( RegistryHub const& );
        -: 6797:
        -: 6798:        public: // IRegistryHub
        1: 6799:            RegistryHub() {
        1: 6800:            }
        2: 6801:            virtual IReporterRegistry const& getReporterRegistry() const CATCH_OVERRIDE {
        2: 6802:                return m_reporterRegistry;
        -: 6803:            }
        1: 6804:            virtual ITestCaseRegistry const& getTestCaseRegistry() const CATCH_OVERRIDE {
        1: 6805:                return m_testCaseRegistry;
        -: 6806:            }
    #####: 6807:            virtual IExceptionTranslatorRegistry& getExceptionTranslatorRegistry() CATCH_OVERRIDE {
    #####: 6808:                return m_exceptionTranslatorRegistry;
        -: 6809:            }
        -: 6810:
        -: 6811:        public: // IMutableRegistryHub
        4: 6812:            virtual void registerReporter( std::string const& name, Ptr<IReporterFactory> const& factory ) CATCH_OVERRIDE {
        4: 6813:                m_reporterRegistry.registerReporter( name, factory );
        4: 6814:            }
    #####: 6815:            virtual void registerListener( Ptr<IReporterFactory> const& factory ) CATCH_OVERRIDE {
    #####: 6816:                m_reporterRegistry.registerListener( factory );
    #####: 6817:            }
    #####: 6818:            virtual void registerTest( TestCase const& testInfo ) CATCH_OVERRIDE {
    #####: 6819:                m_testCaseRegistry.registerTest( testInfo );
    #####: 6820:            }
    #####: 6821:            virtual void registerTranslator( const IExceptionTranslator* translator ) CATCH_OVERRIDE {
    #####: 6822:                m_exceptionTranslatorRegistry.registerTranslator( translator );
    #####: 6823:            }
        -: 6824:
        -: 6825:        private:
        -: 6826:            TestRegistry m_testCaseRegistry;
        -: 6827:            ReporterRegistry m_reporterRegistry;
        -: 6828:            ExceptionTranslatorRegistry m_exceptionTranslatorRegistry;
        -: 6829:        };
        -: 6830:
        -: 6831:        // Single, global, instance
        9: 6832:        inline RegistryHub*& getTheRegistryHub() {
        -: 6833:            static RegistryHub* theRegistryHub = CATCH_NULL;
        9: 6834:            if( !theRegistryHub )
        1: 6835:                theRegistryHub = new RegistryHub();
        9: 6836:            return theRegistryHub;
        -: 6837:        }
        -: 6838:    }
        -: 6839:
        3: 6840:    IRegistryHub& getRegistryHub() {
        3: 6841:        return *getTheRegistryHub();
        -: 6842:    }
        4: 6843:    IMutableRegistryHub& getMutableRegistryHub() {
        4: 6844:        return *getTheRegistryHub();
        -: 6845:    }
        1: 6846:    void cleanUp() {
        1: 6847:        delete getTheRegistryHub();
        1: 6848:        getTheRegistryHub() = CATCH_NULL;
        1: 6849:        cleanUpContext();
        1: 6850:    }
    #####: 6851:    std::string translateActiveException() {
    #####: 6852:        return getRegistryHub().getExceptionTranslatorRegistry().translateActiveException();
        -: 6853:    }
        -: 6854:
        -: 6855:} // end namespace Catch
        -: 6856:
        -: 6857:// #included from: catch_notimplemented_exception.hpp
        -: 6858:#define TWOBLUECUBES_CATCH_NOTIMPLEMENTED_EXCEPTION_HPP_INCLUDED
        -: 6859:
        -: 6860:#include <ostream>
        -: 6861:
        -: 6862:namespace Catch {
        -: 6863:
    #####: 6864:    NotImplementedException::NotImplementedException( SourceLineInfo const& lineInfo )
    #####: 6865:    :   m_lineInfo( lineInfo ) {
    #####: 6866:        std::ostringstream oss;
    #####: 6867:        oss << lineInfo << ": function ";
    #####: 6868:        oss << "not implemented";
    #####: 6869:        m_what = oss.str();
    #####: 6870:    }
        -: 6871:
    #####: 6872:    const char* NotImplementedException::what() const CATCH_NOEXCEPT {
    #####: 6873:        return m_what.c_str();
        -: 6874:    }
        -: 6875:
        -: 6876:} // end namespace Catch
        -: 6877:
        -: 6878:// #included from: catch_context_impl.hpp
        -: 6879:#define TWOBLUECUBES_CATCH_CONTEXT_IMPL_HPP_INCLUDED
        -: 6880:
        -: 6881:// #included from: catch_stream.hpp
        -: 6882:#define TWOBLUECUBES_CATCH_STREAM_HPP_INCLUDED
        -: 6883:
        -: 6884:#include <stdexcept>
        -: 6885:#include <cstdio>
        -: 6886:#include <iostream>
        -: 6887:
        -: 6888:namespace Catch {
        -: 6889:
        -: 6890:    template<typename WriterF, size_t bufferSize=256>
        -: 6891:    class StreamBufImpl : public StreamBufBase {
        -: 6892:        char data[bufferSize];
        -: 6893:        WriterF m_writer;
        -: 6894:
        -: 6895:    public:
    #####: 6896:        StreamBufImpl() {
    #####: 6897:            setp( data, data + sizeof(data) );
    #####: 6898:        }
        -: 6899:
    #####: 6900:        ~StreamBufImpl() CATCH_NOEXCEPT {
    #####: 6901:            sync();
    #####: 6902:        }
        -: 6903:
        -: 6904:    private:
    #####: 6905:        int overflow( int c ) {
    #####: 6906:            sync();
        -: 6907:
    #####: 6908:            if( c != EOF ) {
    #####: 6909:                if( pbase() == epptr() )
    #####: 6910:                    m_writer( std::string( 1, static_cast<char>( c ) ) );
        -: 6911:                else
    #####: 6912:                    sputc( static_cast<char>( c ) );
        -: 6913:            }
    #####: 6914:            return 0;
        -: 6915:        }
        -: 6916:
    #####: 6917:        int sync() {
    #####: 6918:            if( pbase() != pptr() ) {
    #####: 6919:                m_writer( std::string( pbase(), static_cast<std::string::size_type>( pptr() - pbase() ) ) );
    #####: 6920:                setp( pbase(), epptr() );
        -: 6921:            }
    #####: 6922:            return 0;
        -: 6923:        }
        -: 6924:    };
        -: 6925:
        -: 6926:    ///////////////////////////////////////////////////////////////////////////
        -: 6927:
    #####: 6928:    FileStream::FileStream( std::string const& filename ) {
    #####: 6929:        m_ofs.open( filename.c_str() );
    #####: 6930:        if( m_ofs.fail() ) {
    #####: 6931:            std::ostringstream oss;
    #####: 6932:            oss << "Unable to open file: '" << filename << "'";
    #####: 6933:            throw std::domain_error( oss.str() );
        -: 6934:        }
    #####: 6935:    }
        -: 6936:
    #####: 6937:    std::ostream& FileStream::stream() const {
    #####: 6938:        return m_ofs;
        -: 6939:    }
        -: 6940:
        -: 6941:    struct OutputDebugWriter {
        -: 6942:
    #####: 6943:        void operator()( std::string const&str ) {
    #####: 6944:            writeToDebugConsole( str );
    #####: 6945:        }
        -: 6946:    };
        -: 6947:
    #####: 6948:    DebugOutStream::DebugOutStream()
    =====: 6949:    :   m_streamBuf( new StreamBufImpl<OutputDebugWriter>() ),
    #####: 6950:        m_os( m_streamBuf.get() )
    #####: 6951:    {}
        -: 6952:
    #####: 6953:    std::ostream& DebugOutStream::stream() const {
    #####: 6954:        return m_os;
        -: 6955:    }
        -: 6956:
        -: 6957:    // Store the streambuf from cout up-front because
        -: 6958:    // cout may get redirected when running tests
        1: 6959:    CoutStream::CoutStream()
        1: 6960:    :   m_os( Catch::cout().rdbuf() )
        1: 6961:    {}
        -: 6962:
        1: 6963:    std::ostream& CoutStream::stream() const {
        1: 6964:        return m_os;
        -: 6965:    }
        -: 6966:
        -: 6967:#ifndef CATCH_CONFIG_NOSTDOUT // If you #define this you must implement these functions
        5: 6968:    std::ostream& cout() {
        5: 6969:        return std::cout;
        -: 6970:    }
    #####: 6971:    std::ostream& cerr() {
    #####: 6972:        return std::cerr;
        -: 6973:    }
        -: 6974:#endif
        -: 6975:}
        -: 6976:
        -: 6977:namespace Catch {
        -: 6978:
        2: 6979:    class Context : public IMutableContext {
        -: 6980:
        1: 6981:        Context() : m_config( CATCH_NULL ), m_runner( CATCH_NULL ), m_resultCapture( CATCH_NULL ) {}
        -: 6982:        Context( Context const& );
        -: 6983:        void operator=( Context const& );
        -: 6984:
        -: 6985:    public: // IContext
    #####: 6986:        virtual IResultCapture* getResultCapture() {
    #####: 6987:            return m_resultCapture;
        -: 6988:        }
    #####: 6989:        virtual IRunner* getRunner() {
    #####: 6990:            return m_runner;
        -: 6991:        }
    #####: 6992:        virtual size_t getGeneratorIndex( std::string const& fileInfo, size_t totalSize ) {
    #####: 6993:            return getGeneratorsForCurrentTest()
    #####: 6994:            .getGeneratorInfo( fileInfo, totalSize )
    #####: 6995:            .getCurrentIndex();
        -: 6996:        }
    #####: 6997:        virtual bool advanceGeneratorsForCurrentTest() {
    #####: 6998:            IGeneratorsForTest* generators = findGeneratorsForCurrentTest();
    #####: 6999:            return generators && generators->moveNext();
        -: 7000:        }
        -: 7001:
        1: 7002:        virtual Ptr<IConfig const> getConfig() const {
        1: 7003:            return m_config;
        -: 7004:        }
        -: 7005:
        -: 7006:    public: // IMutableContext
        1: 7007:        virtual void setResultCapture( IResultCapture* resultCapture ) {
        1: 7008:            m_resultCapture = resultCapture;
        1: 7009:        }
        1: 7010:        virtual void setRunner( IRunner* runner ) {
        1: 7011:            m_runner = runner;
        1: 7012:        }
        1: 7013:        virtual void setConfig( Ptr<IConfig const> const& config ) {
        1: 7014:            m_config = config;
        1: 7015:        }
        -: 7016:
        -: 7017:        friend IMutableContext& getCurrentMutableContext();
        -: 7018:
        -: 7019:    private:
    #####: 7020:        IGeneratorsForTest* findGeneratorsForCurrentTest() {
    #####: 7021:            std::string testName = getResultCapture()->getCurrentTestName();
        -: 7022:
        -: 7023:            std::map<std::string, IGeneratorsForTest*>::const_iterator it =
    #####: 7024:                m_generatorsByTestName.find( testName );
    #####: 7025:            return it != m_generatorsByTestName.end()
    #####: 7026:                ? it->second
    #####: 7027:                : CATCH_NULL;
        -: 7028:        }
        -: 7029:
    #####: 7030:        IGeneratorsForTest& getGeneratorsForCurrentTest() {
    #####: 7031:            IGeneratorsForTest* generators = findGeneratorsForCurrentTest();
    #####: 7032:            if( !generators ) {
    #####: 7033:                std::string testName = getResultCapture()->getCurrentTestName();
    #####: 7034:                generators = createGeneratorsForTest();
    #####: 7035:                m_generatorsByTestName.insert( std::make_pair( testName, generators ) );
        -: 7036:            }
    #####: 7037:            return *generators;
        -: 7038:        }
        -: 7039:
        -: 7040:    private:
        -: 7041:        Ptr<IConfig const> m_config;
        -: 7042:        IRunner* m_runner;
        -: 7043:        IResultCapture* m_resultCapture;
        -: 7044:        std::map<std::string, IGeneratorsForTest*> m_generatorsByTestName;
        -: 7045:    };
        -: 7046:
        -: 7047:    namespace {
        -: 7048:        Context* currentContext = CATCH_NULL;
        -: 7049:    }
        2: 7050:    IMutableContext& getCurrentMutableContext() {
        2: 7051:        if( !currentContext )
        1: 7052:            currentContext = new Context();
        2: 7053:        return *currentContext;
        -: 7054:    }
        1: 7055:    IContext& getCurrentContext() {
        1: 7056:        return getCurrentMutableContext();
        -: 7057:    }
        -: 7058:
        1: 7059:    void cleanUpContext() {
        1: 7060:        delete currentContext;
        1: 7061:        currentContext = CATCH_NULL;
        1: 7062:    }
        -: 7063:}
        -: 7064:
        -: 7065:// #included from: catch_console_colour_impl.hpp
        -: 7066:#define TWOBLUECUBES_CATCH_CONSOLE_COLOUR_IMPL_HPP_INCLUDED
        -: 7067:
        -: 7068:namespace Catch {
        -: 7069:    namespace {
        -: 7070:
        -: 7071:        struct IColourImpl {
        1: 7072:            virtual ~IColourImpl() {}
        -: 7073:            virtual void use( Colour::Code _colourCode ) = 0;
        -: 7074:        };
        -: 7075:
    #####: 7076:        struct NoColourImpl : IColourImpl {
    #####: 7077:            void use( Colour::Code ) {}
        -: 7078:
    #####: 7079:            static IColourImpl* instance() {
    #####: 7080:                static NoColourImpl s_instance;
    #####: 7081:                return &s_instance;
        -: 7082:            }
        -: 7083:        };
        -: 7084:
        -: 7085:    } // anon namespace
        -: 7086:} // namespace Catch
        -: 7087:
        -: 7088:#if !defined( CATCH_CONFIG_COLOUR_NONE ) && !defined( CATCH_CONFIG_COLOUR_WINDOWS ) && !defined( CATCH_CONFIG_COLOUR_ANSI )
        -: 7089:#   ifdef CATCH_PLATFORM_WINDOWS
        -: 7090:#       define CATCH_CONFIG_COLOUR_WINDOWS
        -: 7091:#   else
        -: 7092:#       define CATCH_CONFIG_COLOUR_ANSI
        -: 7093:#   endif
        -: 7094:#endif
        -: 7095:
        -: 7096:#if defined ( CATCH_CONFIG_COLOUR_WINDOWS ) /////////////////////////////////////////
        -: 7097:
        -: 7098:#ifndef NOMINMAX
        -: 7099:#define NOMINMAX
        -: 7100:#endif
        -: 7101:
        -: 7102:#ifdef __AFXDLL
        -: 7103:#include <AfxWin.h>
        -: 7104:#else
        -: 7105:#include <windows.h>
        -: 7106:#endif
        -: 7107:
        -: 7108:namespace Catch {
        -: 7109:namespace {
        -: 7110:
        -: 7111:    class Win32ColourImpl : public IColourImpl {
        -: 7112:    public:
        -: 7113:        Win32ColourImpl() : stdoutHandle( GetStdHandle(STD_OUTPUT_HANDLE) )
        -: 7114:        {
        -: 7115:            CONSOLE_SCREEN_BUFFER_INFO csbiInfo;
        -: 7116:            GetConsoleScreenBufferInfo( stdoutHandle, &csbiInfo );
        -: 7117:            originalForegroundAttributes = csbiInfo.wAttributes & ~( BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_BLUE | BACKGROUND_INTENSITY );
        -: 7118:            originalBackgroundAttributes = csbiInfo.wAttributes & ~( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_INTENSITY );
        -: 7119:        }
        -: 7120:
        -: 7121:        virtual void use( Colour::Code _colourCode ) {
        -: 7122:            switch( _colourCode ) {
        -: 7123:                case Colour::None:      return setTextAttribute( originalForegroundAttributes );
        -: 7124:                case Colour::White:     return setTextAttribute( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );
        -: 7125:                case Colour::Red:       return setTextAttribute( FOREGROUND_RED );
        -: 7126:                case Colour::Green:     return setTextAttribute( FOREGROUND_GREEN );
        -: 7127:                case Colour::Blue:      return setTextAttribute( FOREGROUND_BLUE );
        -: 7128:                case Colour::Cyan:      return setTextAttribute( FOREGROUND_BLUE | FOREGROUND_GREEN );
        -: 7129:                case Colour::Yellow:    return setTextAttribute( FOREGROUND_RED | FOREGROUND_GREEN );
        -: 7130:                case Colour::Grey:      return setTextAttribute( 0 );
        -: 7131:
        -: 7132:                case Colour::LightGrey:     return setTextAttribute( FOREGROUND_INTENSITY );
        -: 7133:                case Colour::BrightRed:     return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_RED );
        -: 7134:                case Colour::BrightGreen:   return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN );
        -: 7135:                case Colour::BrightWhite:   return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );
        -: 7136:
        -: 7137:                case Colour::Bright: throw std::logic_error( "not a colour" );
        -: 7138:            }
        -: 7139:        }
        -: 7140:
        -: 7141:    private:
        -: 7142:        void setTextAttribute( WORD _textAttribute ) {
        -: 7143:            SetConsoleTextAttribute( stdoutHandle, _textAttribute | originalBackgroundAttributes );
        -: 7144:        }
        -: 7145:        HANDLE stdoutHandle;
        -: 7146:        WORD originalForegroundAttributes;
        -: 7147:        WORD originalBackgroundAttributes;
        -: 7148:    };
        -: 7149:
        -: 7150:    IColourImpl* platformColourInstance() {
        -: 7151:        static Win32ColourImpl s_instance;
        -: 7152:
        -: 7153:        Ptr<IConfig const> config = getCurrentContext().getConfig();
        -: 7154:        UseColour::YesOrNo colourMode = config
        -: 7155:            ? config->useColour()
        -: 7156:            : UseColour::Auto;
        -: 7157:        if( colourMode == UseColour::Auto )
        -: 7158:            colourMode = !isDebuggerActive()
        -: 7159:                ? UseColour::Yes
        -: 7160:                : UseColour::No;
        -: 7161:        return colourMode == UseColour::Yes
        -: 7162:            ? &s_instance
        -: 7163:            : NoColourImpl::instance();
        -: 7164:    }
        -: 7165:
        -: 7166:} // end anon namespace
        -: 7167:} // end namespace Catch
        -: 7168:
        -: 7169:#elif defined( CATCH_CONFIG_COLOUR_ANSI ) //////////////////////////////////////
        -: 7170:
        -: 7171:#include <unistd.h>
        -: 7172:
        -: 7173:namespace Catch {
        -: 7174:namespace {
        -: 7175:
        -: 7176:    // use POSIX/ ANSI console terminal codes
        -: 7177:    // Thanks to Adam Strzelecki for original contribution
        -: 7178:    // (http://github.com/nanoant)
        -: 7179:    // https://github.com/philsquared/Catch/pull/131
        1: 7180:    class PosixColourImpl : public IColourImpl {
        -: 7181:    public:
        4: 7182:        virtual void use( Colour::Code _colourCode ) {
        4: 7183:            switch( _colourCode ) {
        -: 7184:                case Colour::None:
        2: 7185:                case Colour::White:     return setColour( "[0m" );
    #####: 7186:                case Colour::Red:       return setColour( "[0;31m" );
    #####: 7187:                case Colour::Green:     return setColour( "[0;32m" );
    #####: 7188:                case Colour::Blue:      return setColour( "[0;34m" );
    #####: 7189:                case Colour::Cyan:      return setColour( "[0;36m" );
        2: 7190:                case Colour::Yellow:    return setColour( "[0;33m" );
    #####: 7191:                case Colour::Grey:      return setColour( "[1;30m" );
        -: 7192:
    #####: 7193:                case Colour::LightGrey:     return setColour( "[0;37m" );
    #####: 7194:                case Colour::BrightRed:     return setColour( "[1;31m" );
    #####: 7195:                case Colour::BrightGreen:   return setColour( "[1;32m" );
    #####: 7196:                case Colour::BrightWhite:   return setColour( "[1;37m" );
        -: 7197:
    #####: 7198:                case Colour::Bright: throw std::logic_error( "not a colour" );
        -: 7199:            }
        -: 7200:        }
        1: 7201:        static IColourImpl* instance() {
        1: 7202:            static PosixColourImpl s_instance;
        1: 7203:            return &s_instance;
        -: 7204:        }
        -: 7205:
        -: 7206:    private:
        4: 7207:        void setColour( const char* _escapeCode ) {
        4: 7208:            Catch::cout() << '\033' << _escapeCode;
        4: 7209:        }
        -: 7210:    };
        -: 7211:
        1: 7212:    IColourImpl* platformColourInstance() {
        2: 7213:        Ptr<IConfig const> config = getCurrentContext().getConfig();
        -: 7214:        UseColour::YesOrNo colourMode = config
        1: 7215:            ? config->useColour()
        2: 7216:            : UseColour::Auto;
        1: 7217:        if( colourMode == UseColour::Auto )
        2: 7218:            colourMode = (!isDebuggerActive() && isatty(STDOUT_FILENO) )
        -: 7219:                ? UseColour::Yes
        2: 7220:                : UseColour::No;
        -: 7221:        return colourMode == UseColour::Yes
        -: 7222:            ? PosixColourImpl::instance()
        2: 7223:            : NoColourImpl::instance();
        -: 7224:    }
        -: 7225:
        -: 7226:} // end anon namespace
        -: 7227:} // end namespace Catch
        -: 7228:
        -: 7229:#else  // not Windows or ANSI ///////////////////////////////////////////////
        -: 7230:
        -: 7231:namespace Catch {
        -: 7232:
        -: 7233:    static IColourImpl* platformColourInstance() { return NoColourImpl::instance(); }
        -: 7234:
        -: 7235:} // end namespace Catch
        -: 7236:
        -: 7237:#endif // Windows/ ANSI/ None
        -: 7238:
        -: 7239:namespace Catch {
        -: 7240:
        2: 7241:    Colour::Colour( Code _colourCode ) : m_moved( false ) { use( _colourCode ); }
    #####: 7242:    Colour::Colour( Colour const& _other ) : m_moved( false ) { const_cast<Colour&>( _other ).m_moved = true; }
        2: 7243:    Colour::~Colour(){ if( !m_moved ) use( None ); }
        -: 7244:
        4: 7245:    void Colour::use( Code _colourCode ) {
        4: 7246:        static IColourImpl* impl = platformColourInstance();
        4: 7247:        impl->use( _colourCode );
        4: 7248:    }
        -: 7249:
        -: 7250:} // end namespace Catch
        -: 7251:
        -: 7252:// #included from: catch_generators_impl.hpp
        -: 7253:#define TWOBLUECUBES_CATCH_GENERATORS_IMPL_HPP_INCLUDED
        -: 7254:
        -: 7255:#include <vector>
        -: 7256:#include <string>
        -: 7257:#include <map>
        -: 7258:
        -: 7259:namespace Catch {
        -: 7260:
    #####: 7261:    struct GeneratorInfo : IGeneratorInfo {
        -: 7262:
    #####: 7263:        GeneratorInfo( std::size_t size )
        -: 7264:        :   m_size( size ),
    #####: 7265:            m_currentIndex( 0 )
    #####: 7266:        {}
        -: 7267:
    #####: 7268:        bool moveNext() {
    #####: 7269:            if( ++m_currentIndex == m_size ) {
    #####: 7270:                m_currentIndex = 0;
    #####: 7271:                return false;
        -: 7272:            }
    #####: 7273:            return true;
        -: 7274:        }
        -: 7275:
    #####: 7276:        std::size_t getCurrentIndex() const {
    #####: 7277:            return m_currentIndex;
        -: 7278:        }
        -: 7279:
        -: 7280:        std::size_t m_size;
        -: 7281:        std::size_t m_currentIndex;
        -: 7282:    };
        -: 7283:
        -: 7284:    ///////////////////////////////////////////////////////////////////////////
        -: 7285:
    #####: 7286:    class GeneratorsForTest : public IGeneratorsForTest {
        -: 7287:
        -: 7288:    public:
    #####: 7289:        ~GeneratorsForTest() {
    #####: 7290:            deleteAll( m_generatorsInOrder );
    #####: 7291:        }
        -: 7292:
    #####: 7293:        IGeneratorInfo& getGeneratorInfo( std::string const& fileInfo, std::size_t size ) {
    #####: 7294:            std::map<std::string, IGeneratorInfo*>::const_iterator it = m_generatorsByName.find( fileInfo );
    #####: 7295:            if( it == m_generatorsByName.end() ) {
    #####: 7296:                IGeneratorInfo* info = new GeneratorInfo( size );
    #####: 7297:                m_generatorsByName.insert( std::make_pair( fileInfo, info ) );
    #####: 7298:                m_generatorsInOrder.push_back( info );
    #####: 7299:                return *info;
        -: 7300:            }
    #####: 7301:            return *it->second;
        -: 7302:        }
        -: 7303:
    #####: 7304:        bool moveNext() {
    #####: 7305:            std::vector<IGeneratorInfo*>::const_iterator it = m_generatorsInOrder.begin();
    #####: 7306:            std::vector<IGeneratorInfo*>::const_iterator itEnd = m_generatorsInOrder.end();
    #####: 7307:            for(; it != itEnd; ++it ) {
    #####: 7308:                if( (*it)->moveNext() )
    #####: 7309:                    return true;
        -: 7310:            }
    #####: 7311:            return false;
        -: 7312:        }
        -: 7313:
        -: 7314:    private:
        -: 7315:        std::map<std::string, IGeneratorInfo*> m_generatorsByName;
        -: 7316:        std::vector<IGeneratorInfo*> m_generatorsInOrder;
        -: 7317:    };
        -: 7318:
    #####: 7319:    IGeneratorsForTest* createGeneratorsForTest()
        -: 7320:    {
    #####: 7321:        return new GeneratorsForTest();
        -: 7322:    }
        -: 7323:
        -: 7324:} // end namespace Catch
        -: 7325:
        -: 7326:// #included from: catch_assertionresult.hpp
        -: 7327:#define TWOBLUECUBES_CATCH_ASSERTIONRESULT_HPP_INCLUDED
        -: 7328:
        -: 7329:namespace Catch {
        -: 7330:
    #####: 7331:    AssertionInfo::AssertionInfo(   std::string const& _macroName,
        -: 7332:                                    SourceLineInfo const& _lineInfo,
        -: 7333:                                    std::string const& _capturedExpression,
        -: 7334:                                    ResultDisposition::Flags _resultDisposition )
        -: 7335:    :   macroName( _macroName ),
        -: 7336:        lineInfo( _lineInfo ),
        -: 7337:        capturedExpression( _capturedExpression ),
    #####: 7338:        resultDisposition( _resultDisposition )
    #####: 7339:    {}
        -: 7340:
        1: 7341:    AssertionResult::AssertionResult() {}
        -: 7342:
    #####: 7343:    AssertionResult::AssertionResult( AssertionInfo const& info, AssertionResultData const& data )
        -: 7344:    :   m_info( info ),
    #####: 7345:        m_resultData( data )
    #####: 7346:    {}
        -: 7347:
        1: 7348:    AssertionResult::~AssertionResult() {}
        -: 7349:
        -: 7350:    // Result was a success
    #####: 7351:    bool AssertionResult::succeeded() const {
    #####: 7352:        return Catch::isOk( m_resultData.resultType );
        -: 7353:    }
        -: 7354:
        -: 7355:    // Result was a success, or failure is suppressed
    #####: 7356:    bool AssertionResult::isOk() const {
    #####: 7357:        return Catch::isOk( m_resultData.resultType ) || shouldSuppressFailure( m_info.resultDisposition );
        -: 7358:    }
        -: 7359:
    #####: 7360:    ResultWas::OfType AssertionResult::getResultType() const {
    #####: 7361:        return m_resultData.resultType;
        -: 7362:    }
        -: 7363:
    #####: 7364:    bool AssertionResult::hasExpression() const {
    #####: 7365:        return !m_info.capturedExpression.empty();
        -: 7366:    }
        -: 7367:
    #####: 7368:    bool AssertionResult::hasMessage() const {
    #####: 7369:        return !m_resultData.message.empty();
        -: 7370:    }
        -: 7371:
    #####: 7372:    std::string AssertionResult::getExpression() const {
    #####: 7373:        if( isFalseTest( m_info.resultDisposition ) )
    #####: 7374:            return "!" + m_info.capturedExpression;
        -: 7375:        else
    #####: 7376:            return m_info.capturedExpression;
        -: 7377:    }
    #####: 7378:    std::string AssertionResult::getExpressionInMacro() const {
    #####: 7379:        if( m_info.macroName.empty() )
    #####: 7380:            return m_info.capturedExpression;
        -: 7381:        else
    #####: 7382:            return m_info.macroName + "( " + m_info.capturedExpression + " )";
        -: 7383:    }
        -: 7384:
    #####: 7385:    bool AssertionResult::hasExpandedExpression() const {
    #####: 7386:        return hasExpression() && getExpandedExpression() != getExpression();
        -: 7387:    }
        -: 7388:
    #####: 7389:    std::string AssertionResult::getExpandedExpression() const {
    #####: 7390:        return m_resultData.reconstructedExpression;
        -: 7391:    }
        -: 7392:
    #####: 7393:    std::string AssertionResult::getMessage() const {
    #####: 7394:        return m_resultData.message;
        -: 7395:    }
    #####: 7396:    SourceLineInfo AssertionResult::getSourceInfo() const {
    #####: 7397:        return m_info.lineInfo;
        -: 7398:    }
        -: 7399:
    #####: 7400:    std::string AssertionResult::getTestMacroName() const {
    #####: 7401:        return m_info.macroName;
        -: 7402:    }
        -: 7403:
        -: 7404:} // end namespace Catch
        -: 7405:
        -: 7406:// #included from: catch_test_case_info.hpp
        -: 7407:#define TWOBLUECUBES_CATCH_TEST_CASE_INFO_HPP_INCLUDED
        -: 7408:
        -: 7409:namespace Catch {
        -: 7410:
    #####: 7411:    inline TestCaseInfo::SpecialProperties parseSpecialTag( std::string const& tag ) {
    #####: 7412:        if( startsWith( tag, "." ) ||
    #####: 7413:            tag == "hide" ||
    #####: 7414:            tag == "!hide" )
    #####: 7415:            return TestCaseInfo::IsHidden;
    #####: 7416:        else if( tag == "!throws" )
    #####: 7417:            return TestCaseInfo::Throws;
    #####: 7418:        else if( tag == "!shouldfail" )
    #####: 7419:            return TestCaseInfo::ShouldFail;
    #####: 7420:        else if( tag == "!mayfail" )
    #####: 7421:            return TestCaseInfo::MayFail;
        -: 7422:        else
    #####: 7423:            return TestCaseInfo::None;
        -: 7424:    }
    #####: 7425:    inline bool isReservedTag( std::string const& tag ) {
    #####: 7426:        return parseSpecialTag( tag ) == TestCaseInfo::None && tag.size() > 0 && !isalnum( tag[0] );
        -: 7427:    }
    #####: 7428:    inline void enforceNotReservedTag( std::string const& tag, SourceLineInfo const& _lineInfo ) {
    #####: 7429:        if( isReservedTag( tag ) ) {
        -: 7430:            {
    #####: 7431:                Colour colourGuard( Colour::Red );
    #####: 7432:                Catch::cerr()
    #####: 7433:                    << "Tag name [" << tag << "] not allowed.\n"
    #####: 7434:                    << "Tag names starting with non alpha-numeric characters are reserved\n";
        -: 7435:            }
        -: 7436:            {
    #####: 7437:                Colour colourGuard( Colour::FileName );
    #####: 7438:                Catch::cerr() << _lineInfo << std::endl;
        -: 7439:            }
    #####: 7440:            exit(1);
        -: 7441:        }
    #####: 7442:    }
        -: 7443:
    #####: 7444:    TestCase makeTestCase(  ITestCase* _testCase,
        -: 7445:                            std::string const& _className,
        -: 7446:                            std::string const& _name,
        -: 7447:                            std::string const& _descOrTags,
        -: 7448:                            SourceLineInfo const& _lineInfo )
        -: 7449:    {
    #####: 7450:        bool isHidden( startsWith( _name, "./" ) ); // Legacy support
        -: 7451:
        -: 7452:        // Parse out tags
    #####: 7453:        std::set<std::string> tags;
    #####: 7454:        std::string desc, tag;
    #####: 7455:        bool inTag = false;
    #####: 7456:        for( std::size_t i = 0; i < _descOrTags.size(); ++i ) {
    #####: 7457:            char c = _descOrTags[i];
    #####: 7458:            if( !inTag ) {
    #####: 7459:                if( c == '[' )
    #####: 7460:                    inTag = true;
        -: 7461:                else
    #####: 7462:                    desc += c;
        -: 7463:            }
        -: 7464:            else {
    #####: 7465:                if( c == ']' ) {
    #####: 7466:                    TestCaseInfo::SpecialProperties prop = parseSpecialTag( tag );
    #####: 7467:                    if( prop == TestCaseInfo::IsHidden )
    #####: 7468:                        isHidden = true;
    #####: 7469:                    else if( prop == TestCaseInfo::None )
    #####: 7470:                        enforceNotReservedTag( tag, _lineInfo );
        -: 7471:
    #####: 7472:                    tags.insert( tag );
    #####: 7473:                    tag.clear();
    #####: 7474:                    inTag = false;
        -: 7475:                }
        -: 7476:                else
    #####: 7477:                    tag += c;
        -: 7478:            }
        -: 7479:        }
    #####: 7480:        if( isHidden ) {
    #####: 7481:            tags.insert( "hide" );
    #####: 7482:            tags.insert( "." );
        -: 7483:        }
        -: 7484:
    #####: 7485:        TestCaseInfo info( _name, _className, desc, tags, _lineInfo );
    #####: 7486:        return TestCase( _testCase, info );
        -: 7487:    }
        -: 7488:
    #####: 7489:    void setTags( TestCaseInfo& testCaseInfo, std::set<std::string> const& tags )
        -: 7490:    {
    #####: 7491:        testCaseInfo.tags = tags;
    #####: 7492:        testCaseInfo.lcaseTags.clear();
        -: 7493:
    #####: 7494:        std::ostringstream oss;
    #####: 7495:        for( std::set<std::string>::const_iterator it = tags.begin(), itEnd = tags.end(); it != itEnd; ++it ) {
    #####: 7496:            oss << "[" << *it << "]";
    #####: 7497:            std::string lcaseTag = toLower( *it );
    #####: 7498:            testCaseInfo.properties = static_cast<TestCaseInfo::SpecialProperties>( testCaseInfo.properties | parseSpecialTag( lcaseTag ) );
    #####: 7499:            testCaseInfo.lcaseTags.insert( lcaseTag );
        -: 7500:        }
    #####: 7501:        testCaseInfo.tagsAsString = oss.str();
    #####: 7502:    }
        -: 7503:
    #####: 7504:    TestCaseInfo::TestCaseInfo( std::string const& _name,
        -: 7505:                                std::string const& _className,
        -: 7506:                                std::string const& _description,
        -: 7507:                                std::set<std::string> const& _tags,
        -: 7508:                                SourceLineInfo const& _lineInfo )
        -: 7509:    :   name( _name ),
        -: 7510:        className( _className ),
        -: 7511:        description( _description ),
        -: 7512:        lineInfo( _lineInfo ),
    #####: 7513:        properties( None )
        -: 7514:    {
    #####: 7515:        setTags( *this, _tags );
    #####: 7516:    }
        -: 7517:
    #####: 7518:    TestCaseInfo::TestCaseInfo( TestCaseInfo const& other )
        -: 7519:    :   name( other.name ),
        -: 7520:        className( other.className ),
        -: 7521:        description( other.description ),
        -: 7522:        tags( other.tags ),
        -: 7523:        lcaseTags( other.lcaseTags ),
        -: 7524:        tagsAsString( other.tagsAsString ),
        -: 7525:        lineInfo( other.lineInfo ),
    #####: 7526:        properties( other.properties )
    #####: 7527:    {}
        -: 7528:
    #####: 7529:    bool TestCaseInfo::isHidden() const {
    #####: 7530:        return ( properties & IsHidden ) != 0;
        -: 7531:    }
    #####: 7532:    bool TestCaseInfo::throws() const {
    #####: 7533:        return ( properties & Throws ) != 0;
        -: 7534:    }
    #####: 7535:    bool TestCaseInfo::okToFail() const {
    #####: 7536:        return ( properties & (ShouldFail | MayFail ) ) != 0;
        -: 7537:    }
    #####: 7538:    bool TestCaseInfo::expectedToFail() const {
    #####: 7539:        return ( properties & (ShouldFail ) ) != 0;
        -: 7540:    }
        -: 7541:
    #####: 7542:    TestCase::TestCase( ITestCase* testCase, TestCaseInfo const& info ) : TestCaseInfo( info ), test( testCase ) {}
        -: 7543:
    #####: 7544:    TestCase::TestCase( TestCase const& other )
        -: 7545:    :   TestCaseInfo( other ),
    #####: 7546:        test( other.test )
    #####: 7547:    {}
        -: 7548:
    #####: 7549:    TestCase TestCase::withName( std::string const& _newName ) const {
    #####: 7550:        TestCase other( *this );
    #####: 7551:        other.name = _newName;
    #####: 7552:        return other;
        -: 7553:    }
        -: 7554:
    #####: 7555:    void TestCase::swap( TestCase& other ) {
    #####: 7556:        test.swap( other.test );
    #####: 7557:        name.swap( other.name );
    #####: 7558:        className.swap( other.className );
    #####: 7559:        description.swap( other.description );
    #####: 7560:        tags.swap( other.tags );
    #####: 7561:        lcaseTags.swap( other.lcaseTags );
    #####: 7562:        tagsAsString.swap( other.tagsAsString );
    #####: 7563:        std::swap( TestCaseInfo::properties, static_cast<TestCaseInfo&>( other ).properties );
    #####: 7564:        std::swap( lineInfo, other.lineInfo );
    #####: 7565:    }
        -: 7566:
    #####: 7567:    void TestCase::invoke() const {
    #####: 7568:        test->invoke();
    #####: 7569:    }
        -: 7570:
    #####: 7571:    bool TestCase::operator == ( TestCase const& other ) const {
    #####: 7572:        return  test.get() == other.test.get() &&
    #####: 7573:                name == other.name &&
    #####: 7574:                className == other.className;
        -: 7575:    }
        -: 7576:
    #####: 7577:    bool TestCase::operator < ( TestCase const& other ) const {
    #####: 7578:        return name < other.name;
        -: 7579:    }
    #####: 7580:    TestCase& TestCase::operator = ( TestCase const& other ) {
    #####: 7581:        TestCase temp( other );
    #####: 7582:        swap( temp );
    #####: 7583:        return *this;
        -: 7584:    }
        -: 7585:
    #####: 7586:    TestCaseInfo const& TestCase::getTestCaseInfo() const
        -: 7587:    {
    #####: 7588:        return *this;
        -: 7589:    }
        -: 7590:
        -: 7591:} // end namespace Catch
        -: 7592:
        -: 7593:// #included from: catch_version.hpp
        -: 7594:#define TWOBLUECUBES_CATCH_VERSION_HPP_INCLUDED
        -: 7595:
        -: 7596:namespace Catch {
        -: 7597:
        1: 7598:    Version::Version
        -: 7599:        (   unsigned int _majorVersion,
        -: 7600:            unsigned int _minorVersion,
        -: 7601:            unsigned int _patchNumber,
        -: 7602:            std::string const& _branchName,
        -: 7603:            unsigned int _buildNumber )
        -: 7604:    :   majorVersion( _majorVersion ),
        -: 7605:        minorVersion( _minorVersion ),
        -: 7606:        patchNumber( _patchNumber ),
        -: 7607:        branchName( _branchName ),
        1: 7608:        buildNumber( _buildNumber )
        1: 7609:    {}
        -: 7610:
    #####: 7611:    std::ostream& operator << ( std::ostream& os, Version const& version ) {
    #####: 7612:        os  << version.majorVersion << "."
    #####: 7613:            << version.minorVersion << "."
    #####: 7614:            << version.patchNumber;
        -: 7615:
    #####: 7616:        if( !version.branchName.empty() ) {
    #####: 7617:            os  << "-" << version.branchName
    #####: 7618:                << "." << version.buildNumber;
        -: 7619:        }
    #####: 7620:        return os;
        -: 7621:    }
        -: 7622:
        1: 7623:    Version libraryVersion( 1, 6, 0, "", 0 );
        -: 7624:
        -: 7625:}
        -: 7626:
        -: 7627:// #included from: catch_message.hpp
        -: 7628:#define TWOBLUECUBES_CATCH_MESSAGE_HPP_INCLUDED
        -: 7629:
        -: 7630:namespace Catch {
        -: 7631:
    #####: 7632:    MessageInfo::MessageInfo(   std::string const& _macroName,
        -: 7633:                                SourceLineInfo const& _lineInfo,
        -: 7634:                                ResultWas::OfType _type )
        -: 7635:    :   macroName( _macroName ),
        -: 7636:        lineInfo( _lineInfo ),
        -: 7637:        type( _type ),
    #####: 7638:        sequence( ++globalCount )
    #####: 7639:    {}
        -: 7640:
        -: 7641:    // This may need protecting if threading support is added
        -: 7642:    unsigned int MessageInfo::globalCount = 0;
        -: 7643:
        -: 7644:    ////////////////////////////////////////////////////////////////////////////
        -: 7645:
    #####: 7646:    ScopedMessage::ScopedMessage( MessageBuilder const& builder )
    #####: 7647:    : m_info( builder.m_info )
        -: 7648:    {
    #####: 7649:        m_info.message = builder.m_stream.str();
    #####: 7650:        getResultCapture().pushScopedMessage( m_info );
    #####: 7651:    }
    #####: 7652:    ScopedMessage::ScopedMessage( ScopedMessage const& other )
    #####: 7653:    : m_info( other.m_info )
    #####: 7654:    {}
        -: 7655:
    #####: 7656:    ScopedMessage::~ScopedMessage() {
    #####: 7657:        getResultCapture().popScopedMessage( m_info );
    #####: 7658:    }
        -: 7659:
        -: 7660:} // end namespace Catch
        -: 7661:
        -: 7662:// #included from: catch_legacy_reporter_adapter.hpp
        -: 7663:#define TWOBLUECUBES_CATCH_LEGACY_REPORTER_ADAPTER_HPP_INCLUDED
        -: 7664:
        -: 7665:// #included from: catch_legacy_reporter_adapter.h
        -: 7666:#define TWOBLUECUBES_CATCH_LEGACY_REPORTER_ADAPTER_H_INCLUDED
        -: 7667:
        -: 7668:namespace Catch
        -: 7669:{
        -: 7670:    // Deprecated
        -: 7671:    struct IReporter : IShared {
        -: 7672:        virtual ~IReporter();
        -: 7673:
        -: 7674:        virtual bool shouldRedirectStdout() const = 0;
        -: 7675:
        -: 7676:        virtual void StartTesting() = 0;
        -: 7677:        virtual void EndTesting( Totals const& totals ) = 0;
        -: 7678:        virtual void StartGroup( std::string const& groupName ) = 0;
        -: 7679:        virtual void EndGroup( std::string const& groupName, Totals const& totals ) = 0;
        -: 7680:        virtual void StartTestCase( TestCaseInfo const& testInfo ) = 0;
        -: 7681:        virtual void EndTestCase( TestCaseInfo const& testInfo, Totals const& totals, std::string const& stdOut, std::string const& stdErr ) = 0;
        -: 7682:        virtual void StartSection( std::string const& sectionName, std::string const& description ) = 0;
        -: 7683:        virtual void EndSection( std::string const& sectionName, Counts const& assertions ) = 0;
        -: 7684:        virtual void NoAssertionsInSection( std::string const& sectionName ) = 0;
        -: 7685:        virtual void NoAssertionsInTestCase( std::string const& testName ) = 0;
        -: 7686:        virtual void Aborted() = 0;
        -: 7687:        virtual void Result( AssertionResult const& result ) = 0;
        -: 7688:    };
        -: 7689:
        -: 7690:    class LegacyReporterAdapter : public SharedImpl<IStreamingReporter>
        -: 7691:    {
        -: 7692:    public:
        -: 7693:        LegacyReporterAdapter( Ptr<IReporter> const& legacyReporter );
        -: 7694:        virtual ~LegacyReporterAdapter();
        -: 7695:
        -: 7696:        virtual ReporterPreferences getPreferences() const;
        -: 7697:        virtual void noMatchingTestCases( std::string const& );
        -: 7698:        virtual void testRunStarting( TestRunInfo const& );
        -: 7699:        virtual void testGroupStarting( GroupInfo const& groupInfo );
        -: 7700:        virtual void testCaseStarting( TestCaseInfo const& testInfo );
        -: 7701:        virtual void sectionStarting( SectionInfo const& sectionInfo );
        -: 7702:        virtual void assertionStarting( AssertionInfo const& );
        -: 7703:        virtual bool assertionEnded( AssertionStats const& assertionStats );
        -: 7704:        virtual void sectionEnded( SectionStats const& sectionStats );
        -: 7705:        virtual void testCaseEnded( TestCaseStats const& testCaseStats );
        -: 7706:        virtual void testGroupEnded( TestGroupStats const& testGroupStats );
        -: 7707:        virtual void testRunEnded( TestRunStats const& testRunStats );
        -: 7708:        virtual void skipTest( TestCaseInfo const& );
        -: 7709:
        -: 7710:    private:
        -: 7711:        Ptr<IReporter> m_legacyReporter;
        -: 7712:    };
        -: 7713:}
        -: 7714:
        -: 7715:namespace Catch
        -: 7716:{
    #####: 7717:    LegacyReporterAdapter::LegacyReporterAdapter( Ptr<IReporter> const& legacyReporter )
    #####: 7718:    :   m_legacyReporter( legacyReporter )
    #####: 7719:    {}
    #####: 7720:    LegacyReporterAdapter::~LegacyReporterAdapter() {}
        -: 7721:
    #####: 7722:    ReporterPreferences LegacyReporterAdapter::getPreferences() const {
    #####: 7723:        ReporterPreferences prefs;
    #####: 7724:        prefs.shouldRedirectStdOut = m_legacyReporter->shouldRedirectStdout();
    #####: 7725:        return prefs;
        -: 7726:    }
        -: 7727:
    #####: 7728:    void LegacyReporterAdapter::noMatchingTestCases( std::string const& ) {}
    #####: 7729:    void LegacyReporterAdapter::testRunStarting( TestRunInfo const& ) {
    #####: 7730:        m_legacyReporter->StartTesting();
    #####: 7731:    }
    #####: 7732:    void LegacyReporterAdapter::testGroupStarting( GroupInfo const& groupInfo ) {
    #####: 7733:        m_legacyReporter->StartGroup( groupInfo.name );
    #####: 7734:    }
    #####: 7735:    void LegacyReporterAdapter::testCaseStarting( TestCaseInfo const& testInfo ) {
    #####: 7736:        m_legacyReporter->StartTestCase( testInfo );
    #####: 7737:    }
    #####: 7738:    void LegacyReporterAdapter::sectionStarting( SectionInfo const& sectionInfo ) {
    #####: 7739:        m_legacyReporter->StartSection( sectionInfo.name, sectionInfo.description );
    #####: 7740:    }
    #####: 7741:    void LegacyReporterAdapter::assertionStarting( AssertionInfo const& ) {
        -: 7742:        // Not on legacy interface
    #####: 7743:    }
        -: 7744:
    #####: 7745:    bool LegacyReporterAdapter::assertionEnded( AssertionStats const& assertionStats ) {
    #####: 7746:        if( assertionStats.assertionResult.getResultType() != ResultWas::Ok ) {
    #####: 7747:            for( std::vector<MessageInfo>::const_iterator it = assertionStats.infoMessages.begin(), itEnd = assertionStats.infoMessages.end();
        -: 7748:                    it != itEnd;
        -: 7749:                    ++it ) {
    #####: 7750:                if( it->type == ResultWas::Info ) {
    #####: 7751:                    ResultBuilder rb( it->macroName.c_str(), it->lineInfo, "", ResultDisposition::Normal );
    #####: 7752:                    rb << it->message;
    #####: 7753:                    rb.setResultType( ResultWas::Info );
    #####: 7754:                    AssertionResult result = rb.build();
    #####: 7755:                    m_legacyReporter->Result( result );
        -: 7756:                }
        -: 7757:            }
        -: 7758:        }
    #####: 7759:        m_legacyReporter->Result( assertionStats.assertionResult );
    #####: 7760:        return true;
        -: 7761:    }
    #####: 7762:    void LegacyReporterAdapter::sectionEnded( SectionStats const& sectionStats ) {
    #####: 7763:        if( sectionStats.missingAssertions )
    #####: 7764:            m_legacyReporter->NoAssertionsInSection( sectionStats.sectionInfo.name );
    #####: 7765:        m_legacyReporter->EndSection( sectionStats.sectionInfo.name, sectionStats.assertions );
    #####: 7766:    }
    #####: 7767:    void LegacyReporterAdapter::testCaseEnded( TestCaseStats const& testCaseStats ) {
    #####: 7768:        m_legacyReporter->EndTestCase
    #####: 7769:            (   testCaseStats.testInfo,
        -: 7770:                testCaseStats.totals,
        -: 7771:                testCaseStats.stdOut,
    #####: 7772:                testCaseStats.stdErr );
    #####: 7773:    }
    #####: 7774:    void LegacyReporterAdapter::testGroupEnded( TestGroupStats const& testGroupStats ) {
    #####: 7775:        if( testGroupStats.aborting )
    #####: 7776:            m_legacyReporter->Aborted();
    #####: 7777:        m_legacyReporter->EndGroup( testGroupStats.groupInfo.name, testGroupStats.totals );
    #####: 7778:    }
    #####: 7779:    void LegacyReporterAdapter::testRunEnded( TestRunStats const& testRunStats ) {
    #####: 7780:        m_legacyReporter->EndTesting( testRunStats.totals );
    #####: 7781:    }
    #####: 7782:    void LegacyReporterAdapter::skipTest( TestCaseInfo const& ) {
    #####: 7783:    }
        -: 7784:}
        -: 7785:
        -: 7786:// #included from: catch_timer.hpp
        -: 7787:
        -: 7788:#ifdef __clang__
        -: 7789:#pragma clang diagnostic push
        -: 7790:#pragma clang diagnostic ignored "-Wc++11-long-long"
        -: 7791:#endif
        -: 7792:
        -: 7793:#ifdef CATCH_PLATFORM_WINDOWS
        -: 7794:#include <windows.h>
        -: 7795:#else
        -: 7796:#include <sys/time.h>
        -: 7797:#endif
        -: 7798:
        -: 7799:namespace Catch {
        -: 7800:
        -: 7801:    namespace {
        -: 7802:#ifdef CATCH_PLATFORM_WINDOWS
        -: 7803:        uint64_t getCurrentTicks() {
        -: 7804:            static uint64_t hz=0, hzo=0;
        -: 7805:            if (!hz) {
        -: 7806:                QueryPerformanceFrequency( reinterpret_cast<LARGE_INTEGER*>( &hz ) );
        -: 7807:                QueryPerformanceCounter( reinterpret_cast<LARGE_INTEGER*>( &hzo ) );
        -: 7808:            }
        -: 7809:            uint64_t t;
        -: 7810:            QueryPerformanceCounter( reinterpret_cast<LARGE_INTEGER*>( &t ) );
        -: 7811:            return ((t-hzo)*1000000)/hz;
        -: 7812:        }
        -: 7813:#else
    #####: 7814:        uint64_t getCurrentTicks() {
        -: 7815:            timeval t;
    #####: 7816:            gettimeofday(&t,CATCH_NULL);
    #####: 7817:            return static_cast<uint64_t>( t.tv_sec ) * 1000000ull + static_cast<uint64_t>( t.tv_usec );
        -: 7818:        }
        -: 7819:#endif
        -: 7820:    }
        -: 7821:
    #####: 7822:    void Timer::start() {
    #####: 7823:        m_ticks = getCurrentTicks();
    #####: 7824:    }
    #####: 7825:    unsigned int Timer::getElapsedMicroseconds() const {
    #####: 7826:        return static_cast<unsigned int>(getCurrentTicks() - m_ticks);
        -: 7827:    }
    #####: 7828:    unsigned int Timer::getElapsedMilliseconds() const {
    #####: 7829:        return static_cast<unsigned int>(getElapsedMicroseconds()/1000);
        -: 7830:    }
    #####: 7831:    double Timer::getElapsedSeconds() const {
    #####: 7832:        return getElapsedMicroseconds()/1000000.0;
        -: 7833:    }
        -: 7834:
        -: 7835:} // namespace Catch
        -: 7836:
        -: 7837:#ifdef __clang__
        -: 7838:#pragma clang diagnostic pop
        -: 7839:#endif
        -: 7840:// #included from: catch_common.hpp
        -: 7841:#define TWOBLUECUBES_CATCH_COMMON_HPP_INCLUDED
        -: 7842:
        -: 7843:namespace Catch {
        -: 7844:
        1: 7845:    bool startsWith( std::string const& s, std::string const& prefix ) {
        1: 7846:        return s.size() >= prefix.size() && s.substr( 0, prefix.size() ) == prefix;
        -: 7847:    }
    #####: 7848:    bool endsWith( std::string const& s, std::string const& suffix ) {
    #####: 7849:        return s.size() >= suffix.size() && s.substr( s.size()-suffix.size(), suffix.size() ) == suffix;
        -: 7850:    }
    #####: 7851:    bool contains( std::string const& s, std::string const& infix ) {
    #####: 7852:        return s.find( infix ) != std::string::npos;
        -: 7853:    }
        1: 7854:    char toLowerCh(char c) {
        1: 7855:        return static_cast<char>( ::tolower( c ) );
        -: 7856:    }
        1: 7857:    void toLowerInPlace( std::string& s ) {
        1: 7858:        std::transform( s.begin(), s.end(), s.begin(), toLowerCh );
        1: 7859:    }
        1: 7860:    std::string toLower( std::string const& s ) {
        1: 7861:        std::string lc = s;
        1: 7862:        toLowerInPlace( lc );
        1: 7863:        return lc;
        -: 7864:    }
    #####: 7865:    std::string trim( std::string const& str ) {
        -: 7866:        static char const* whitespaceChars = "\n\r\t ";
    #####: 7867:        std::string::size_type start = str.find_first_not_of( whitespaceChars );
    #####: 7868:        std::string::size_type end = str.find_last_not_of( whitespaceChars );
        -: 7869:
    #####: 7870:        return start != std::string::npos ? str.substr( start, 1+end-start ) : "";
        -: 7871:    }
        -: 7872:
    #####: 7873:    bool replaceInPlace( std::string& str, std::string const& replaceThis, std::string const& withThis ) {
    #####: 7874:        bool replaced = false;
    #####: 7875:        std::size_t i = str.find( replaceThis );
    #####: 7876:        while( i != std::string::npos ) {
    #####: 7877:            replaced = true;
    #####: 7878:            str = str.substr( 0, i ) + withThis + str.substr( i+replaceThis.size() );
    #####: 7879:            if( i < str.size()-withThis.size() )
    #####: 7880:                i = str.find( replaceThis, i+withThis.size() );
        -: 7881:            else
    #####: 7882:                i = std::string::npos;
        -: 7883:        }
    #####: 7884:        return replaced;
        -: 7885:    }
        -: 7886:
    #####: 7887:    pluralise::pluralise( std::size_t count, std::string const& label )
        -: 7888:    :   m_count( count ),
    #####: 7889:        m_label( label )
    #####: 7890:    {}
        -: 7891:
    #####: 7892:    std::ostream& operator << ( std::ostream& os, pluralise const& pluraliser ) {
    #####: 7893:        os << pluraliser.m_count << " " << pluraliser.m_label;
    #####: 7894:        if( pluraliser.m_count != 1 )
    #####: 7895:            os << "s";
    #####: 7896:        return os;
        -: 7897:    }
        -: 7898:
        2: 7899:    SourceLineInfo::SourceLineInfo() : line( 0 ){}
    #####: 7900:    SourceLineInfo::SourceLineInfo( char const* _file, std::size_t _line )
        -: 7901:    :   file( _file ),
    #####: 7902:        line( _line )
    #####: 7903:    {}
    #####: 7904:    SourceLineInfo::SourceLineInfo( SourceLineInfo const& other )
        -: 7905:    :   file( other.file ),
    #####: 7906:        line( other.line )
    #####: 7907:    {}
    #####: 7908:    bool SourceLineInfo::empty() const {
    #####: 7909:        return file.empty();
        -: 7910:    }
    #####: 7911:    bool SourceLineInfo::operator == ( SourceLineInfo const& other ) const {
    #####: 7912:        return line == other.line && file == other.file;
        -: 7913:    }
    #####: 7914:    bool SourceLineInfo::operator < ( SourceLineInfo const& other ) const {
    #####: 7915:        return line < other.line || ( line == other.line  && file < other.file );
        -: 7916:    }
        -: 7917:
        1: 7918:    void seedRng( IConfig const& config ) {
        1: 7919:        if( config.rngSeed() != 0 )
    #####: 7920:            std::srand( config.rngSeed() );
        1: 7921:    }
    #####: 7922:    unsigned int rngSeed() {
    #####: 7923:        return getCurrentContext().getConfig()->rngSeed();
        -: 7924:    }
        -: 7925:
    #####: 7926:    std::ostream& operator << ( std::ostream& os, SourceLineInfo const& info ) {
        -: 7927:#ifndef __GNUG__
        -: 7928:        os << info.file << "(" << info.line << ")";
        -: 7929:#else
    #####: 7930:        os << info.file << ":" << info.line;
        -: 7931:#endif
    #####: 7932:        return os;
        -: 7933:    }
        -: 7934:
    #####: 7935:    void throwLogicError( std::string const& message, SourceLineInfo const& locationInfo ) {
    #####: 7936:        std::ostringstream oss;
    #####: 7937:        oss << locationInfo << ": Internal Catch error: '" << message << "'";
    #####: 7938:        if( alwaysTrue() )
    #####: 7939:            throw std::logic_error( oss.str() );
    #####: 7940:    }
        -: 7941:}
        -: 7942:
        -: 7943:// #included from: catch_section.hpp
        -: 7944:#define TWOBLUECUBES_CATCH_SECTION_HPP_INCLUDED
        -: 7945:
        -: 7946:namespace Catch {
        -: 7947:
    #####: 7948:    SectionInfo::SectionInfo
        -: 7949:        (   SourceLineInfo const& _lineInfo,
        -: 7950:            std::string const& _name,
        -: 7951:            std::string const& _description )
        -: 7952:    :   name( _name ),
        -: 7953:        description( _description ),
    #####: 7954:        lineInfo( _lineInfo )
    #####: 7955:    {}
        -: 7956:
    #####: 7957:    Section::Section( SectionInfo const& info )
        -: 7958:    :   m_info( info ),
    #####: 7959:        m_sectionIncluded( getResultCapture().sectionStarted( m_info, m_assertions ) )
        -: 7960:    {
    #####: 7961:        m_timer.start();
    #####: 7962:    }
        -: 7963:
    #####: 7964:    Section::~Section() {
    #####: 7965:        if( m_sectionIncluded ) {
    #####: 7966:            SectionEndInfo endInfo( m_info, m_assertions, m_timer.getElapsedSeconds() );
    #####: 7967:            if( std::uncaught_exception() )
    #####: 7968:                getResultCapture().sectionEndedEarly( endInfo );
        -: 7969:            else
    #####: 7970:                getResultCapture().sectionEnded( endInfo );
        -: 7971:        }
    #####: 7972:    }
        -: 7973:
        -: 7974:    // This indicates whether the section should be executed or not
    #####: 7975:    Section::operator bool() const {
    #####: 7976:        return m_sectionIncluded;
        -: 7977:    }
        -: 7978:
        -: 7979:} // end namespace Catch
        -: 7980:
        -: 7981:// #included from: catch_debugger.hpp
        -: 7982:#define TWOBLUECUBES_CATCH_DEBUGGER_HPP_INCLUDED
        -: 7983:
        -: 7984:#include <iostream>
        -: 7985:
        -: 7986:#ifdef CATCH_PLATFORM_MAC
        -: 7987:
        -: 7988:    #include <assert.h>
        -: 7989:    #include <stdbool.h>
        -: 7990:    #include <sys/types.h>
        -: 7991:    #include <unistd.h>
        -: 7992:    #include <sys/sysctl.h>
        -: 7993:
        -: 7994:    namespace Catch{
        -: 7995:
        -: 7996:        // The following function is taken directly from the following technical note:
        -: 7997:        // http://developer.apple.com/library/mac/#qa/qa2004/qa1361.html
        -: 7998:
        -: 7999:        // Returns true if the current process is being debugged (either
        -: 8000:        // running under the debugger or has a debugger attached post facto).
        -: 8001:        bool isDebuggerActive(){
        -: 8002:
        -: 8003:            int                 mib[4];
        -: 8004:            struct kinfo_proc   info;
        -: 8005:            size_t              size;
        -: 8006:
        -: 8007:            // Initialize the flags so that, if sysctl fails for some bizarre
        -: 8008:            // reason, we get a predictable result.
        -: 8009:
        -: 8010:            info.kp_proc.p_flag = 0;
        -: 8011:
        -: 8012:            // Initialize mib, which tells sysctl the info we want, in this case
        -: 8013:            // we're looking for information about a specific process ID.
        -: 8014:
        -: 8015:            mib[0] = CTL_KERN;
        -: 8016:            mib[1] = KERN_PROC;
        -: 8017:            mib[2] = KERN_PROC_PID;
        -: 8018:            mib[3] = getpid();
        -: 8019:
        -: 8020:            // Call sysctl.
        -: 8021:
        -: 8022:            size = sizeof(info);
        -: 8023:            if( sysctl(mib, sizeof(mib) / sizeof(*mib), &info, &size, CATCH_NULL, 0) != 0 ) {
        -: 8024:                Catch::cerr() << "\n** Call to sysctl failed - unable to determine if debugger is active **\n" << std::endl;
        -: 8025:                return false;
        -: 8026:            }
        -: 8027:
        -: 8028:            // We're being debugged if the P_TRACED flag is set.
        -: 8029:
        -: 8030:            return ( (info.kp_proc.p_flag & P_TRACED) != 0 );
        -: 8031:        }
        -: 8032:    } // namespace Catch
        -: 8033:
        -: 8034:#elif defined(_MSC_VER)
        -: 8035:    extern "C" __declspec(dllimport) int __stdcall IsDebuggerPresent();
        -: 8036:    namespace Catch {
        -: 8037:        bool isDebuggerActive() {
        -: 8038:            return IsDebuggerPresent() != 0;
        -: 8039:        }
        -: 8040:    }
        -: 8041:#elif defined(__MINGW32__)
        -: 8042:    extern "C" __declspec(dllimport) int __stdcall IsDebuggerPresent();
        -: 8043:    namespace Catch {
        -: 8044:        bool isDebuggerActive() {
        -: 8045:            return IsDebuggerPresent() != 0;
        -: 8046:        }
        -: 8047:    }
        -: 8048:#else
        -: 8049:    namespace Catch {
        1: 8050:       inline bool isDebuggerActive() { return false; }
        -: 8051:    }
        -: 8052:#endif // Platform
        -: 8053:
        -: 8054:#ifdef CATCH_PLATFORM_WINDOWS
        -: 8055:    extern "C" __declspec(dllimport) void __stdcall OutputDebugStringA( const char* );
        -: 8056:    namespace Catch {
        -: 8057:        void writeToDebugConsole( std::string const& text ) {
        -: 8058:            ::OutputDebugStringA( text.c_str() );
        -: 8059:        }
        -: 8060:    }
        -: 8061:#else
        -: 8062:    namespace Catch {
    #####: 8063:        void writeToDebugConsole( std::string const& text ) {
        -: 8064:            // !TBD: Need a version for Mac/ XCode and other IDEs
    #####: 8065:            Catch::cout() << text;
    #####: 8066:        }
        -: 8067:    }
        -: 8068:#endif // Platform
        -: 8069:
        -: 8070:// #included from: catch_tostring.hpp
        -: 8071:#define TWOBLUECUBES_CATCH_TOSTRING_HPP_INCLUDED
        -: 8072:
        -: 8073:namespace Catch {
        -: 8074:
        -: 8075:namespace Detail {
        -: 8076:
        1: 8077:    const std::string unprintableString = "{?}";
        -: 8078:
        -: 8079:    namespace {
        -: 8080:        const int hexThreshold = 255;
        -: 8081:
        -: 8082:        struct Endianness {
        -: 8083:            enum Arch { Big, Little };
        -: 8084:
    #####: 8085:            static Arch which() {
        -: 8086:                union _{
        -: 8087:                    int asInt;
        -: 8088:                    char asChar[sizeof (int)];
        -: 8089:                } u;
        -: 8090:
    #####: 8091:                u.asInt = 1;
    #####: 8092:                return ( u.asChar[sizeof(int)-1] == 1 ) ? Big : Little;
        -: 8093:            }
        -: 8094:        };
        -: 8095:    }
        -: 8096:
    #####: 8097:    std::string rawMemoryToString( const void *object, std::size_t size )
        -: 8098:    {
        -: 8099:        // Reverse order for little endian architectures
    #####: 8100:        int i = 0, end = static_cast<int>( size ), inc = 1;
    #####: 8101:        if( Endianness::which() == Endianness::Little ) {
    #####: 8102:            i = end-1;
    #####: 8103:            end = inc = -1;
        -: 8104:        }
        -: 8105:
    #####: 8106:        unsigned char const *bytes = static_cast<unsigned char const *>(object);
    #####: 8107:        std::ostringstream os;
    #####: 8108:        os << "0x" << std::setfill('0') << std::hex;
    #####: 8109:        for( ; i != end; i += inc )
    #####: 8110:             os << std::setw(2) << static_cast<unsigned>(bytes[i]);
    #####: 8111:       return os.str();
        -: 8112:    }
        -: 8113:}
        -: 8114:
    #####: 8115:std::string toString( std::string const& value ) {
    #####: 8116:    std::string s = value;
    #####: 8117:    if( getCurrentContext().getConfig()->showInvisibles() ) {
    #####: 8118:        for(size_t i = 0; i < s.size(); ++i ) {
    #####: 8119:            std::string subs;
    #####: 8120:            switch( s[i] ) {
    #####: 8121:            case '\n': subs = "\\n"; break;
    #####: 8122:            case '\t': subs = "\\t"; break;
    #####: 8123:            default: break;
        -: 8124:            }
    #####: 8125:            if( !subs.empty() ) {
    #####: 8126:                s = s.substr( 0, i ) + subs + s.substr( i+1 );
    #####: 8127:                ++i;
        -: 8128:            }
        -: 8129:        }
        -: 8130:    }
    #####: 8131:    return "\"" + s + "\"";
        -: 8132:}
    #####: 8133:std::string toString( std::wstring const& value ) {
        -: 8134:
    #####: 8135:    std::string s;
    #####: 8136:    s.reserve( value.size() );
    #####: 8137:    for(size_t i = 0; i < value.size(); ++i )
    #####: 8138:        s += value[i] <= 0xff ? static_cast<char>( value[i] ) : '?';
    #####: 8139:    return Catch::toString( s );
        -: 8140:}
        -: 8141:
    #####: 8142:std::string toString( const char* const value ) {
    #####: 8143:    return value ? Catch::toString( std::string( value ) ) : std::string( "{null string}" );
        -: 8144:}
        -: 8145:
    #####: 8146:std::string toString( char* const value ) {
    #####: 8147:    return Catch::toString( static_cast<const char*>( value ) );
        -: 8148:}
        -: 8149:
    #####: 8150:std::string toString( const wchar_t* const value )
        -: 8151:{
    #####: 8152:	return value ? Catch::toString( std::wstring(value) ) : std::string( "{null string}" );
        -: 8153:}
        -: 8154:
    #####: 8155:std::string toString( wchar_t* const value )
        -: 8156:{
    #####: 8157:	return Catch::toString( static_cast<const wchar_t*>( value ) );
        -: 8158:}
        -: 8159:
    #####: 8160:std::string toString( int value ) {
    #####: 8161:    std::ostringstream oss;
    #####: 8162:    oss << value;
    #####: 8163:    if( value > Detail::hexThreshold )
    #####: 8164:        oss << " (0x" << std::hex << value << ")";
    #####: 8165:    return oss.str();
        -: 8166:}
        -: 8167:
    #####: 8168:std::string toString( unsigned long value ) {
    #####: 8169:    std::ostringstream oss;
    #####: 8170:    oss << value;
    #####: 8171:    if( value > Detail::hexThreshold )
    #####: 8172:        oss << " (0x" << std::hex << value << ")";
    #####: 8173:    return oss.str();
        -: 8174:}
        -: 8175:
    #####: 8176:std::string toString( unsigned int value ) {
    #####: 8177:    return Catch::toString( static_cast<unsigned long>( value ) );
        -: 8178:}
        -: 8179:
        -: 8180:template<typename T>
    #####: 8181:std::string fpToString( T value, int precision ) {
    #####: 8182:    std::ostringstream oss;
    #####: 8183:    oss << std::setprecision( precision )
    #####: 8184:        << std::fixed
        -: 8185:        << value;
    #####: 8186:    std::string d = oss.str();
    #####: 8187:    std::size_t i = d.find_last_not_of( '0' );
    #####: 8188:    if( i != std::string::npos && i != d.size()-1 ) {
    #####: 8189:        if( d[i] == '.' )
    #####: 8190:            i++;
    #####: 8191:        d = d.substr( 0, i+1 );
        -: 8192:    }
    #####: 8193:    return d;
        -: 8194:}
        -: 8195:
    #####: 8196:std::string toString( const double value ) {
    #####: 8197:    return fpToString( value, 10 );
        -: 8198:}
    #####: 8199:std::string toString( const float value ) {
    #####: 8200:    return fpToString( value, 5 ) + "f";
        -: 8201:}
        -: 8202:
    #####: 8203:std::string toString( bool value ) {
    #####: 8204:    return value ? "true" : "false";
        -: 8205:}
        -: 8206:
    #####: 8207:std::string toString( char value ) {
    #####: 8208:    return value < ' '
        -: 8209:        ? toString( static_cast<unsigned int>( value ) )
    #####: 8210:        : Detail::makeString( value );
        -: 8211:}
        -: 8212:
    #####: 8213:std::string toString( signed char value ) {
    #####: 8214:    return toString( static_cast<char>( value ) );
        -: 8215:}
        -: 8216:
    #####: 8217:std::string toString( unsigned char value ) {
    #####: 8218:    return toString( static_cast<char>( value ) );
        -: 8219:}
        -: 8220:
        -: 8221:#ifdef CATCH_CONFIG_CPP11_LONG_LONG
    #####: 8222:std::string toString( long long value ) {
    #####: 8223:    std::ostringstream oss;
    #####: 8224:    oss << value;
    #####: 8225:    if( value > Detail::hexThreshold )
    #####: 8226:        oss << " (0x" << std::hex << value << ")";
    #####: 8227:    return oss.str();
        -: 8228:}
    #####: 8229:std::string toString( unsigned long long value ) {
    #####: 8230:    std::ostringstream oss;
    #####: 8231:    oss << value;
    #####: 8232:    if( value > Detail::hexThreshold )
    #####: 8233:        oss << " (0x" << std::hex << value << ")";
    #####: 8234:    return oss.str();
        -: 8235:}
        -: 8236:#endif
        -: 8237:
        -: 8238:#ifdef CATCH_CONFIG_CPP11_NULLPTR
    #####: 8239:std::string toString( std::nullptr_t ) {
    #####: 8240:    return "nullptr";
        -: 8241:}
        -: 8242:#endif
        -: 8243:
        -: 8244:#ifdef __OBJC__
        -: 8245:    std::string toString( NSString const * const& nsstring ) {
        -: 8246:        if( !nsstring )
        -: 8247:            return "nil";
        -: 8248:        return "@" + toString([nsstring UTF8String]);
        -: 8249:    }
        -: 8250:    std::string toString( NSString * CATCH_ARC_STRONG const& nsstring ) {
        -: 8251:        if( !nsstring )
        -: 8252:            return "nil";
        -: 8253:        return "@" + toString([nsstring UTF8String]);
        -: 8254:    }
        -: 8255:    std::string toString( NSObject* const& nsObject ) {
        -: 8256:        return toString( [nsObject description] );
        -: 8257:    }
        -: 8258:#endif
        -: 8259:
        -: 8260:} // end namespace Catch
        -: 8261:
        -: 8262:// #included from: catch_result_builder.hpp
        -: 8263:#define TWOBLUECUBES_CATCH_RESULT_BUILDER_HPP_INCLUDED
        -: 8264:
        -: 8265:namespace Catch {
        -: 8266:
    #####: 8267:    std::string capturedExpressionWithSecondArgument( std::string const& capturedExpression, std::string const& secondArg ) {
    #####: 8268:        return secondArg.empty() || secondArg == "\"\""
        -: 8269:            ? capturedExpression
    #####: 8270:            : capturedExpression + ", " + secondArg;
        -: 8271:    }
    #####: 8272:    ResultBuilder::ResultBuilder(   char const* macroName,
        -: 8273:                                    SourceLineInfo const& lineInfo,
        -: 8274:                                    char const* capturedExpression,
        -: 8275:                                    ResultDisposition::Flags resultDisposition,
        -: 8276:                                    char const* secondArg )
    #####: 8277:    :   m_assertionInfo( macroName, lineInfo, capturedExpressionWithSecondArgument( capturedExpression, secondArg ), resultDisposition ),
        -: 8278:        m_shouldDebugBreak( false ),
    #####: 8279:        m_shouldThrow( false )
    #####: 8280:    {}
        -: 8281:
    #####: 8282:    ResultBuilder& ResultBuilder::setResultType( ResultWas::OfType result ) {
    #####: 8283:        m_data.resultType = result;
    #####: 8284:        return *this;
        -: 8285:    }
    #####: 8286:    ResultBuilder& ResultBuilder::setResultType( bool result ) {
    #####: 8287:        m_data.resultType = result ? ResultWas::Ok : ResultWas::ExpressionFailed;
    #####: 8288:        return *this;
        -: 8289:    }
    #####: 8290:    ResultBuilder& ResultBuilder::setLhs( std::string const& lhs ) {
    #####: 8291:        m_exprComponents.lhs = lhs;
    #####: 8292:        return *this;
        -: 8293:    }
    #####: 8294:    ResultBuilder& ResultBuilder::setRhs( std::string const& rhs ) {
    #####: 8295:        m_exprComponents.rhs = rhs;
    #####: 8296:        return *this;
        -: 8297:    }
    #####: 8298:    ResultBuilder& ResultBuilder::setOp( std::string const& op ) {
    #####: 8299:        m_exprComponents.op = op;
    #####: 8300:        return *this;
        -: 8301:    }
        -: 8302:
    #####: 8303:    void ResultBuilder::endExpression() {
    #####: 8304:        m_exprComponents.testFalse = isFalseTest( m_assertionInfo.resultDisposition );
    #####: 8305:        captureExpression();
    #####: 8306:    }
        -: 8307:
    #####: 8308:    void ResultBuilder::useActiveException( ResultDisposition::Flags resultDisposition ) {
    #####: 8309:        m_assertionInfo.resultDisposition = resultDisposition;
    #####: 8310:        m_stream.oss << Catch::translateActiveException();
    #####: 8311:        captureResult( ResultWas::ThrewException );
    #####: 8312:    }
        -: 8313:
    #####: 8314:    void ResultBuilder::captureResult( ResultWas::OfType resultType ) {
    #####: 8315:        setResultType( resultType );
    #####: 8316:        captureExpression();
    #####: 8317:    }
    #####: 8318:    void ResultBuilder::captureExpectedException( std::string const& expectedMessage ) {
    #####: 8319:        if( expectedMessage.empty() )
    #####: 8320:            captureExpectedException( Matchers::Impl::Generic::AllOf<std::string>() );
        -: 8321:        else
    #####: 8322:            captureExpectedException( Matchers::Equals( expectedMessage ) );
    #####: 8323:    }
        -: 8324:
    #####: 8325:    void ResultBuilder::captureExpectedException( Matchers::Impl::Matcher<std::string> const& matcher ) {
        -: 8326:
    #####: 8327:        assert( m_exprComponents.testFalse == false );
    #####: 8328:        AssertionResultData data = m_data;
    #####: 8329:        data.resultType = ResultWas::Ok;
    #####: 8330:        data.reconstructedExpression = m_assertionInfo.capturedExpression;
        -: 8331:
    #####: 8332:        std::string actualMessage = Catch::translateActiveException();
    #####: 8333:        if( !matcher.match( actualMessage ) ) {
    #####: 8334:            data.resultType = ResultWas::ExpressionFailed;
    #####: 8335:            data.reconstructedExpression = actualMessage;
        -: 8336:        }
    #####: 8337:        AssertionResult result( m_assertionInfo, data );
    #####: 8338:        handleResult( result );
    #####: 8339:    }
        -: 8340:
    #####: 8341:    void ResultBuilder::captureExpression() {
    #####: 8342:        AssertionResult result = build();
    #####: 8343:        handleResult( result );
    #####: 8344:    }
    #####: 8345:    void ResultBuilder::handleResult( AssertionResult const& result )
        -: 8346:    {
    #####: 8347:        getResultCapture().assertionEnded( result );
        -: 8348:
    #####: 8349:        if( !result.isOk() ) {
    #####: 8350:            if( getCurrentContext().getConfig()->shouldDebugBreak() )
    #####: 8351:                m_shouldDebugBreak = true;
    #####: 8352:            if( getCurrentContext().getRunner()->aborting() || (m_assertionInfo.resultDisposition & ResultDisposition::Normal) )
    #####: 8353:                m_shouldThrow = true;
        -: 8354:        }
    #####: 8355:    }
    #####: 8356:    void ResultBuilder::react() {
    #####: 8357:        if( m_shouldThrow )
    #####: 8358:            throw Catch::TestFailureException();
    #####: 8359:    }
        -: 8360:
    #####: 8361:    bool ResultBuilder::shouldDebugBreak() const { return m_shouldDebugBreak; }
    #####: 8362:    bool ResultBuilder::allowThrows() const { return getCurrentContext().getConfig()->allowThrows(); }
        -: 8363:
    #####: 8364:    AssertionResult ResultBuilder::build() const
        -: 8365:    {
    #####: 8366:        assert( m_data.resultType != ResultWas::Unknown );
        -: 8367:
    #####: 8368:        AssertionResultData data = m_data;
        -: 8369:
        -: 8370:        // Flip bool results if testFalse is set
    #####: 8371:        if( m_exprComponents.testFalse ) {
    #####: 8372:            if( data.resultType == ResultWas::Ok )
    #####: 8373:                data.resultType = ResultWas::ExpressionFailed;
    #####: 8374:            else if( data.resultType == ResultWas::ExpressionFailed )
    #####: 8375:                data.resultType = ResultWas::Ok;
        -: 8376:        }
        -: 8377:
    #####: 8378:        data.message = m_stream.oss.str();
    #####: 8379:        data.reconstructedExpression = reconstructExpression();
    #####: 8380:        if( m_exprComponents.testFalse ) {
    #####: 8381:            if( m_exprComponents.op == "" )
    #####: 8382:                data.reconstructedExpression = "!" + data.reconstructedExpression;
        -: 8383:            else
    #####: 8384:                data.reconstructedExpression = "!(" + data.reconstructedExpression + ")";
        -: 8385:        }
    #####: 8386:        return AssertionResult( m_assertionInfo, data );
        -: 8387:    }
    #####: 8388:    std::string ResultBuilder::reconstructExpression() const {
    #####: 8389:        if( m_exprComponents.op == "" )
    #####: 8390:            return m_exprComponents.lhs.empty() ? m_assertionInfo.capturedExpression : m_exprComponents.lhs;
    #####: 8391:        else if( m_exprComponents.op == "matches" )
    #####: 8392:            return m_exprComponents.lhs + " " + m_exprComponents.rhs;
    #####: 8393:        else if( m_exprComponents.op != "!" ) {
    #####: 8394:            if( m_exprComponents.lhs.size() + m_exprComponents.rhs.size() < 40 &&
    #####: 8395:                m_exprComponents.lhs.find("\n") == std::string::npos &&
    #####: 8396:                m_exprComponents.rhs.find("\n") == std::string::npos )
    #####: 8397:                return m_exprComponents.lhs + " " + m_exprComponents.op + " " + m_exprComponents.rhs;
        -: 8398:            else
    #####: 8399:                return m_exprComponents.lhs + "\n" + m_exprComponents.op + "\n" + m_exprComponents.rhs;
        -: 8400:        }
        -: 8401:        else
    #####: 8402:            return "{can't expand - use " + m_assertionInfo.macroName + "_FALSE( " + m_assertionInfo.capturedExpression.substr(1) + " ) instead of " + m_assertionInfo.macroName + "( " + m_assertionInfo.capturedExpression + " ) for better diagnostics}";
        -: 8403:    }
        -: 8404:
        -: 8405:} // end namespace Catch
        -: 8406:
        -: 8407:// #included from: catch_tag_alias_registry.hpp
        -: 8408:#define TWOBLUECUBES_CATCH_TAG_ALIAS_REGISTRY_HPP_INCLUDED
        -: 8409:
        -: 8410:// #included from: catch_tag_alias_registry.h
        -: 8411:#define TWOBLUECUBES_CATCH_TAG_ALIAS_REGISTRY_H_INCLUDED
        -: 8412:
        -: 8413:#include <map>
        -: 8414:
        -: 8415:namespace Catch {
        -: 8416:
        1: 8417:    class TagAliasRegistry : public ITagAliasRegistry {
        -: 8418:    public:
        -: 8419:        virtual ~TagAliasRegistry();
        -: 8420:        virtual Option<TagAlias> find( std::string const& alias ) const;
        -: 8421:        virtual std::string expandAliases( std::string const& unexpandedTestSpec ) const;
        -: 8422:        void add( char const* alias, char const* tag, SourceLineInfo const& lineInfo );
        -: 8423:        static TagAliasRegistry& get();
        -: 8424:
        -: 8425:    private:
        -: 8426:        std::map<std::string, TagAlias> m_registry;
        -: 8427:    };
        -: 8428:
        -: 8429:} // end namespace Catch
        -: 8430:
        -: 8431:#include <map>
        -: 8432:#include <iostream>
        -: 8433:
        -: 8434:namespace Catch {
        -: 8435:
        1: 8436:    TagAliasRegistry::~TagAliasRegistry() {}
        -: 8437:
    #####: 8438:    Option<TagAlias> TagAliasRegistry::find( std::string const& alias ) const {
    #####: 8439:        std::map<std::string, TagAlias>::const_iterator it = m_registry.find( alias );
    #####: 8440:        if( it != m_registry.end() )
    #####: 8441:            return it->second;
        -: 8442:        else
    #####: 8443:            return Option<TagAlias>();
        -: 8444:    }
        -: 8445:
        1: 8446:    std::string TagAliasRegistry::expandAliases( std::string const& unexpandedTestSpec ) const {
        1: 8447:        std::string expandedTestSpec = unexpandedTestSpec;
        1: 8448:        for( std::map<std::string, TagAlias>::const_iterator it = m_registry.begin(), itEnd = m_registry.end();
        -: 8449:                it != itEnd;
        -: 8450:                ++it ) {
    #####: 8451:            std::size_t pos = expandedTestSpec.find( it->first );
    #####: 8452:            if( pos != std::string::npos ) {
    #####: 8453:                expandedTestSpec =  expandedTestSpec.substr( 0, pos ) +
    #####: 8454:                                    it->second.tag +
    #####: 8455:                                    expandedTestSpec.substr( pos + it->first.size() );
        -: 8456:            }
        -: 8457:        }
        1: 8458:        return expandedTestSpec;
        -: 8459:    }
        -: 8460:
    #####: 8461:    void TagAliasRegistry::add( char const* alias, char const* tag, SourceLineInfo const& lineInfo ) {
        -: 8462:
    #####: 8463:        if( !startsWith( alias, "[@" ) || !endsWith( alias, "]" ) ) {
    #####: 8464:            std::ostringstream oss;
    #####: 8465:            oss << "error: tag alias, \"" << alias << "\" is not of the form [@alias name].\n" << lineInfo;
    #####: 8466:            throw std::domain_error( oss.str().c_str() );
        -: 8467:        }
    #####: 8468:        if( !m_registry.insert( std::make_pair( alias, TagAlias( tag, lineInfo ) ) ).second ) {
    #####: 8469:            std::ostringstream oss;
    #####: 8470:            oss << "error: tag alias, \"" << alias << "\" already registered.\n"
    #####: 8471:                << "\tFirst seen at " << find(alias)->lineInfo << "\n"
    #####: 8472:                << "\tRedefined at " << lineInfo;
    #####: 8473:            throw std::domain_error( oss.str().c_str() );
        -: 8474:        }
    #####: 8475:    }
        -: 8476:
        1: 8477:    TagAliasRegistry& TagAliasRegistry::get() {
        1: 8478:        static TagAliasRegistry instance;
        1: 8479:        return instance;
        -: 8480:
        -: 8481:    }
        -: 8482:
        1: 8483:    ITagAliasRegistry::~ITagAliasRegistry() {}
        1: 8484:    ITagAliasRegistry const& ITagAliasRegistry::get() { return TagAliasRegistry::get(); }
        -: 8485:
    #####: 8486:    RegistrarForTagAliases::RegistrarForTagAliases( char const* alias, char const* tag, SourceLineInfo const& lineInfo ) {
        -: 8487:        try {
    #####: 8488:            TagAliasRegistry::get().add( alias, tag, lineInfo );
        -: 8489:        }
    =====: 8490:        catch( std::exception& ex ) {
    =====: 8491:            Colour colourGuard( Colour::Red );
    =====: 8492:            Catch::cerr() << ex.what() << std::endl;
    =====: 8493:            exit(1);
        -: 8494:        }
    #####: 8495:    }
        -: 8496:
        -: 8497:} // end namespace Catch
        -: 8498:
        -: 8499:// #included from: ../reporters/catch_reporter_multi.hpp
        -: 8500:#define TWOBLUECUBES_CATCH_REPORTER_MULTI_HPP_INCLUDED
        -: 8501:
        -: 8502:namespace Catch {
        -: 8503:
    #####: 8504:class MultipleReporters : public SharedImpl<IStreamingReporter> {
        -: 8505:    typedef std::vector<Ptr<IStreamingReporter> > Reporters;
        -: 8506:    Reporters m_reporters;
        -: 8507:
        -: 8508:public:
    #####: 8509:    void add( Ptr<IStreamingReporter> const& reporter ) {
    #####: 8510:        m_reporters.push_back( reporter );
    #####: 8511:    }
        -: 8512:
        -: 8513:public: // IStreamingReporter
        -: 8514:
    #####: 8515:    virtual ReporterPreferences getPreferences() const CATCH_OVERRIDE {
    #####: 8516:        return m_reporters[0]->getPreferences();
        -: 8517:    }
        -: 8518:
    #####: 8519:    virtual void noMatchingTestCases( std::string const& spec ) CATCH_OVERRIDE {
    #####: 8520:        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
        -: 8521:                it != itEnd;
        -: 8522:                ++it )
    #####: 8523:            (*it)->noMatchingTestCases( spec );
    #####: 8524:    }
        -: 8525:
    #####: 8526:    virtual void testRunStarting( TestRunInfo const& testRunInfo ) CATCH_OVERRIDE {
    #####: 8527:        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
        -: 8528:                it != itEnd;
        -: 8529:                ++it )
    #####: 8530:            (*it)->testRunStarting( testRunInfo );
    #####: 8531:    }
        -: 8532:
    #####: 8533:    virtual void testGroupStarting( GroupInfo const& groupInfo ) CATCH_OVERRIDE {
    #####: 8534:        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
        -: 8535:                it != itEnd;
        -: 8536:                ++it )
    #####: 8537:            (*it)->testGroupStarting( groupInfo );
    #####: 8538:    }
        -: 8539:
    #####: 8540:    virtual void testCaseStarting( TestCaseInfo const& testInfo ) CATCH_OVERRIDE {
    #####: 8541:        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
        -: 8542:                it != itEnd;
        -: 8543:                ++it )
    #####: 8544:            (*it)->testCaseStarting( testInfo );
    #####: 8545:    }
        -: 8546:
    #####: 8547:    virtual void sectionStarting( SectionInfo const& sectionInfo ) CATCH_OVERRIDE {
    #####: 8548:        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
        -: 8549:                it != itEnd;
        -: 8550:                ++it )
    #####: 8551:            (*it)->sectionStarting( sectionInfo );
    #####: 8552:    }
        -: 8553:
    #####: 8554:    virtual void assertionStarting( AssertionInfo const& assertionInfo ) CATCH_OVERRIDE {
    #####: 8555:        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
        -: 8556:                it != itEnd;
        -: 8557:                ++it )
    #####: 8558:            (*it)->assertionStarting( assertionInfo );
    #####: 8559:    }
        -: 8560:
        -: 8561:    // The return value indicates if the messages buffer should be cleared:
    #####: 8562:    virtual bool assertionEnded( AssertionStats const& assertionStats ) CATCH_OVERRIDE {
    #####: 8563:        bool clearBuffer = false;
    #####: 8564:        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
        -: 8565:                it != itEnd;
        -: 8566:                ++it )
    #####: 8567:            clearBuffer |= (*it)->assertionEnded( assertionStats );
    #####: 8568:        return clearBuffer;
        -: 8569:    }
        -: 8570:
    #####: 8571:    virtual void sectionEnded( SectionStats const& sectionStats ) CATCH_OVERRIDE {
    #####: 8572:        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
        -: 8573:                it != itEnd;
        -: 8574:                ++it )
    #####: 8575:            (*it)->sectionEnded( sectionStats );
    #####: 8576:    }
        -: 8577:
    #####: 8578:    virtual void testCaseEnded( TestCaseStats const& testCaseStats ) CATCH_OVERRIDE {
    #####: 8579:        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
        -: 8580:                it != itEnd;
        -: 8581:                ++it )
    #####: 8582:            (*it)->testCaseEnded( testCaseStats );
    #####: 8583:    }
        -: 8584:
    #####: 8585:    virtual void testGroupEnded( TestGroupStats const& testGroupStats ) CATCH_OVERRIDE {
    #####: 8586:        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
        -: 8587:                it != itEnd;
        -: 8588:                ++it )
    #####: 8589:            (*it)->testGroupEnded( testGroupStats );
    #####: 8590:    }
        -: 8591:
    #####: 8592:    virtual void testRunEnded( TestRunStats const& testRunStats ) CATCH_OVERRIDE {
    #####: 8593:        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
        -: 8594:                it != itEnd;
        -: 8595:                ++it )
    #####: 8596:            (*it)->testRunEnded( testRunStats );
    #####: 8597:    }
        -: 8598:
    #####: 8599:    virtual void skipTest( TestCaseInfo const& testInfo ) CATCH_OVERRIDE {
    #####: 8600:        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
        -: 8601:                it != itEnd;
        -: 8602:                ++it )
    #####: 8603:            (*it)->skipTest( testInfo );
    #####: 8604:    }
        -: 8605:
    #####: 8606:    virtual MultipleReporters* tryAsMulti() CATCH_OVERRIDE {
    #####: 8607:        return this;
        -: 8608:    }
        -: 8609:
        -: 8610:};
        -: 8611:
        1: 8612:Ptr<IStreamingReporter> addReporter( Ptr<IStreamingReporter> const& existingReporter, Ptr<IStreamingReporter> const& additionalReporter ) {
        1: 8613:    Ptr<IStreamingReporter> resultingReporter;
        -: 8614:
        1: 8615:    if( existingReporter ) {
    #####: 8616:        MultipleReporters* multi = existingReporter->tryAsMulti();
    #####: 8617:        if( !multi ) {
    #####: 8618:            multi = new MultipleReporters;
    #####: 8619:            resultingReporter = Ptr<IStreamingReporter>( multi );
    #####: 8620:            if( existingReporter )
    #####: 8621:                multi->add( existingReporter );
        -: 8622:        }
        -: 8623:        else
    #####: 8624:            resultingReporter = existingReporter;
    #####: 8625:        multi->add( additionalReporter );
        -: 8626:    }
        -: 8627:    else
        1: 8628:        resultingReporter = additionalReporter;
        -: 8629:
        1: 8630:    return resultingReporter;
        -: 8631:}
        -: 8632:
        -: 8633:} // end namespace Catch
        -: 8634:
        -: 8635:// #included from: ../reporters/catch_reporter_xml.hpp
        -: 8636:#define TWOBLUECUBES_CATCH_REPORTER_XML_HPP_INCLUDED
        -: 8637:
        -: 8638:// #included from: catch_reporter_bases.hpp
        -: 8639:#define TWOBLUECUBES_CATCH_REPORTER_BASES_HPP_INCLUDED
        -: 8640:
        -: 8641:#include <cstring>
        -: 8642:
        -: 8643:namespace Catch {
        -: 8644:
        -: 8645:    struct StreamingReporterBase : SharedImpl<IStreamingReporter> {
        -: 8646:
        1: 8647:        StreamingReporterBase( ReporterConfig const& _config )
        -: 8648:        :   m_config( _config.fullConfig() ),
        1: 8649:            stream( _config.stream() )
        -: 8650:        {
        1: 8651:            m_reporterPrefs.shouldRedirectStdOut = false;
        1: 8652:        }
        -: 8653:
    #####: 8654:        virtual ReporterPreferences getPreferences() const CATCH_OVERRIDE {
    #####: 8655:            return m_reporterPrefs;
        -: 8656:        }
        -: 8657:
        -: 8658:        virtual ~StreamingReporterBase() CATCH_OVERRIDE;
        -: 8659:
    #####: 8660:        virtual void noMatchingTestCases( std::string const& ) CATCH_OVERRIDE {}
        -: 8661:
        1: 8662:        virtual void testRunStarting( TestRunInfo const& _testRunInfo ) CATCH_OVERRIDE {
        1: 8663:            currentTestRunInfo = _testRunInfo;
        1: 8664:        }
        1: 8665:        virtual void testGroupStarting( GroupInfo const& _groupInfo ) CATCH_OVERRIDE {
        1: 8666:            currentGroupInfo = _groupInfo;
        1: 8667:        }
        -: 8668:
    #####: 8669:        virtual void testCaseStarting( TestCaseInfo const& _testInfo ) CATCH_OVERRIDE {
    #####: 8670:            currentTestCaseInfo = _testInfo;
    #####: 8671:        }
    #####: 8672:        virtual void sectionStarting( SectionInfo const& _sectionInfo ) CATCH_OVERRIDE {
    #####: 8673:            m_sectionStack.push_back( _sectionInfo );
    #####: 8674:        }
        -: 8675:
    #####: 8676:        virtual void sectionEnded( SectionStats const& /* _sectionStats */ ) CATCH_OVERRIDE {
    #####: 8677:            m_sectionStack.pop_back();
    #####: 8678:        }
    #####: 8679:        virtual void testCaseEnded( TestCaseStats const& /* _testCaseStats */ ) CATCH_OVERRIDE {
    #####: 8680:            currentTestCaseInfo.reset();
    #####: 8681:        }
        1: 8682:        virtual void testGroupEnded( TestGroupStats const& /* _testGroupStats */ ) CATCH_OVERRIDE {
        1: 8683:            currentGroupInfo.reset();
        1: 8684:        }
        1: 8685:        virtual void testRunEnded( TestRunStats const& /* _testRunStats */ ) CATCH_OVERRIDE {
        1: 8686:            currentTestCaseInfo.reset();
        1: 8687:            currentGroupInfo.reset();
        1: 8688:            currentTestRunInfo.reset();
        1: 8689:        }
        -: 8690:
    #####: 8691:        virtual void skipTest( TestCaseInfo const& ) CATCH_OVERRIDE {
        -: 8692:            // Don't do anything with this by default.
        -: 8693:            // It can optionally be overridden in the derived class.
    #####: 8694:        }
        -: 8695:
        -: 8696:        Ptr<IConfig const> m_config;
        -: 8697:        std::ostream& stream;
        -: 8698:
        -: 8699:        LazyStat<TestRunInfo> currentTestRunInfo;
        -: 8700:        LazyStat<GroupInfo> currentGroupInfo;
        -: 8701:        LazyStat<TestCaseInfo> currentTestCaseInfo;
        -: 8702:
        -: 8703:        std::vector<SectionInfo> m_sectionStack;
        -: 8704:        ReporterPreferences m_reporterPrefs;
        -: 8705:    };
        -: 8706:
        -: 8707:    struct CumulativeReporterBase : SharedImpl<IStreamingReporter> {
        -: 8708:        template<typename T, typename ChildNodeT>
        -: 8709:        struct Node : SharedImpl<> {
    #####: 8710:            explicit Node( T const& _value ) : value( _value ) {}
    #####: 8711:            virtual ~Node() {}
        -: 8712:
        -: 8713:            typedef std::vector<Ptr<ChildNodeT> > ChildNodes;
        -: 8714:            T value;
        -: 8715:            ChildNodes children;
        -: 8716:        };
        -: 8717:        struct SectionNode : SharedImpl<> {
    #####: 8718:            explicit SectionNode( SectionStats const& _stats ) : stats( _stats ) {}
        -: 8719:            virtual ~SectionNode();
        -: 8720:
        -: 8721:            bool operator == ( SectionNode const& other ) const {
        -: 8722:                return stats.sectionInfo.lineInfo == other.stats.sectionInfo.lineInfo;
        -: 8723:            }
        -: 8724:            bool operator == ( Ptr<SectionNode> const& other ) const {
        -: 8725:                return operator==( *other );
        -: 8726:            }
        -: 8727:
        -: 8728:            SectionStats stats;
        -: 8729:            typedef std::vector<Ptr<SectionNode> > ChildSections;
        -: 8730:            typedef std::vector<AssertionStats> Assertions;
        -: 8731:            ChildSections childSections;
        -: 8732:            Assertions assertions;
        -: 8733:            std::string stdOut;
        -: 8734:            std::string stdErr;
        -: 8735:        };
        -: 8736:
        -: 8737:        struct BySectionInfo {
    #####: 8738:            BySectionInfo( SectionInfo const& other ) : m_other( other ) {}
    #####: 8739:			BySectionInfo( BySectionInfo const& other ) : m_other( other.m_other ) {}
    #####: 8740:            bool operator() ( Ptr<SectionNode> const& node ) const {
    #####: 8741:                return node->stats.sectionInfo.lineInfo == m_other.lineInfo;
        -: 8742:            }
        -: 8743:        private:
        -: 8744:			void operator=( BySectionInfo const& );
        -: 8745:            SectionInfo const& m_other;
        -: 8746:        };
        -: 8747:
        -: 8748:        typedef Node<TestCaseStats, SectionNode> TestCaseNode;
        -: 8749:        typedef Node<TestGroupStats, TestCaseNode> TestGroupNode;
        -: 8750:        typedef Node<TestRunStats, TestGroupNode> TestRunNode;
        -: 8751:
    #####: 8752:        CumulativeReporterBase( ReporterConfig const& _config )
        -: 8753:        :   m_config( _config.fullConfig() ),
    #####: 8754:            stream( _config.stream() )
        -: 8755:        {
    #####: 8756:            m_reporterPrefs.shouldRedirectStdOut = false;
    #####: 8757:        }
        -: 8758:        ~CumulativeReporterBase();
        -: 8759:
    #####: 8760:        virtual ReporterPreferences getPreferences() const CATCH_OVERRIDE {
    #####: 8761:            return m_reporterPrefs;
        -: 8762:        }
        -: 8763:
    #####: 8764:        virtual void testRunStarting( TestRunInfo const& ) CATCH_OVERRIDE {}
    #####: 8765:        virtual void testGroupStarting( GroupInfo const& ) CATCH_OVERRIDE {}
        -: 8766:
    #####: 8767:        virtual void testCaseStarting( TestCaseInfo const& ) CATCH_OVERRIDE {}
        -: 8768:
    #####: 8769:        virtual void sectionStarting( SectionInfo const& sectionInfo ) CATCH_OVERRIDE {
    #####: 8770:            SectionStats incompleteStats( sectionInfo, Counts(), 0, false );
    #####: 8771:            Ptr<SectionNode> node;
    #####: 8772:            if( m_sectionStack.empty() ) {
    #####: 8773:                if( !m_rootSection )
    #####: 8774:                    m_rootSection = new SectionNode( incompleteStats );
    #####: 8775:                node = m_rootSection;
        -: 8776:            }
        -: 8777:            else {
    #####: 8778:                SectionNode& parentNode = *m_sectionStack.back();
        -: 8779:                SectionNode::ChildSections::const_iterator it =
    #####: 8780:                    std::find_if(   parentNode.childSections.begin(),
        -: 8781:                                    parentNode.childSections.end(),
    #####: 8782:                                    BySectionInfo( sectionInfo ) );
    #####: 8783:                if( it == parentNode.childSections.end() ) {
    #####: 8784:                    node = new SectionNode( incompleteStats );
    #####: 8785:                    parentNode.childSections.push_back( node );
        -: 8786:                }
        -: 8787:                else
    #####: 8788:                    node = *it;
        -: 8789:            }
    #####: 8790:            m_sectionStack.push_back( node );
    #####: 8791:            m_deepestSection = node;
    #####: 8792:        }
        -: 8793:
    #####: 8794:        virtual void assertionStarting( AssertionInfo const& ) CATCH_OVERRIDE {}
        -: 8795:
    #####: 8796:        virtual bool assertionEnded( AssertionStats const& assertionStats ) CATCH_OVERRIDE {
    #####: 8797:            assert( !m_sectionStack.empty() );
    #####: 8798:            SectionNode& sectionNode = *m_sectionStack.back();
    #####: 8799:            sectionNode.assertions.push_back( assertionStats );
    #####: 8800:            return true;
        -: 8801:        }
    #####: 8802:        virtual void sectionEnded( SectionStats const& sectionStats ) CATCH_OVERRIDE {
    #####: 8803:            assert( !m_sectionStack.empty() );
    #####: 8804:            SectionNode& node = *m_sectionStack.back();
    #####: 8805:            node.stats = sectionStats;
    #####: 8806:            m_sectionStack.pop_back();
    #####: 8807:        }
    #####: 8808:        virtual void testCaseEnded( TestCaseStats const& testCaseStats ) CATCH_OVERRIDE {
    #####: 8809:            Ptr<TestCaseNode> node = new TestCaseNode( testCaseStats );
    #####: 8810:            assert( m_sectionStack.size() == 0 );
    #####: 8811:            node->children.push_back( m_rootSection );
    #####: 8812:            m_testCases.push_back( node );
    #####: 8813:            m_rootSection.reset();
        -: 8814:
    #####: 8815:            assert( m_deepestSection );
    #####: 8816:            m_deepestSection->stdOut = testCaseStats.stdOut;
    #####: 8817:            m_deepestSection->stdErr = testCaseStats.stdErr;
    #####: 8818:        }
    #####: 8819:        virtual void testGroupEnded( TestGroupStats const& testGroupStats ) CATCH_OVERRIDE {
    #####: 8820:            Ptr<TestGroupNode> node = new TestGroupNode( testGroupStats );
    #####: 8821:            node->children.swap( m_testCases );
    #####: 8822:            m_testGroups.push_back( node );
    #####: 8823:        }
    #####: 8824:        virtual void testRunEnded( TestRunStats const& testRunStats ) CATCH_OVERRIDE {
    #####: 8825:            Ptr<TestRunNode> node = new TestRunNode( testRunStats );
    #####: 8826:            node->children.swap( m_testGroups );
    #####: 8827:            m_testRuns.push_back( node );
    #####: 8828:            testRunEndedCumulative();
    #####: 8829:        }
        -: 8830:        virtual void testRunEndedCumulative() = 0;
        -: 8831:
    #####: 8832:        virtual void skipTest( TestCaseInfo const& ) CATCH_OVERRIDE {}
        -: 8833:
        -: 8834:        Ptr<IConfig const> m_config;
        -: 8835:        std::ostream& stream;
        -: 8836:        std::vector<AssertionStats> m_assertions;
        -: 8837:        std::vector<std::vector<Ptr<SectionNode> > > m_sections;
        -: 8838:        std::vector<Ptr<TestCaseNode> > m_testCases;
        -: 8839:        std::vector<Ptr<TestGroupNode> > m_testGroups;
        -: 8840:
        -: 8841:        std::vector<Ptr<TestRunNode> > m_testRuns;
        -: 8842:
        -: 8843:        Ptr<SectionNode> m_rootSection;
        -: 8844:        Ptr<SectionNode> m_deepestSection;
        -: 8845:        std::vector<Ptr<SectionNode> > m_sectionStack;
        -: 8846:        ReporterPreferences m_reporterPrefs;
        -: 8847:
        -: 8848:    };
        -: 8849:
        -: 8850:    template<char C>
    #####: 8851:    char const* getLineOfChars() {
        -: 8852:        static char line[CATCH_CONFIG_CONSOLE_WIDTH] = {0};
    #####: 8853:        if( !*line ) {
    #####: 8854:            memset( line, C, CATCH_CONFIG_CONSOLE_WIDTH-1 );
    #####: 8855:            line[CATCH_CONFIG_CONSOLE_WIDTH-1] = 0;
        -: 8856:        }
    #####: 8857:        return line;
        -: 8858:    }
        -: 8859:
        -: 8860:    struct TestEventListenerBase : StreamingReporterBase {
        -: 8861:        TestEventListenerBase( ReporterConfig const& _config )
        -: 8862:        :   StreamingReporterBase( _config )
        -: 8863:        {}
        -: 8864:
        -: 8865:        virtual void assertionStarting( AssertionInfo const& ) CATCH_OVERRIDE {}
        -: 8866:        virtual bool assertionEnded( AssertionStats const& ) CATCH_OVERRIDE {
        -: 8867:            return false;
        -: 8868:        }
        -: 8869:    };
        -: 8870:
        -: 8871:} // end namespace Catch
        -: 8872:
        -: 8873:// #included from: ../internal/catch_reporter_registrars.hpp
        -: 8874:#define TWOBLUECUBES_CATCH_REPORTER_REGISTRARS_HPP_INCLUDED
        -: 8875:
        -: 8876:namespace Catch {
        -: 8877:
        -: 8878:    template<typename T>
        -: 8879:    class LegacyReporterRegistrar {
        -: 8880:
        -: 8881:        class ReporterFactory : public IReporterFactory {
        -: 8882:            virtual IStreamingReporter* create( ReporterConfig const& config ) const {
        -: 8883:                return new LegacyReporterAdapter( new T( config ) );
        -: 8884:            }
        -: 8885:
        -: 8886:            virtual std::string getDescription() const {
        -: 8887:                return T::getDescription();
        -: 8888:            }
        -: 8889:        };
        -: 8890:
        -: 8891:    public:
        -: 8892:
        -: 8893:        LegacyReporterRegistrar( std::string const& name ) {
        -: 8894:            getMutableRegistryHub().registerReporter( name, new ReporterFactory() );
        -: 8895:        }
        -: 8896:    };
        -: 8897:
        -: 8898:    template<typename T>
        -: 8899:    class ReporterRegistrar {
        -: 8900:
       12: 8901:        class ReporterFactory : public SharedImpl<IReporterFactory> {
        -: 8902:
        -: 8903:            // *** Please Note ***:
        -: 8904:            // - If you end up here looking at a compiler error because it's trying to register
        -: 8905:            // your custom reporter class be aware that the native reporter interface has changed
        -: 8906:            // to IStreamingReporter. The "legacy" interface, IReporter, is still supported via
        -: 8907:            // an adapter. Just use REGISTER_LEGACY_REPORTER to take advantage of the adapter.
        -: 8908:            // However please consider updating to the new interface as the old one is now
        -: 8909:            // deprecated and will probably be removed quite soon!
        -: 8910:            // Please contact me via github if you have any questions at all about this.
        -: 8911:            // In fact, ideally, please contact me anyway to let me know you've hit this - as I have
        -: 8912:            // no idea who is actually using custom reporters at all (possibly no-one!).
        -: 8913:            // The new interface is designed to minimise exposure to interface changes in the future.
        1: 8914:            virtual IStreamingReporter* create( ReporterConfig const& config ) const {
        1: 8915:                return new T( config );
        -: 8916:            }
        -: 8917:
    #####: 8918:            virtual std::string getDescription() const {
    #####: 8919:                return T::getDescription();
        -: 8920:            }
        -: 8921:        };
        -: 8922:
        -: 8923:    public:
        -: 8924:
        4: 8925:        ReporterRegistrar( std::string const& name ) {
        4: 8926:            getMutableRegistryHub().registerReporter( name, new ReporterFactory() );
        4: 8927:        }
        -: 8928:    };
        -: 8929:
        -: 8930:    template<typename T>
        -: 8931:    class ListenerRegistrar {
        -: 8932:
        -: 8933:        class ListenerFactory : public SharedImpl<IReporterFactory> {
        -: 8934:
        -: 8935:            virtual IStreamingReporter* create( ReporterConfig const& config ) const {
        -: 8936:                return new T( config );
        -: 8937:            }
        -: 8938:            virtual std::string getDescription() const {
        -: 8939:                return "";
        -: 8940:            }
        -: 8941:        };
        -: 8942:
        -: 8943:    public:
        -: 8944:
        -: 8945:        ListenerRegistrar() {
        -: 8946:            getMutableRegistryHub().registerListener( new ListenerFactory() );
        -: 8947:        }
        -: 8948:    };
        -: 8949:}
        -: 8950:
        -: 8951:#define INTERNAL_CATCH_REGISTER_LEGACY_REPORTER( name, reporterType ) \
        -: 8952:    namespace{ Catch::LegacyReporterRegistrar<reporterType> catch_internal_RegistrarFor##reporterType( name ); }
        -: 8953:
        -: 8954:#define INTERNAL_CATCH_REGISTER_REPORTER( name, reporterType ) \
        -: 8955:    namespace{ Catch::ReporterRegistrar<reporterType> catch_internal_RegistrarFor##reporterType( name ); }
        -: 8956:
        -: 8957:#define INTERNAL_CATCH_REGISTER_LISTENER( listenerType ) \
        -: 8958:    namespace{ Catch::ListenerRegistrar<listenerType> catch_internal_RegistrarFor##listenerType; }
        -: 8959:
        -: 8960:// #included from: ../internal/catch_xmlwriter.hpp
        -: 8961:#define TWOBLUECUBES_CATCH_XMLWRITER_HPP_INCLUDED
        -: 8962:
        -: 8963:#include <sstream>
        -: 8964:#include <string>
        -: 8965:#include <vector>
        -: 8966:#include <iomanip>
        -: 8967:
        -: 8968:namespace Catch {
        -: 8969:
    #####: 8970:    class XmlEncode {
        -: 8971:    public:
        -: 8972:        enum ForWhat { ForTextNodes, ForAttributes };
        -: 8973:
    #####: 8974:        XmlEncode( std::string const& str, ForWhat forWhat = ForTextNodes )
        -: 8975:        :   m_str( str ),
    #####: 8976:            m_forWhat( forWhat )
    #####: 8977:        {}
        -: 8978:
    #####: 8979:        void encodeTo( std::ostream& os ) const {
        -: 8980:
        -: 8981:            // Apostrophe escaping not necessary if we always use " to write attributes
        -: 8982:            // (see: http://www.w3.org/TR/xml/#syntax)
        -: 8983:
    #####: 8984:            for( std::size_t i = 0; i < m_str.size(); ++ i ) {
    #####: 8985:                char c = m_str[i];
    #####: 8986:                switch( c ) {
    #####: 8987:                    case '<':   os << "&lt;"; break;
    #####: 8988:                    case '&':   os << "&amp;"; break;
        -: 8989:
        -: 8990:                    case '>':
        -: 8991:                        // See: http://www.w3.org/TR/xml/#syntax
    #####: 8992:                        if( i > 2 && m_str[i-1] == ']' && m_str[i-2] == ']' )
    #####: 8993:                            os << "&gt;";
        -: 8994:                        else
    #####: 8995:                            os << c;
    #####: 8996:                        break;
        -: 8997:
        -: 8998:                    case '\"':
    #####: 8999:                        if( m_forWhat == ForAttributes )
    #####: 9000:                            os << "&quot;";
        -: 9001:                        else
    #####: 9002:                            os << c;
    #####: 9003:                        break;
        -: 9004:
        -: 9005:                    default:
        -: 9006:                        // Escape control chars - based on contribution by @espenalb in PR #465 and
        -: 9007:                        // by @mrpi PR #588
    #####: 9008:                        if ( ( c >= 0 && c < '\x09' ) || ( c > '\x0D' && c < '\x20') || c=='\x7F' )
    #####: 9009:                            os << "&#x" << std::uppercase << std::hex << std::setfill('0') << std::setw(2) << static_cast<int>( c ) << ';';
        -: 9010:                        else
    #####: 9011:                            os << c;
        -: 9012:                }
        -: 9013:            }
    #####: 9014:        }
        -: 9015:
    #####: 9016:        friend std::ostream& operator << ( std::ostream& os, XmlEncode const& xmlEncode ) {
    #####: 9017:            xmlEncode.encodeTo( os );
    #####: 9018:            return os;
        -: 9019:        }
        -: 9020:
        -: 9021:    private:
        -: 9022:        std::string m_str;
        -: 9023:        ForWhat m_forWhat;
        -: 9024:    };
        -: 9025:
        -: 9026:    class XmlWriter {
        -: 9027:    public:
        -: 9028:
        -: 9029:        class ScopedElement {
        -: 9030:        public:
    #####: 9031:            ScopedElement( XmlWriter* writer )
    #####: 9032:            :   m_writer( writer )
    #####: 9033:            {}
        -: 9034:
        -: 9035:            ScopedElement( ScopedElement const& other )
        -: 9036:            :   m_writer( other.m_writer ){
        -: 9037:                other.m_writer = CATCH_NULL;
        -: 9038:            }
        -: 9039:
    #####: 9040:            ~ScopedElement() {
    #####: 9041:                if( m_writer )
    #####: 9042:                    m_writer->endElement();
    #####: 9043:            }
        -: 9044:
    #####: 9045:            ScopedElement& writeText( std::string const& text, bool indent = true ) {
    #####: 9046:                m_writer->writeText( text, indent );
    #####: 9047:                return *this;
        -: 9048:            }
        -: 9049:
        -: 9050:            template<typename T>
    #####: 9051:            ScopedElement& writeAttribute( std::string const& name, T const& attribute ) {
    #####: 9052:                m_writer->writeAttribute( name, attribute );
    #####: 9053:                return *this;
        -: 9054:            }
        -: 9055:
        -: 9056:        private:
        -: 9057:            mutable XmlWriter* m_writer;
        -: 9058:        };
        -: 9059:
        -: 9060:        XmlWriter()
        -: 9061:        :   m_tagIsOpen( false ),
        -: 9062:            m_needsNewline( false ),
        -: 9063:            m_os( &Catch::cout() )
        -: 9064:        {
        -: 9065:            // We encode control characters, which requires
        -: 9066:            // XML 1.1
        -: 9067:            // see http://stackoverflow.com/questions/404107/why-are-control-characters-illegal-in-xml-1-0
        -: 9068:            *m_os << "<?xml version=\"1.1\" encoding=\"UTF-8\"?>\n";
        -: 9069:        }
        -: 9070:
    #####: 9071:        XmlWriter( std::ostream& os )
        -: 9072:        :   m_tagIsOpen( false ),
        -: 9073:            m_needsNewline( false ),
    #####: 9074:            m_os( &os )
        -: 9075:        {
    #####: 9076:            *m_os << "<?xml version=\"1.1\" encoding=\"UTF-8\"?>\n";
    #####: 9077:        }
        -: 9078:
    #####: 9079:        ~XmlWriter() {
    #####: 9080:            while( !m_tags.empty() )
    #####: 9081:                endElement();
    #####: 9082:        }
        -: 9083:
    #####: 9084:        XmlWriter& startElement( std::string const& name ) {
    #####: 9085:            ensureTagClosed();
    #####: 9086:            newlineIfNecessary();
    #####: 9087:            stream() << m_indent << "<" << name;
    #####: 9088:            m_tags.push_back( name );
    #####: 9089:            m_indent += "  ";
    #####: 9090:            m_tagIsOpen = true;
    #####: 9091:            return *this;
        -: 9092:        }
        -: 9093:
    #####: 9094:        ScopedElement scopedElement( std::string const& name ) {
    #####: 9095:            ScopedElement scoped( this );
    #####: 9096:            startElement( name );
    #####: 9097:            return scoped;
        -: 9098:        }
        -: 9099:
    #####: 9100:        XmlWriter& endElement() {
    #####: 9101:            newlineIfNecessary();
    #####: 9102:            m_indent = m_indent.substr( 0, m_indent.size()-2 );
    #####: 9103:            if( m_tagIsOpen ) {
    #####: 9104:                stream() << "/>\n";
    #####: 9105:                m_tagIsOpen = false;
        -: 9106:            }
        -: 9107:            else {
    #####: 9108:                stream() << m_indent << "</" << m_tags.back() << ">\n";
        -: 9109:            }
    #####: 9110:            m_tags.pop_back();
    #####: 9111:            return *this;
        -: 9112:        }
        -: 9113:
    #####: 9114:        XmlWriter& writeAttribute( std::string const& name, std::string const& attribute ) {
    #####: 9115:            if( !name.empty() && !attribute.empty() )
    #####: 9116:                stream() << " " << name << "=\"" << XmlEncode( attribute, XmlEncode::ForAttributes ) << "\"";
    #####: 9117:            return *this;
        -: 9118:        }
        -: 9119:
    #####: 9120:        XmlWriter& writeAttribute( std::string const& name, bool attribute ) {
    #####: 9121:            stream() << " " << name << "=\"" << ( attribute ? "true" : "false" ) << "\"";
    #####: 9122:            return *this;
        -: 9123:        }
        -: 9124:
        -: 9125:        template<typename T>
    #####: 9126:        XmlWriter& writeAttribute( std::string const& name, T const& attribute ) {
    #####: 9127:            std::ostringstream oss;
    #####: 9128:            oss << attribute;
    #####: 9129:            return writeAttribute( name, oss.str() );
        -: 9130:        }
        -: 9131:
    #####: 9132:        XmlWriter& writeText( std::string const& text, bool indent = true ) {
    #####: 9133:            if( !text.empty() ){
    #####: 9134:                bool tagWasOpen = m_tagIsOpen;
    #####: 9135:                ensureTagClosed();
    #####: 9136:                if( tagWasOpen && indent )
    #####: 9137:                    stream() << m_indent;
    #####: 9138:                stream() << XmlEncode( text );
    #####: 9139:                m_needsNewline = true;
        -: 9140:            }
    #####: 9141:            return *this;
        -: 9142:        }
        -: 9143:
        -: 9144:        XmlWriter& writeComment( std::string const& text ) {
        -: 9145:            ensureTagClosed();
        -: 9146:            stream() << m_indent << "<!--" << text << "-->";
        -: 9147:            m_needsNewline = true;
        -: 9148:            return *this;
        -: 9149:        }
        -: 9150:
        -: 9151:        XmlWriter& writeBlankLine() {
        -: 9152:            ensureTagClosed();
        -: 9153:            stream() << "\n";
        -: 9154:            return *this;
        -: 9155:        }
        -: 9156:
        -: 9157:        void setStream( std::ostream& os ) {
        -: 9158:            m_os = &os;
        -: 9159:        }
        -: 9160:
        -: 9161:    private:
        -: 9162:        XmlWriter( XmlWriter const& );
        -: 9163:        void operator=( XmlWriter const& );
        -: 9164:
    #####: 9165:        std::ostream& stream() {
    #####: 9166:            return *m_os;
        -: 9167:        }
        -: 9168:
    #####: 9169:        void ensureTagClosed() {
    #####: 9170:            if( m_tagIsOpen ) {
    #####: 9171:                stream() << ">\n";
    #####: 9172:                m_tagIsOpen = false;
        -: 9173:            }
    #####: 9174:        }
        -: 9175:
    #####: 9176:        void newlineIfNecessary() {
    #####: 9177:            if( m_needsNewline ) {
    #####: 9178:                stream() << "\n";
    #####: 9179:                m_needsNewline = false;
        -: 9180:            }
    #####: 9181:        }
        -: 9182:
        -: 9183:        bool m_tagIsOpen;
        -: 9184:        bool m_needsNewline;
        -: 9185:        std::vector<std::string> m_tags;
        -: 9186:        std::string m_indent;
        -: 9187:        std::ostream* m_os;
        -: 9188:    };
        -: 9189:
        -: 9190:}
        -: 9191:// #included from: catch_reenable_warnings.h
        -: 9192:
        -: 9193:#define TWOBLUECUBES_CATCH_REENABLE_WARNINGS_H_INCLUDED
        -: 9194:
        -: 9195:#ifdef __clang__
        -: 9196:#    ifdef __ICC // icpc defines the __clang__ macro
        -: 9197:#        pragma warning(pop)
        -: 9198:#    else
        -: 9199:#        pragma clang diagnostic pop
        -: 9200:#    endif
        -: 9201:#elif defined __GNUC__
        -: 9202:#    pragma GCC diagnostic pop
        -: 9203:#endif
        -: 9204:
        -: 9205:
        -: 9206:namespace Catch {
        -: 9207:    class XmlReporter : public StreamingReporterBase {
        -: 9208:    public:
    #####: 9209:        XmlReporter( ReporterConfig const& _config )
        -: 9210:        :   StreamingReporterBase( _config ),
    #####: 9211:            m_xml(_config.stream()),
    #####: 9212:            m_sectionDepth( 0 )
        -: 9213:        {
    #####: 9214:            m_reporterPrefs.shouldRedirectStdOut = true;
    #####: 9215:        }
        -: 9216:
        -: 9217:        virtual ~XmlReporter() CATCH_OVERRIDE;
        -: 9218:
    #####: 9219:        static std::string getDescription() {
    #####: 9220:            return "Reports test results as an XML document";
        -: 9221:        }
        -: 9222:
        -: 9223:    public: // StreamingReporterBase
        -: 9224:
    #####: 9225:        virtual void noMatchingTestCases( std::string const& s ) CATCH_OVERRIDE {
    #####: 9226:            StreamingReporterBase::noMatchingTestCases( s );
    #####: 9227:        }
        -: 9228:
    #####: 9229:        virtual void testRunStarting( TestRunInfo const& testInfo ) CATCH_OVERRIDE {
    #####: 9230:            StreamingReporterBase::testRunStarting( testInfo );
    #####: 9231:            m_xml.startElement( "Catch" );
    #####: 9232:            if( !m_config->name().empty() )
    #####: 9233:                m_xml.writeAttribute( "name", m_config->name() );
    #####: 9234:        }
        -: 9235:
    #####: 9236:        virtual void testGroupStarting( GroupInfo const& groupInfo ) CATCH_OVERRIDE {
    #####: 9237:            StreamingReporterBase::testGroupStarting( groupInfo );
    #####: 9238:            m_xml.startElement( "Group" )
    #####: 9239:                .writeAttribute( "name", groupInfo.name );
    #####: 9240:        }
        -: 9241:
    #####: 9242:        virtual void testCaseStarting( TestCaseInfo const& testInfo ) CATCH_OVERRIDE {
    #####: 9243:            StreamingReporterBase::testCaseStarting(testInfo);
    #####: 9244:            m_xml.startElement( "TestCase" ).writeAttribute( "name", testInfo.name );
        -: 9245:
    #####: 9246:            if ( m_config->showDurations() == ShowDurations::Always )
    #####: 9247:                m_testCaseTimer.start();
    #####: 9248:        }
        -: 9249:
    #####: 9250:        virtual void sectionStarting( SectionInfo const& sectionInfo ) CATCH_OVERRIDE {
    #####: 9251:            StreamingReporterBase::sectionStarting( sectionInfo );
    #####: 9252:            if( m_sectionDepth++ > 0 ) {
    #####: 9253:                m_xml.startElement( "Section" )
    #####: 9254:                    .writeAttribute( "name", trim( sectionInfo.name ) )
    #####: 9255:                    .writeAttribute( "description", sectionInfo.description );
        -: 9256:            }
    #####: 9257:        }
        -: 9258:
    #####: 9259:        virtual void assertionStarting( AssertionInfo const& ) CATCH_OVERRIDE { }
        -: 9260:
    #####: 9261:        virtual bool assertionEnded( AssertionStats const& assertionStats ) CATCH_OVERRIDE {
    #####: 9262:            const AssertionResult& assertionResult = assertionStats.assertionResult;
        -: 9263:
        -: 9264:            // Print any info messages in <Info> tags.
    #####: 9265:            if( assertionStats.assertionResult.getResultType() != ResultWas::Ok ) {
    #####: 9266:                for( std::vector<MessageInfo>::const_iterator it = assertionStats.infoMessages.begin(), itEnd = assertionStats.infoMessages.end();
        -: 9267:                        it != itEnd;
        -: 9268:                        ++it ) {
    #####: 9269:                    if( it->type == ResultWas::Info ) {
    #####: 9270:                        m_xml.scopedElement( "Info" )
    #####: 9271:                            .writeText( it->message );
    #####: 9272:                    } else if ( it->type == ResultWas::Warning ) {
    #####: 9273:                        m_xml.scopedElement( "Warning" )
    #####: 9274:                            .writeText( it->message );
        -: 9275:                    }
        -: 9276:                }
        -: 9277:            }
        -: 9278:
        -: 9279:            // Drop out if result was successful but we're not printing them.
    #####: 9280:            if( !m_config->includeSuccessfulResults() && isOk(assertionResult.getResultType()) )
    #####: 9281:                return true;
        -: 9282:
        -: 9283:            // Print the expression if there is one.
    #####: 9284:            if( assertionResult.hasExpression() ) {
    #####: 9285:                m_xml.startElement( "Expression" )
    #####: 9286:                    .writeAttribute( "success", assertionResult.succeeded() )
    #####: 9287:					.writeAttribute( "type", assertionResult.getTestMacroName() )
    #####: 9288:                    .writeAttribute( "filename", assertionResult.getSourceInfo().file )
    #####: 9289:                    .writeAttribute( "line", assertionResult.getSourceInfo().line );
        -: 9290:
    #####: 9291:                m_xml.scopedElement( "Original" )
    #####: 9292:                    .writeText( assertionResult.getExpression() );
    #####: 9293:                m_xml.scopedElement( "Expanded" )
    #####: 9294:                    .writeText( assertionResult.getExpandedExpression() );
        -: 9295:            }
        -: 9296:
        -: 9297:            // And... Print a result applicable to each result type.
    #####: 9298:            switch( assertionResult.getResultType() ) {
        -: 9299:                case ResultWas::ThrewException:
    #####: 9300:                    m_xml.scopedElement( "Exception" )
    #####: 9301:                        .writeAttribute( "filename", assertionResult.getSourceInfo().file )
    #####: 9302:                        .writeAttribute( "line", assertionResult.getSourceInfo().line )
    #####: 9303:                        .writeText( assertionResult.getMessage() );
    #####: 9304:                    break;
        -: 9305:                case ResultWas::FatalErrorCondition:
    #####: 9306:                    m_xml.scopedElement( "FatalErrorCondition" )
    #####: 9307:                        .writeAttribute( "filename", assertionResult.getSourceInfo().file )
    #####: 9308:                        .writeAttribute( "line", assertionResult.getSourceInfo().line )
    #####: 9309:                        .writeText( assertionResult.getMessage() );
    #####: 9310:                    break;
        -: 9311:                case ResultWas::Info:
    #####: 9312:                    m_xml.scopedElement( "Info" )
    #####: 9313:                        .writeText( assertionResult.getMessage() );
    #####: 9314:                    break;
        -: 9315:                case ResultWas::Warning:
        -: 9316:                    // Warning will already have been written
    #####: 9317:                    break;
        -: 9318:                case ResultWas::ExplicitFailure:
    #####: 9319:                    m_xml.scopedElement( "Failure" )
    #####: 9320:                        .writeText( assertionResult.getMessage() );
    #####: 9321:                    break;
        -: 9322:                default:
    #####: 9323:                    break;
        -: 9324:            }
        -: 9325:
    #####: 9326:            if( assertionResult.hasExpression() )
    #####: 9327:                m_xml.endElement();
        -: 9328:
    #####: 9329:            return true;
        -: 9330:        }
        -: 9331:
    #####: 9332:        virtual void sectionEnded( SectionStats const& sectionStats ) CATCH_OVERRIDE {
    #####: 9333:            StreamingReporterBase::sectionEnded( sectionStats );
    #####: 9334:            if( --m_sectionDepth > 0 ) {
    #####: 9335:                XmlWriter::ScopedElement e = m_xml.scopedElement( "OverallResults" );
    #####: 9336:                e.writeAttribute( "successes", sectionStats.assertions.passed );
    #####: 9337:                e.writeAttribute( "failures", sectionStats.assertions.failed );
    #####: 9338:                e.writeAttribute( "expectedFailures", sectionStats.assertions.failedButOk );
        -: 9339:
    #####: 9340:                if ( m_config->showDurations() == ShowDurations::Always )
    #####: 9341:                    e.writeAttribute( "durationInSeconds", sectionStats.durationInSeconds );
        -: 9342:
    #####: 9343:                m_xml.endElement();
        -: 9344:            }
    #####: 9345:        }
        -: 9346:
    #####: 9347:        virtual void testCaseEnded( TestCaseStats const& testCaseStats ) CATCH_OVERRIDE {
    #####: 9348:            StreamingReporterBase::testCaseEnded( testCaseStats );
    #####: 9349:            XmlWriter::ScopedElement e = m_xml.scopedElement( "OverallResult" );
    #####: 9350:            e.writeAttribute( "success", testCaseStats.totals.assertions.allOk() );
        -: 9351:
    #####: 9352:            if ( m_config->showDurations() == ShowDurations::Always )
    #####: 9353:                e.writeAttribute( "durationInSeconds", m_testCaseTimer.getElapsedSeconds() );
        -: 9354:
    #####: 9355:            m_xml.endElement();
    #####: 9356:        }
        -: 9357:
    #####: 9358:        virtual void testGroupEnded( TestGroupStats const& testGroupStats ) CATCH_OVERRIDE {
    #####: 9359:            StreamingReporterBase::testGroupEnded( testGroupStats );
        -: 9360:            // TODO: Check testGroupStats.aborting and act accordingly.
    #####: 9361:            m_xml.scopedElement( "OverallResults" )
    #####: 9362:                .writeAttribute( "successes", testGroupStats.totals.assertions.passed )
    #####: 9363:                .writeAttribute( "failures", testGroupStats.totals.assertions.failed )
    #####: 9364:                .writeAttribute( "expectedFailures", testGroupStats.totals.assertions.failedButOk );
    #####: 9365:            m_xml.endElement();
    #####: 9366:        }
        -: 9367:
    #####: 9368:        virtual void testRunEnded( TestRunStats const& testRunStats ) CATCH_OVERRIDE {
    #####: 9369:            StreamingReporterBase::testRunEnded( testRunStats );
    #####: 9370:            m_xml.scopedElement( "OverallResults" )
    #####: 9371:                .writeAttribute( "successes", testRunStats.totals.assertions.passed )
    #####: 9372:                .writeAttribute( "failures", testRunStats.totals.assertions.failed )
    #####: 9373:                .writeAttribute( "expectedFailures", testRunStats.totals.assertions.failedButOk );
    #####: 9374:            m_xml.endElement();
    #####: 9375:        }
        -: 9376:
        -: 9377:    private:
        -: 9378:        Timer m_testCaseTimer;
        -: 9379:        XmlWriter m_xml;
        -: 9380:        int m_sectionDepth;
        -: 9381:    };
        -: 9382:
        1: 9383:     INTERNAL_CATCH_REGISTER_REPORTER( "xml", XmlReporter )
        -: 9384:
        -: 9385:} // end namespace Catch
        -: 9386:
        -: 9387:// #included from: ../reporters/catch_reporter_junit.hpp
        -: 9388:#define TWOBLUECUBES_CATCH_REPORTER_JUNIT_HPP_INCLUDED
        -: 9389:
        -: 9390:#include <assert.h>
        -: 9391:
        -: 9392:namespace Catch {
        -: 9393:
        -: 9394:    class JunitReporter : public CumulativeReporterBase {
        -: 9395:    public:
    #####: 9396:        JunitReporter( ReporterConfig const& _config )
        -: 9397:        :   CumulativeReporterBase( _config ),
    #####: 9398:            xml( _config.stream() )
        -: 9399:        {
    #####: 9400:            m_reporterPrefs.shouldRedirectStdOut = true;
    #####: 9401:        }
        -: 9402:
        -: 9403:        virtual ~JunitReporter() CATCH_OVERRIDE;
        -: 9404:
    #####: 9405:        static std::string getDescription() {
    #####: 9406:            return "Reports test results in an XML format that looks like Ant's junitreport target";
        -: 9407:        }
        -: 9408:
    #####: 9409:        virtual void noMatchingTestCases( std::string const& /*spec*/ ) CATCH_OVERRIDE {}
        -: 9410:
    #####: 9411:        virtual void testRunStarting( TestRunInfo const& runInfo ) CATCH_OVERRIDE {
    #####: 9412:            CumulativeReporterBase::testRunStarting( runInfo );
    #####: 9413:            xml.startElement( "testsuites" );
    #####: 9414:        }
        -: 9415:
    #####: 9416:        virtual void testGroupStarting( GroupInfo const& groupInfo ) CATCH_OVERRIDE {
    #####: 9417:            suiteTimer.start();
    #####: 9418:            stdOutForSuite.str("");
    #####: 9419:            stdErrForSuite.str("");
    #####: 9420:            unexpectedExceptions = 0;
    #####: 9421:            CumulativeReporterBase::testGroupStarting( groupInfo );
    #####: 9422:        }
        -: 9423:
    #####: 9424:        virtual bool assertionEnded( AssertionStats const& assertionStats ) CATCH_OVERRIDE {
    #####: 9425:            if( assertionStats.assertionResult.getResultType() == ResultWas::ThrewException )
    #####: 9426:                unexpectedExceptions++;
    #####: 9427:            return CumulativeReporterBase::assertionEnded( assertionStats );
        -: 9428:        }
        -: 9429:
    #####: 9430:        virtual void testCaseEnded( TestCaseStats const& testCaseStats ) CATCH_OVERRIDE {
    #####: 9431:            stdOutForSuite << testCaseStats.stdOut;
    #####: 9432:            stdErrForSuite << testCaseStats.stdErr;
    #####: 9433:            CumulativeReporterBase::testCaseEnded( testCaseStats );
    #####: 9434:        }
        -: 9435:
    #####: 9436:        virtual void testGroupEnded( TestGroupStats const& testGroupStats ) CATCH_OVERRIDE {
    #####: 9437:            double suiteTime = suiteTimer.getElapsedSeconds();
    #####: 9438:            CumulativeReporterBase::testGroupEnded( testGroupStats );
    #####: 9439:            writeGroup( *m_testGroups.back(), suiteTime );
    #####: 9440:        }
        -: 9441:
    #####: 9442:        virtual void testRunEndedCumulative() CATCH_OVERRIDE {
    #####: 9443:            xml.endElement();
    #####: 9444:        }
        -: 9445:
    #####: 9446:        void writeGroup( TestGroupNode const& groupNode, double suiteTime ) {
    #####: 9447:            XmlWriter::ScopedElement e = xml.scopedElement( "testsuite" );
    #####: 9448:            TestGroupStats const& stats = groupNode.value;
    #####: 9449:            xml.writeAttribute( "name", stats.groupInfo.name );
    #####: 9450:            xml.writeAttribute( "errors", unexpectedExceptions );
    #####: 9451:            xml.writeAttribute( "failures", stats.totals.assertions.failed-unexpectedExceptions );
    #####: 9452:            xml.writeAttribute( "tests", stats.totals.assertions.total() );
    #####: 9453:            xml.writeAttribute( "hostname", "tbd" ); // !TBD
    #####: 9454:            if( m_config->showDurations() == ShowDurations::Never )
    #####: 9455:                xml.writeAttribute( "time", "" );
        -: 9456:            else
    #####: 9457:                xml.writeAttribute( "time", suiteTime );
    #####: 9458:            xml.writeAttribute( "timestamp", "tbd" ); // !TBD
        -: 9459:
        -: 9460:            // Write test cases
    #####: 9461:            for( TestGroupNode::ChildNodes::const_iterator
    #####: 9462:                    it = groupNode.children.begin(), itEnd = groupNode.children.end();
        -: 9463:                    it != itEnd;
        -: 9464:                    ++it )
    #####: 9465:                writeTestCase( **it );
        -: 9466:
    #####: 9467:            xml.scopedElement( "system-out" ).writeText( trim( stdOutForSuite.str() ), false );
    #####: 9468:            xml.scopedElement( "system-err" ).writeText( trim( stdErrForSuite.str() ), false );
    #####: 9469:        }
        -: 9470:
    #####: 9471:        void writeTestCase( TestCaseNode const& testCaseNode ) {
    #####: 9472:            TestCaseStats const& stats = testCaseNode.value;
        -: 9473:
        -: 9474:            // All test cases have exactly one section - which represents the
        -: 9475:            // test case itself. That section may have 0-n nested sections
    #####: 9476:            assert( testCaseNode.children.size() == 1 );
    #####: 9477:            SectionNode const& rootSection = *testCaseNode.children.front();
        -: 9478:
    #####: 9479:            std::string className = stats.testInfo.className;
        -: 9480:
    #####: 9481:            if( className.empty() ) {
    #####: 9482:                if( rootSection.childSections.empty() )
    #####: 9483:                    className = "global";
        -: 9484:            }
    #####: 9485:            writeSection( className, "", rootSection );
    #####: 9486:        }
        -: 9487:
    #####: 9488:        void writeSection(  std::string const& className,
        -: 9489:                            std::string const& rootName,
        -: 9490:                            SectionNode const& sectionNode ) {
    #####: 9491:            std::string name = trim( sectionNode.stats.sectionInfo.name );
    #####: 9492:            if( !rootName.empty() )
    #####: 9493:                name = rootName + "/" + name;
        -: 9494:
    #####: 9495:            if( !sectionNode.assertions.empty() ||
    #####: 9496:                !sectionNode.stdOut.empty() ||
    #####: 9497:                !sectionNode.stdErr.empty() ) {
    #####: 9498:                XmlWriter::ScopedElement e = xml.scopedElement( "testcase" );
    #####: 9499:                if( className.empty() ) {
    #####: 9500:                    xml.writeAttribute( "classname", name );
    #####: 9501:                    xml.writeAttribute( "name", "root" );
        -: 9502:                }
        -: 9503:                else {
    #####: 9504:                    xml.writeAttribute( "classname", className );
    #####: 9505:                    xml.writeAttribute( "name", name );
        -: 9506:                }
    #####: 9507:                xml.writeAttribute( "time", Catch::toString( sectionNode.stats.durationInSeconds ) );
        -: 9508:
    #####: 9509:                writeAssertions( sectionNode );
        -: 9510:
    #####: 9511:                if( !sectionNode.stdOut.empty() )
    #####: 9512:                    xml.scopedElement( "system-out" ).writeText( trim( sectionNode.stdOut ), false );
    #####: 9513:                if( !sectionNode.stdErr.empty() )
    #####: 9514:                    xml.scopedElement( "system-err" ).writeText( trim( sectionNode.stdErr ), false );
        -: 9515:            }
    #####: 9516:            for( SectionNode::ChildSections::const_iterator
    #####: 9517:                    it = sectionNode.childSections.begin(),
    #####: 9518:                    itEnd = sectionNode.childSections.end();
        -: 9519:                    it != itEnd;
        -: 9520:                    ++it )
    #####: 9521:                if( className.empty() )
    #####: 9522:                    writeSection( name, "", **it );
        -: 9523:                else
    #####: 9524:                    writeSection( className, name, **it );
    #####: 9525:        }
        -: 9526:
    #####: 9527:        void writeAssertions( SectionNode const& sectionNode ) {
    #####: 9528:            for( SectionNode::Assertions::const_iterator
    #####: 9529:                    it = sectionNode.assertions.begin(), itEnd = sectionNode.assertions.end();
        -: 9530:                    it != itEnd;
        -: 9531:                    ++it )
    #####: 9532:                writeAssertion( *it );
    #####: 9533:        }
    #####: 9534:        void writeAssertion( AssertionStats const& stats ) {
    #####: 9535:            AssertionResult const& result = stats.assertionResult;
    #####: 9536:            if( !result.isOk() ) {
    #####: 9537:                std::string elementName;
    #####: 9538:                switch( result.getResultType() ) {
        -: 9539:                    case ResultWas::ThrewException:
        -: 9540:                    case ResultWas::FatalErrorCondition:
    #####: 9541:                        elementName = "error";
    #####: 9542:                        break;
        -: 9543:                    case ResultWas::ExplicitFailure:
    #####: 9544:                        elementName = "failure";
    #####: 9545:                        break;
        -: 9546:                    case ResultWas::ExpressionFailed:
    #####: 9547:                        elementName = "failure";
    #####: 9548:                        break;
        -: 9549:                    case ResultWas::DidntThrowException:
    #####: 9550:                        elementName = "failure";
    #####: 9551:                        break;
        -: 9552:
        -: 9553:                    // We should never see these here:
        -: 9554:                    case ResultWas::Info:
        -: 9555:                    case ResultWas::Warning:
        -: 9556:                    case ResultWas::Ok:
        -: 9557:                    case ResultWas::Unknown:
        -: 9558:                    case ResultWas::FailureBit:
        -: 9559:                    case ResultWas::Exception:
    #####: 9560:                        elementName = "internalError";
    #####: 9561:                        break;
        -: 9562:                }
        -: 9563:
    #####: 9564:                XmlWriter::ScopedElement e = xml.scopedElement( elementName );
        -: 9565:
    #####: 9566:                xml.writeAttribute( "message", result.getExpandedExpression() );
    #####: 9567:                xml.writeAttribute( "type", result.getTestMacroName() );
        -: 9568:
    #####: 9569:                std::ostringstream oss;
    #####: 9570:                if( !result.getMessage().empty() )
    #####: 9571:                    oss << result.getMessage() << "\n";
    #####: 9572:                for( std::vector<MessageInfo>::const_iterator
    #####: 9573:                        it = stats.infoMessages.begin(),
    #####: 9574:                        itEnd = stats.infoMessages.end();
        -: 9575:                            it != itEnd;
        -: 9576:                            ++it )
    #####: 9577:                    if( it->type == ResultWas::Info )
    #####: 9578:                        oss << it->message << "\n";
        -: 9579:
    #####: 9580:                oss << "at " << result.getSourceInfo();
    #####: 9581:                xml.writeText( oss.str(), false );
        -: 9582:            }
    #####: 9583:        }
        -: 9584:
        -: 9585:        XmlWriter xml;
        -: 9586:        Timer suiteTimer;
        -: 9587:        std::ostringstream stdOutForSuite;
        -: 9588:        std::ostringstream stdErrForSuite;
        -: 9589:        unsigned int unexpectedExceptions;
        -: 9590:    };
        -: 9591:
        1: 9592:    INTERNAL_CATCH_REGISTER_REPORTER( "junit", JunitReporter )
        -: 9593:
        -: 9594:} // end namespace Catch
        -: 9595:
        -: 9596:// #included from: ../reporters/catch_reporter_console.hpp
        -: 9597:#define TWOBLUECUBES_CATCH_REPORTER_CONSOLE_HPP_INCLUDED
        -: 9598:
        -: 9599:namespace Catch {
        -: 9600:
        -: 9601:    struct ConsoleReporter : StreamingReporterBase {
        1: 9602:        ConsoleReporter( ReporterConfig const& _config )
        -: 9603:        :   StreamingReporterBase( _config ),
        1: 9604:            m_headerPrinted( false )
        1: 9605:        {}
        -: 9606:
        -: 9607:        virtual ~ConsoleReporter() CATCH_OVERRIDE;
    #####: 9608:        static std::string getDescription() {
    #####: 9609:            return "Reports test results as plain lines of text";
        -: 9610:        }
        -: 9611:
    #####: 9612:        virtual void noMatchingTestCases( std::string const& spec ) CATCH_OVERRIDE {
    #####: 9613:            stream << "No test cases matched '" << spec << "'" << std::endl;
    #####: 9614:        }
        -: 9615:
    #####: 9616:        virtual void assertionStarting( AssertionInfo const& ) CATCH_OVERRIDE {
    #####: 9617:        }
        -: 9618:
    #####: 9619:        virtual bool assertionEnded( AssertionStats const& _assertionStats ) CATCH_OVERRIDE {
    #####: 9620:            AssertionResult const& result = _assertionStats.assertionResult;
        -: 9621:
    #####: 9622:            bool printInfoMessages = true;
        -: 9623:
        -: 9624:            // Drop out if result was successful and we're not printing those
    #####: 9625:            if( !m_config->includeSuccessfulResults() && result.isOk() ) {
    #####: 9626:                if( result.getResultType() != ResultWas::Warning )
    #####: 9627:                    return false;
    #####: 9628:                printInfoMessages = false;
        -: 9629:            }
        -: 9630:
    #####: 9631:            lazyPrint();
        -: 9632:
    #####: 9633:            AssertionPrinter printer( stream, _assertionStats, printInfoMessages );
    #####: 9634:            printer.print();
    #####: 9635:            stream << std::endl;
    #####: 9636:            return true;
        -: 9637:        }
        -: 9638:
    #####: 9639:        virtual void sectionStarting( SectionInfo const& _sectionInfo ) CATCH_OVERRIDE {
    #####: 9640:            m_headerPrinted = false;
    #####: 9641:            StreamingReporterBase::sectionStarting( _sectionInfo );
    #####: 9642:        }
    #####: 9643:        virtual void sectionEnded( SectionStats const& _sectionStats ) CATCH_OVERRIDE {
    #####: 9644:            if( _sectionStats.missingAssertions ) {
    #####: 9645:                lazyPrint();
    #####: 9646:                Colour colour( Colour::ResultError );
    #####: 9647:                if( m_sectionStack.size() > 1 )
    #####: 9648:                    stream << "\nNo assertions in section";
        -: 9649:                else
    #####: 9650:                    stream << "\nNo assertions in test case";
    #####: 9651:                stream << " '" << _sectionStats.sectionInfo.name << "'\n" << std::endl;
        -: 9652:            }
    #####: 9653:            if( m_headerPrinted ) {
    #####: 9654:                if( m_config->showDurations() == ShowDurations::Always )
    #####: 9655:                    stream << "Completed in " << _sectionStats.durationInSeconds << "s" << std::endl;
    #####: 9656:                m_headerPrinted = false;
        -: 9657:            }
        -: 9658:            else {
    #####: 9659:                if( m_config->showDurations() == ShowDurations::Always )
    #####: 9660:                    stream << _sectionStats.sectionInfo.name << " completed in " << _sectionStats.durationInSeconds << "s" << std::endl;
        -: 9661:            }
    #####: 9662:            StreamingReporterBase::sectionEnded( _sectionStats );
    #####: 9663:        }
        -: 9664:
    #####: 9665:        virtual void testCaseEnded( TestCaseStats const& _testCaseStats ) CATCH_OVERRIDE {
    #####: 9666:            StreamingReporterBase::testCaseEnded( _testCaseStats );
    #####: 9667:            m_headerPrinted = false;
    #####: 9668:        }
        1: 9669:        virtual void testGroupEnded( TestGroupStats const& _testGroupStats ) CATCH_OVERRIDE {
        1: 9670:            if( currentGroupInfo.used ) {
    #####: 9671:                printSummaryDivider();
    #####: 9672:                stream << "Summary for group '" << _testGroupStats.groupInfo.name << "':\n";
    #####: 9673:                printTotals( _testGroupStats.totals );
    #####: 9674:                stream << "\n" << std::endl;
        -: 9675:            }
        1: 9676:            StreamingReporterBase::testGroupEnded( _testGroupStats );
        1: 9677:        }
        1: 9678:        virtual void testRunEnded( TestRunStats const& _testRunStats ) CATCH_OVERRIDE {
        1: 9679:            printTotalsDivider( _testRunStats.totals );
        1: 9680:            printTotals( _testRunStats.totals );
        1: 9681:            stream << std::endl;
        1: 9682:            StreamingReporterBase::testRunEnded( _testRunStats );
        1: 9683:        }
        -: 9684:
        -: 9685:    private:
        -: 9686:
    #####: 9687:        class AssertionPrinter {
        -: 9688:            void operator= ( AssertionPrinter const& );
        -: 9689:        public:
    #####: 9690:            AssertionPrinter( std::ostream& _stream, AssertionStats const& _stats, bool _printInfoMessages )
        -: 9691:            :   stream( _stream ),
        -: 9692:                stats( _stats ),
        -: 9693:                result( _stats.assertionResult ),
        -: 9694:                colour( Colour::None ),
    #####: 9695:                message( result.getMessage() ),
        -: 9696:                messages( _stats.infoMessages ),
    #####: 9697:                printInfoMessages( _printInfoMessages )
        -: 9698:            {
    #####: 9699:                switch( result.getResultType() ) {
        -: 9700:                    case ResultWas::Ok:
    #####: 9701:                        colour = Colour::Success;
    #####: 9702:                        passOrFail = "PASSED";
        -: 9703:                        //if( result.hasMessage() )
    #####: 9704:                        if( _stats.infoMessages.size() == 1 )
    #####: 9705:                            messageLabel = "with message";
    #####: 9706:                        if( _stats.infoMessages.size() > 1 )
    #####: 9707:                            messageLabel = "with messages";
    #####: 9708:                        break;
        -: 9709:                    case ResultWas::ExpressionFailed:
    #####: 9710:                        if( result.isOk() ) {
    #####: 9711:                            colour = Colour::Success;
    #####: 9712:                            passOrFail = "FAILED - but was ok";
        -: 9713:                        }
        -: 9714:                        else {
    #####: 9715:                            colour = Colour::Error;
    #####: 9716:                            passOrFail = "FAILED";
        -: 9717:                        }
    #####: 9718:                        if( _stats.infoMessages.size() == 1 )
    #####: 9719:                            messageLabel = "with message";
    #####: 9720:                        if( _stats.infoMessages.size() > 1 )
    #####: 9721:                            messageLabel = "with messages";
    #####: 9722:                        break;
        -: 9723:                    case ResultWas::ThrewException:
    #####: 9724:                        colour = Colour::Error;
    #####: 9725:                        passOrFail = "FAILED";
    #####: 9726:                        messageLabel = "due to unexpected exception with message";
    #####: 9727:                        break;
        -: 9728:                    case ResultWas::FatalErrorCondition:
    #####: 9729:                        colour = Colour::Error;
    #####: 9730:                        passOrFail = "FAILED";
    #####: 9731:                        messageLabel = "due to a fatal error condition";
    #####: 9732:                        break;
        -: 9733:                    case ResultWas::DidntThrowException:
    #####: 9734:                        colour = Colour::Error;
    #####: 9735:                        passOrFail = "FAILED";
    #####: 9736:                        messageLabel = "because no exception was thrown where one was expected";
    #####: 9737:                        break;
        -: 9738:                    case ResultWas::Info:
    #####: 9739:                        messageLabel = "info";
    #####: 9740:                        break;
        -: 9741:                    case ResultWas::Warning:
    #####: 9742:                        messageLabel = "warning";
    #####: 9743:                        break;
        -: 9744:                    case ResultWas::ExplicitFailure:
    #####: 9745:                        passOrFail = "FAILED";
    #####: 9746:                        colour = Colour::Error;
    #####: 9747:                        if( _stats.infoMessages.size() == 1 )
    #####: 9748:                            messageLabel = "explicitly with message";
    #####: 9749:                        if( _stats.infoMessages.size() > 1 )
    #####: 9750:                            messageLabel = "explicitly with messages";
    #####: 9751:                        break;
        -: 9752:                    // These cases are here to prevent compiler warnings
        -: 9753:                    case ResultWas::Unknown:
        -: 9754:                    case ResultWas::FailureBit:
        -: 9755:                    case ResultWas::Exception:
    #####: 9756:                        passOrFail = "** internal error **";
    #####: 9757:                        colour = Colour::Error;
    #####: 9758:                        break;
        -: 9759:                }
    #####: 9760:            }
        -: 9761:
    #####: 9762:            void print() const {
    #####: 9763:                printSourceInfo();
    #####: 9764:                if( stats.totals.assertions.total() > 0 ) {
    #####: 9765:                    if( result.isOk() )
    #####: 9766:                        stream << "\n";
    #####: 9767:                    printResultType();
    #####: 9768:                    printOriginalExpression();
    #####: 9769:                    printReconstructedExpression();
        -: 9770:                }
        -: 9771:                else {
    #####: 9772:                    stream << "\n";
        -: 9773:                }
    #####: 9774:                printMessage();
    #####: 9775:            }
        -: 9776:
        -: 9777:        private:
    #####: 9778:            void printResultType() const {
    #####: 9779:                if( !passOrFail.empty() ) {
    #####: 9780:                    Colour colourGuard( colour );
    #####: 9781:                    stream << passOrFail << ":\n";
        -: 9782:                }
    #####: 9783:            }
    #####: 9784:            void printOriginalExpression() const {
    #####: 9785:                if( result.hasExpression() ) {
    #####: 9786:                    Colour colourGuard( Colour::OriginalExpression );
    #####: 9787:                    stream  << "  ";
    #####: 9788:                    stream << result.getExpressionInMacro();
    #####: 9789:                    stream << "\n";
        -: 9790:                }
    #####: 9791:            }
    #####: 9792:            void printReconstructedExpression() const {
    #####: 9793:                if( result.hasExpandedExpression() ) {
    #####: 9794:                    stream << "with expansion:\n";
    #####: 9795:                    Colour colourGuard( Colour::ReconstructedExpression );
    #####: 9796:                    stream << Text( result.getExpandedExpression(), TextAttributes().setIndent(2) ) << "\n";
        -: 9797:                }
    #####: 9798:            }
    #####: 9799:            void printMessage() const {
    #####: 9800:                if( !messageLabel.empty() )
    #####: 9801:                    stream << messageLabel << ":" << "\n";
    #####: 9802:                for( std::vector<MessageInfo>::const_iterator it = messages.begin(), itEnd = messages.end();
        -: 9803:                        it != itEnd;
        -: 9804:                        ++it ) {
        -: 9805:                    // If this assertion is a warning ignore any INFO messages
    #####: 9806:                    if( printInfoMessages || it->type != ResultWas::Info )
    #####: 9807:                        stream << Text( it->message, TextAttributes().setIndent(2) ) << "\n";
        -: 9808:                }
    #####: 9809:            }
    #####: 9810:            void printSourceInfo() const {
    #####: 9811:                Colour colourGuard( Colour::FileName );
    #####: 9812:                stream << result.getSourceInfo() << ": ";
    #####: 9813:            }
        -: 9814:
        -: 9815:            std::ostream& stream;
        -: 9816:            AssertionStats const& stats;
        -: 9817:            AssertionResult const& result;
        -: 9818:            Colour::Code colour;
        -: 9819:            std::string passOrFail;
        -: 9820:            std::string messageLabel;
        -: 9821:            std::string message;
        -: 9822:            std::vector<MessageInfo> messages;
        -: 9823:            bool printInfoMessages;
        -: 9824:        };
        -: 9825:
    #####: 9826:        void lazyPrint() {
        -: 9827:
    #####: 9828:            if( !currentTestRunInfo.used )
    #####: 9829:                lazyPrintRunInfo();
    #####: 9830:            if( !currentGroupInfo.used )
    #####: 9831:                lazyPrintGroupInfo();
        -: 9832:
    #####: 9833:            if( !m_headerPrinted ) {
    #####: 9834:                printTestCaseAndSectionHeader();
    #####: 9835:                m_headerPrinted = true;
        -: 9836:            }
    #####: 9837:        }
    #####: 9838:        void lazyPrintRunInfo() {
    #####: 9839:            stream  << "\n" << getLineOfChars<'~'>() << "\n";
    #####: 9840:            Colour colour( Colour::SecondaryText );
    #####: 9841:            stream  << currentTestRunInfo->name
    #####: 9842:                    << " is a Catch v"  << libraryVersion << " host application.\n"
    #####: 9843:                    << "Run with -? for options\n\n";
        -: 9844:
    #####: 9845:            if( m_config->rngSeed() != 0 )
    #####: 9846:                stream << "Randomness seeded to: " << m_config->rngSeed() << "\n\n";
        -: 9847:
    #####: 9848:            currentTestRunInfo.used = true;
    #####: 9849:        }
    #####: 9850:        void lazyPrintGroupInfo() {
    #####: 9851:            if( !currentGroupInfo->name.empty() && currentGroupInfo->groupsCounts > 1 ) {
    #####: 9852:                printClosedHeader( "Group: " + currentGroupInfo->name );
    #####: 9853:                currentGroupInfo.used = true;
        -: 9854:            }
    #####: 9855:        }
    #####: 9856:        void printTestCaseAndSectionHeader() {
    #####: 9857:            assert( !m_sectionStack.empty() );
    #####: 9858:            printOpenHeader( currentTestCaseInfo->name );
        -: 9859:
    #####: 9860:            if( m_sectionStack.size() > 1 ) {
    #####: 9861:                Colour colourGuard( Colour::Headers );
        -: 9862:
        -: 9863:                std::vector<SectionInfo>::const_iterator
    #####: 9864:                    it = m_sectionStack.begin()+1, // Skip first section (test case)
    #####: 9865:                    itEnd = m_sectionStack.end();
    #####: 9866:                for( ; it != itEnd; ++it )
    #####: 9867:                    printHeaderString( it->name, 2 );
        -: 9868:            }
        -: 9869:
    #####: 9870:            SourceLineInfo lineInfo = m_sectionStack.front().lineInfo;
        -: 9871:
    #####: 9872:            if( !lineInfo.empty() ){
    #####: 9873:                stream << getLineOfChars<'-'>() << "\n";
    #####: 9874:                Colour colourGuard( Colour::FileName );
    #####: 9875:                stream << lineInfo << "\n";
        -: 9876:            }
    #####: 9877:            stream << getLineOfChars<'.'>() << "\n" << std::endl;
    #####: 9878:        }
        -: 9879:
    #####: 9880:        void printClosedHeader( std::string const& _name ) {
    #####: 9881:            printOpenHeader( _name );
    #####: 9882:            stream << getLineOfChars<'.'>() << "\n";
    #####: 9883:        }
    #####: 9884:        void printOpenHeader( std::string const& _name ) {
    #####: 9885:            stream  << getLineOfChars<'-'>() << "\n";
        -: 9886:            {
    #####: 9887:                Colour colourGuard( Colour::Headers );
    #####: 9888:                printHeaderString( _name );
        -: 9889:            }
    #####: 9890:        }
        -: 9891:
        -: 9892:        // if string has a : in first line will set indent to follow it on
        -: 9893:        // subsequent lines
    #####: 9894:        void printHeaderString( std::string const& _string, std::size_t indent = 0 ) {
    #####: 9895:            std::size_t i = _string.find( ": " );
    #####: 9896:            if( i != std::string::npos )
    #####: 9897:                i+=2;
        -: 9898:            else
    #####: 9899:                i = 0;
    #####: 9900:            stream << Text( _string, TextAttributes()
    #####: 9901:                                        .setIndent( indent+i)
    #####: 9902:                                        .setInitialIndent( indent ) ) << "\n";
    #####: 9903:        }
        -: 9904:
    #####: 9905:        struct SummaryColumn {
        -: 9906:
    #####: 9907:            SummaryColumn( std::string const& _label, Colour::Code _colour )
        -: 9908:            :   label( _label ),
    #####: 9909:                colour( _colour )
    #####: 9910:            {}
    #####: 9911:            SummaryColumn addRow( std::size_t count ) {
    #####: 9912:                std::ostringstream oss;
    #####: 9913:                oss << count;
    #####: 9914:                std::string row = oss.str();
    #####: 9915:                for( std::vector<std::string>::iterator it = rows.begin(); it != rows.end(); ++it ) {
    #####: 9916:                    while( it->size() < row.size() )
    #####: 9917:                        *it = " " + *it;
    #####: 9918:                    while( it->size() > row.size() )
    #####: 9919:                        row = " " + row;
        -: 9920:                }
    #####: 9921:                rows.push_back( row );
    #####: 9922:                return *this;
        -: 9923:            }
        -: 9924:
        -: 9925:            std::string label;
        -: 9926:            Colour::Code colour;
        -: 9927:            std::vector<std::string> rows;
        -: 9928:
        -: 9929:        };
        -: 9930:
        1: 9931:        void printTotals( Totals const& totals ) {
        1: 9932:            if( totals.testCases.total() == 0 ) {
        1: 9933:                stream << Colour( Colour::Warning ) << "No tests ran\n";
        -: 9934:            }
    #####: 9935:            else if( totals.assertions.total() > 0 && totals.testCases.allPassed() ) {
    #####: 9936:                stream << Colour( Colour::ResultSuccess ) << "All tests passed";
    #####: 9937:                stream << " ("
    #####: 9938:                        << pluralise( totals.assertions.passed, "assertion" ) << " in "
    #####: 9939:                        << pluralise( totals.testCases.passed, "test case" ) << ")"
    #####: 9940:                        << "\n";
        -: 9941:            }
        -: 9942:            else {
        -: 9943:
    #####: 9944:                std::vector<SummaryColumn> columns;
        -: 9945:                columns.push_back( SummaryColumn( "", Colour::None )
    #####: 9946:                                        .addRow( totals.testCases.total() )
    #####: 9947:                                        .addRow( totals.assertions.total() ) );
        -: 9948:                columns.push_back( SummaryColumn( "passed", Colour::Success )
    #####: 9949:                                        .addRow( totals.testCases.passed )
    #####: 9950:                                        .addRow( totals.assertions.passed ) );
        -: 9951:                columns.push_back( SummaryColumn( "failed", Colour::ResultError )
    #####: 9952:                                        .addRow( totals.testCases.failed )
    #####: 9953:                                        .addRow( totals.assertions.failed ) );
        -: 9954:                columns.push_back( SummaryColumn( "failed as expected", Colour::ResultExpectedFailure )
    #####: 9955:                                        .addRow( totals.testCases.failedButOk )
    #####: 9956:                                        .addRow( totals.assertions.failedButOk ) );
        -: 9957:
    #####: 9958:                printSummaryRow( "test cases", columns, 0 );
    #####: 9959:                printSummaryRow( "assertions", columns, 1 );
        -: 9960:            }
        1: 9961:        }
    #####: 9962:        void printSummaryRow( std::string const& label, std::vector<SummaryColumn> const& cols, std::size_t row ) {
    #####: 9963:            for( std::vector<SummaryColumn>::const_iterator it = cols.begin(); it != cols.end(); ++it ) {
    #####: 9964:                std::string value = it->rows[row];
    #####: 9965:                if( it->label.empty() ) {
    #####: 9966:                    stream << label << ": ";
    #####: 9967:                    if( value != "0" )
    #####: 9968:                        stream << value;
        -: 9969:                    else
    #####: 9970:                        stream << Colour( Colour::Warning ) << "- none -";
        -: 9971:                }
    #####: 9972:                else if( value != "0" ) {
    #####: 9973:                    stream  << Colour( Colour::LightGrey ) << " | ";
    #####: 9974:                    stream  << Colour( it->colour )
    #####: 9975:                            << value << " " << it->label;
        -: 9976:                }
        -: 9977:            }
    #####: 9978:            stream << "\n";
    #####: 9979:        }
        -: 9980:
    #####: 9981:        static std::size_t makeRatio( std::size_t number, std::size_t total ) {
    #####: 9982:            std::size_t ratio = total > 0 ? CATCH_CONFIG_CONSOLE_WIDTH * number/ total : 0;
    #####: 9983:            return ( ratio == 0 && number > 0 ) ? 1 : ratio;
        -: 9984:        }
    #####: 9985:        static std::size_t& findMax( std::size_t& i, std::size_t& j, std::size_t& k ) {
    #####: 9986:            if( i > j && i > k )
    #####: 9987:                return i;
    #####: 9988:            else if( j > k )
    #####: 9989:                return j;
        -: 9990:            else
    #####: 9991:                return k;
        -: 9992:        }
        -: 9993:
        1: 9994:        void printTotalsDivider( Totals const& totals ) {
        1: 9995:            if( totals.testCases.total() > 0 ) {
    #####: 9996:                std::size_t failedRatio = makeRatio( totals.testCases.failed, totals.testCases.total() );
    #####: 9997:                std::size_t failedButOkRatio = makeRatio( totals.testCases.failedButOk, totals.testCases.total() );
    #####: 9998:                std::size_t passedRatio = makeRatio( totals.testCases.passed, totals.testCases.total() );
    #####: 9999:                while( failedRatio + failedButOkRatio + passedRatio < CATCH_CONFIG_CONSOLE_WIDTH-1 )
    #####:10000:                    findMax( failedRatio, failedButOkRatio, passedRatio )++;
    #####:10001:                while( failedRatio + failedButOkRatio + passedRatio > CATCH_CONFIG_CONSOLE_WIDTH-1 )
    #####:10002:                    findMax( failedRatio, failedButOkRatio, passedRatio )--;
        -:10003:
    #####:10004:                stream << Colour( Colour::Error ) << std::string( failedRatio, '=' );
    #####:10005:                stream << Colour( Colour::ResultExpectedFailure ) << std::string( failedButOkRatio, '=' );
    #####:10006:                if( totals.testCases.allPassed() )
    #####:10007:                    stream << Colour( Colour::ResultSuccess ) << std::string( passedRatio, '=' );
        -:10008:                else
    #####:10009:                    stream << Colour( Colour::Success ) << std::string( passedRatio, '=' );
        -:10010:            }
        -:10011:            else {
        1:10012:                stream << Colour( Colour::Warning ) << std::string( CATCH_CONFIG_CONSOLE_WIDTH-1, '=' );
        -:10013:            }
        1:10014:            stream << "\n";
        1:10015:        }
    #####:10016:        void printSummaryDivider() {
    #####:10017:            stream << getLineOfChars<'-'>() << "\n";
    #####:10018:        }
        -:10019:
        -:10020:    private:
        -:10021:        bool m_headerPrinted;
        -:10022:    };
        -:10023:
        1:10024:    INTERNAL_CATCH_REGISTER_REPORTER( "console", ConsoleReporter )
        -:10025:
        -:10026:} // end namespace Catch
        -:10027:
        -:10028:// #included from: ../reporters/catch_reporter_compact.hpp
        -:10029:#define TWOBLUECUBES_CATCH_REPORTER_COMPACT_HPP_INCLUDED
        -:10030:
        -:10031:namespace Catch {
        -:10032:
        -:10033:    struct CompactReporter : StreamingReporterBase {
        -:10034:
    #####:10035:        CompactReporter( ReporterConfig const& _config )
    #####:10036:        : StreamingReporterBase( _config )
    #####:10037:        {}
        -:10038:
        -:10039:        virtual ~CompactReporter();
        -:10040:
    #####:10041:        static std::string getDescription() {
    #####:10042:            return "Reports test results on a single line, suitable for IDEs";
        -:10043:        }
        -:10044:
    #####:10045:        virtual ReporterPreferences getPreferences() const {
    #####:10046:            ReporterPreferences prefs;
    #####:10047:            prefs.shouldRedirectStdOut = false;
    #####:10048:            return prefs;
        -:10049:        }
        -:10050:
    #####:10051:        virtual void noMatchingTestCases( std::string const& spec ) {
    #####:10052:            stream << "No test cases matched '" << spec << "'" << std::endl;
    #####:10053:        }
        -:10054:
    #####:10055:        virtual void assertionStarting( AssertionInfo const& ) {
    #####:10056:        }
        -:10057:
    #####:10058:        virtual bool assertionEnded( AssertionStats const& _assertionStats ) {
    #####:10059:            AssertionResult const& result = _assertionStats.assertionResult;
        -:10060:
    #####:10061:            bool printInfoMessages = true;
        -:10062:
        -:10063:            // Drop out if result was successful and we're not printing those
    #####:10064:            if( !m_config->includeSuccessfulResults() && result.isOk() ) {
    #####:10065:                if( result.getResultType() != ResultWas::Warning )
    #####:10066:                    return false;
    #####:10067:                printInfoMessages = false;
        -:10068:            }
        -:10069:
    #####:10070:            AssertionPrinter printer( stream, _assertionStats, printInfoMessages );
    #####:10071:            printer.print();
        -:10072:
    #####:10073:            stream << std::endl;
    #####:10074:            return true;
        -:10075:        }
        -:10076:
    #####:10077:        virtual void testRunEnded( TestRunStats const& _testRunStats ) {
    #####:10078:            printTotals( _testRunStats.totals );
    #####:10079:            stream << "\n" << std::endl;
    #####:10080:            StreamingReporterBase::testRunEnded( _testRunStats );
    #####:10081:        }
        -:10082:
        -:10083:    private:
    #####:10084:        class AssertionPrinter {
        -:10085:            void operator= ( AssertionPrinter const& );
        -:10086:        public:
    #####:10087:            AssertionPrinter( std::ostream& _stream, AssertionStats const& _stats, bool _printInfoMessages )
        -:10088:            : stream( _stream )
        -:10089:            , stats( _stats )
        -:10090:            , result( _stats.assertionResult )
        -:10091:            , messages( _stats.infoMessages )
    #####:10092:            , itMessage( _stats.infoMessages.begin() )
    #####:10093:            , printInfoMessages( _printInfoMessages )
    #####:10094:            {}
        -:10095:
    #####:10096:            void print() {
    #####:10097:                printSourceInfo();
        -:10098:
    #####:10099:                itMessage = messages.begin();
        -:10100:
    #####:10101:                switch( result.getResultType() ) {
        -:10102:                    case ResultWas::Ok:
    #####:10103:                        printResultType( Colour::ResultSuccess, passedString() );
    #####:10104:                        printOriginalExpression();
    #####:10105:                        printReconstructedExpression();
    #####:10106:                        if ( ! result.hasExpression() )
    #####:10107:                            printRemainingMessages( Colour::None );
        -:10108:                        else
    #####:10109:                            printRemainingMessages();
    #####:10110:                        break;
        -:10111:                    case ResultWas::ExpressionFailed:
    #####:10112:                        if( result.isOk() )
    #####:10113:                            printResultType( Colour::ResultSuccess, failedString() + std::string( " - but was ok" ) );
        -:10114:                        else
    #####:10115:                            printResultType( Colour::Error, failedString() );
    #####:10116:                        printOriginalExpression();
    #####:10117:                        printReconstructedExpression();
    #####:10118:                        printRemainingMessages();
    #####:10119:                        break;
        -:10120:                    case ResultWas::ThrewException:
    #####:10121:                        printResultType( Colour::Error, failedString() );
    #####:10122:                        printIssue( "unexpected exception with message:" );
    #####:10123:                        printMessage();
    #####:10124:                        printExpressionWas();
    #####:10125:                        printRemainingMessages();
    #####:10126:                        break;
        -:10127:                    case ResultWas::FatalErrorCondition:
    #####:10128:                        printResultType( Colour::Error, failedString() );
    #####:10129:                        printIssue( "fatal error condition with message:" );
    #####:10130:                        printMessage();
    #####:10131:                        printExpressionWas();
    #####:10132:                        printRemainingMessages();
    #####:10133:                        break;
        -:10134:                    case ResultWas::DidntThrowException:
    #####:10135:                        printResultType( Colour::Error, failedString() );
    #####:10136:                        printIssue( "expected exception, got none" );
    #####:10137:                        printExpressionWas();
    #####:10138:                        printRemainingMessages();
    #####:10139:                        break;
        -:10140:                    case ResultWas::Info:
    #####:10141:                        printResultType( Colour::None, "info" );
    #####:10142:                        printMessage();
    #####:10143:                        printRemainingMessages();
    #####:10144:                        break;
        -:10145:                    case ResultWas::Warning:
    #####:10146:                        printResultType( Colour::None, "warning" );
    #####:10147:                        printMessage();
    #####:10148:                        printRemainingMessages();
    #####:10149:                        break;
        -:10150:                    case ResultWas::ExplicitFailure:
    #####:10151:                        printResultType( Colour::Error, failedString() );
    #####:10152:                        printIssue( "explicitly" );
    #####:10153:                        printRemainingMessages( Colour::None );
    #####:10154:                        break;
        -:10155:                    // These cases are here to prevent compiler warnings
        -:10156:                    case ResultWas::Unknown:
        -:10157:                    case ResultWas::FailureBit:
        -:10158:                    case ResultWas::Exception:
    #####:10159:                        printResultType( Colour::Error, "** internal error **" );
    #####:10160:                        break;
        -:10161:                }
    #####:10162:            }
        -:10163:
        -:10164:        private:
        -:10165:            // Colour::LightGrey
        -:10166:
    #####:10167:            static Colour::Code dimColour() { return Colour::FileName; }
        -:10168:
        -:10169:#ifdef CATCH_PLATFORM_MAC
        -:10170:            static const char* failedString() { return "FAILED"; }
        -:10171:            static const char* passedString() { return "PASSED"; }
        -:10172:#else
    #####:10173:            static const char* failedString() { return "failed"; }
    #####:10174:            static const char* passedString() { return "passed"; }
        -:10175:#endif
        -:10176:
    #####:10177:            void printSourceInfo() const {
    #####:10178:                Colour colourGuard( Colour::FileName );
    #####:10179:                stream << result.getSourceInfo() << ":";
    #####:10180:            }
        -:10181:
    #####:10182:            void printResultType( Colour::Code colour, std::string passOrFail ) const {
    #####:10183:                if( !passOrFail.empty() ) {
        -:10184:                    {
    #####:10185:                        Colour colourGuard( colour );
    #####:10186:                        stream << " " << passOrFail;
        -:10187:                    }
    #####:10188:                    stream << ":";
        -:10189:                }
    #####:10190:            }
        -:10191:
    #####:10192:            void printIssue( std::string issue ) const {
    #####:10193:                stream << " " << issue;
    #####:10194:            }
        -:10195:
    #####:10196:            void printExpressionWas() {
    #####:10197:                if( result.hasExpression() ) {
    #####:10198:                    stream << ";";
        -:10199:                    {
    #####:10200:                        Colour colour( dimColour() );
    #####:10201:                        stream << " expression was:";
        -:10202:                    }
    #####:10203:                    printOriginalExpression();
        -:10204:                }
    #####:10205:            }
        -:10206:
    #####:10207:            void printOriginalExpression() const {
    #####:10208:                if( result.hasExpression() ) {
    #####:10209:                    stream << " " << result.getExpression();
        -:10210:                }
    #####:10211:            }
        -:10212:
    #####:10213:            void printReconstructedExpression() const {
    #####:10214:                if( result.hasExpandedExpression() ) {
        -:10215:                    {
    #####:10216:                        Colour colour( dimColour() );
    #####:10217:                        stream << " for: ";
        -:10218:                    }
    #####:10219:                    stream << result.getExpandedExpression();
        -:10220:                }
    #####:10221:            }
        -:10222:
    #####:10223:            void printMessage() {
    #####:10224:                if ( itMessage != messages.end() ) {
    #####:10225:                    stream << " '" << itMessage->message << "'";
    #####:10226:                    ++itMessage;
        -:10227:                }
    #####:10228:            }
        -:10229:
    #####:10230:            void printRemainingMessages( Colour::Code colour = dimColour() ) {
    #####:10231:                if ( itMessage == messages.end() )
    #####:10232:                    return;
        -:10233:
        -:10234:                // using messages.end() directly yields compilation error:
    #####:10235:                std::vector<MessageInfo>::const_iterator itEnd = messages.end();
    #####:10236:                const std::size_t N = static_cast<std::size_t>( std::distance( itMessage, itEnd ) );
        -:10237:
        -:10238:                {
    #####:10239:                    Colour colourGuard( colour );
    #####:10240:                    stream << " with " << pluralise( N, "message" ) << ":";
        -:10241:                }
        -:10242:
    #####:10243:                for(; itMessage != itEnd; ) {
        -:10244:                    // If this assertion is a warning ignore any INFO messages
    #####:10245:                    if( printInfoMessages || itMessage->type != ResultWas::Info ) {
    #####:10246:                        stream << " '" << itMessage->message << "'";
    #####:10247:                        if ( ++itMessage != itEnd ) {
    #####:10248:                            Colour colourGuard( dimColour() );
    #####:10249:                            stream << " and";
        -:10250:                        }
        -:10251:                    }
        -:10252:                }
        -:10253:            }
        -:10254:
        -:10255:        private:
        -:10256:            std::ostream& stream;
        -:10257:            AssertionStats const& stats;
        -:10258:            AssertionResult const& result;
        -:10259:            std::vector<MessageInfo> messages;
        -:10260:            std::vector<MessageInfo>::const_iterator itMessage;
        -:10261:            bool printInfoMessages;
        -:10262:        };
        -:10263:
        -:10264:        // Colour, message variants:
        -:10265:        // - white: No tests ran.
        -:10266:        // -   red: Failed [both/all] N test cases, failed [both/all] M assertions.
        -:10267:        // - white: Passed [both/all] N test cases (no assertions).
        -:10268:        // -   red: Failed N tests cases, failed M assertions.
        -:10269:        // - green: Passed [both/all] N tests cases with M assertions.
        -:10270:
    #####:10271:        std::string bothOrAll( std::size_t count ) const {
    #####:10272:            return count == 1 ? "" : count == 2 ? "both " : "all " ;
        -:10273:        }
        -:10274:
    #####:10275:        void printTotals( const Totals& totals ) const {
    #####:10276:            if( totals.testCases.total() == 0 ) {
    #####:10277:                stream << "No tests ran.";
        -:10278:            }
    #####:10279:            else if( totals.testCases.failed == totals.testCases.total() ) {
    #####:10280:                Colour colour( Colour::ResultError );
        -:10281:                const std::string qualify_assertions_failed =
    #####:10282:                    totals.assertions.failed == totals.assertions.total() ?
    #####:10283:                        bothOrAll( totals.assertions.failed ) : "";
    #####:10284:                stream <<
    #####:10285:                    "Failed " << bothOrAll( totals.testCases.failed )
    #####:10286:                              << pluralise( totals.testCases.failed, "test case"  ) << ", "
    #####:10287:                    "failed " << qualify_assertions_failed <<
    #####:10288:                                 pluralise( totals.assertions.failed, "assertion" ) << ".";
        -:10289:            }
    #####:10290:            else if( totals.assertions.total() == 0 ) {
    #####:10291:                stream <<
    #####:10292:                    "Passed " << bothOrAll( totals.testCases.total() )
    #####:10293:                              << pluralise( totals.testCases.total(), "test case" )
    #####:10294:                              << " (no assertions).";
        -:10295:            }
    #####:10296:            else if( totals.assertions.failed ) {
    #####:10297:                Colour colour( Colour::ResultError );
    #####:10298:                stream <<
    #####:10299:                    "Failed " << pluralise( totals.testCases.failed, "test case"  ) << ", "
    #####:10300:                    "failed " << pluralise( totals.assertions.failed, "assertion" ) << ".";
        -:10301:            }
        -:10302:            else {
    #####:10303:                Colour colour( Colour::ResultSuccess );
    #####:10304:                stream <<
    #####:10305:                    "Passed " << bothOrAll( totals.testCases.passed )
    #####:10306:                              << pluralise( totals.testCases.passed, "test case"  ) <<
    #####:10307:                    " with "  << pluralise( totals.assertions.passed, "assertion" ) << ".";
        -:10308:            }
    #####:10309:        }
        -:10310:    };
        -:10311:
        1:10312:    INTERNAL_CATCH_REGISTER_REPORTER( "compact", CompactReporter )
        -:10313:
        -:10314:} // end namespace Catch
        -:10315:
        -:10316:namespace Catch {
        -:10317:    // These are all here to avoid warnings about not having any out of line
        -:10318:    // virtual methods
        9:10319:    NonCopyable::~NonCopyable() {}
        8:10320:    IShared::~IShared() {}
        1:10321:    IStream::~IStream() CATCH_NOEXCEPT {}
    #####:10322:    FileStream::~FileStream() CATCH_NOEXCEPT {}
        2:10323:    CoutStream::~CoutStream() CATCH_NOEXCEPT {}
    #####:10324:    DebugOutStream::~DebugOutStream() CATCH_NOEXCEPT {}
    #####:10325:    StreamBufBase::~StreamBufBase() CATCH_NOEXCEPT {}
        1:10326:    IContext::~IContext() {}
        1:10327:    IResultCapture::~IResultCapture() {}
    #####:10328:    ITestCase::~ITestCase() {}
        1:10329:    ITestCaseRegistry::~ITestCaseRegistry() {}
        1:10330:    IRegistryHub::~IRegistryHub() {}
        1:10331:    IMutableRegistryHub::~IMutableRegistryHub() {}
    #####:10332:    IExceptionTranslator::~IExceptionTranslator() {}
        1:10333:    IExceptionTranslatorRegistry::~IExceptionTranslatorRegistry() {}
    #####:10334:    IReporter::~IReporter() {}
        4:10335:    IReporterFactory::~IReporterFactory() {}
        1:10336:    IReporterRegistry::~IReporterRegistry() {}
        1:10337:    IStreamingReporter::~IStreamingReporter() {}
    #####:10338:    AssertionStats::~AssertionStats() {}
    #####:10339:    SectionStats::~SectionStats() {}
    #####:10340:    TestCaseStats::~TestCaseStats() {}
        1:10341:    TestGroupStats::~TestGroupStats() {}
        1:10342:    TestRunStats::~TestRunStats() {}
    #####:10343:    CumulativeReporterBase::SectionNode::~SectionNode() {}
    #####:10344:    CumulativeReporterBase::~CumulativeReporterBase() {}
        -:10345:
        1:10346:    StreamingReporterBase::~StreamingReporterBase() {}
        2:10347:    ConsoleReporter::~ConsoleReporter() {}
    #####:10348:    CompactReporter::~CompactReporter() {}
        1:10349:    IRunner::~IRunner() {}
        1:10350:    IMutableContext::~IMutableContext() {}
        1:10351:    IConfig::~IConfig() {}
    #####:10352:    XmlReporter::~XmlReporter() {}
    #####:10353:    JunitReporter::~JunitReporter() {}
        1:10354:    TestRegistry::~TestRegistry() {}
    #####:10355:    FreeFunctionTestCase::~FreeFunctionTestCase() {}
    #####:10356:    IGeneratorInfo::~IGeneratorInfo() {}
    #####:10357:    IGeneratorsForTest::~IGeneratorsForTest() {}
    #####:10358:    WildcardPattern::~WildcardPattern() {}
        2:10359:    TestSpec::Pattern::~Pattern() {}
    #####:10360:    TestSpec::NamePattern::~NamePattern() {}
        2:10361:    TestSpec::TagPattern::~TagPattern() {}
        2:10362:    TestSpec::ExcludedPattern::~ExcludedPattern() {}
        -:10363:
    #####:10364:    Matchers::Impl::StdString::Equals::~Equals() {}
    #####:10365:    Matchers::Impl::StdString::Contains::~Contains() {}
    #####:10366:    Matchers::Impl::StdString::StartsWith::~StartsWith() {}
    #####:10367:    Matchers::Impl::StdString::EndsWith::~EndsWith() {}
        -:10368:
    #####:10369:    void Config::dummy() {}
        -:10370:
        -:10371:    namespace TestCaseTracking {
    #####:10372:        ITracker::~ITracker() {}
    #####:10373:        TrackerBase::~TrackerBase() {}
    #####:10374:        SectionTracker::~SectionTracker() {}
    #####:10375:        IndexTracker::~IndexTracker() {}
        -:10376:    }
        -:10377:}
        -:10378:
        -:10379:#ifdef __clang__
        -:10380:#pragma clang diagnostic pop
        -:10381:#endif
        -:10382:
        -:10383:#endif
        -:10384:
        -:10385:#ifdef CATCH_CONFIG_MAIN
        -:10386:// #included from: internal/catch_default_main.hpp
        -:10387:#define TWOBLUECUBES_CATCH_DEFAULT_MAIN_HPP_INCLUDED
        -:10388:
        -:10389:#ifndef __OBJC__
        -:10390:
        -:10391:// Standard C/C++ main entry point
        1:10392:int main (int argc, char * argv[]) {
        1:10393:    return Catch::Session().run( argc, argv );
        -:10394:}
        -:10395:
        -:10396:#else // __OBJC__
        -:10397:
        -:10398:// Objective-C entry point
        -:10399:int main (int argc, char * const argv[]) {
        -:10400:#if !CATCH_ARC_ENABLED
        -:10401:    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
        -:10402:#endif
        -:10403:
        -:10404:    Catch::registerTestMethods();
        -:10405:    int result = Catch::Session().run( argc, (char* const*)argv );
        -:10406:
        -:10407:#if !CATCH_ARC_ENABLED
        -:10408:    [pool drain];
        -:10409:#endif
        -:10410:
        -:10411:    return result;
        -:10412:}
        -:10413:
        -:10414:#endif // __OBJC__
        -:10415:
        -:10416:#endif
        -:10417:
        -:10418:#ifdef CLARA_CONFIG_MAIN_NOT_DEFINED
        -:10419:#  undef CLARA_CONFIG_MAIN
        -:10420:#endif
        -:10421:
        -:10422://////
        -:10423:
        -:10424:// If this config identifier is defined then all CATCH macros are prefixed with CATCH_
        -:10425:#ifdef CATCH_CONFIG_PREFIX_ALL
        -:10426:
        -:10427:#define CATCH_REQUIRE( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::Normal, "CATCH_REQUIRE" )
        -:10428:#define CATCH_REQUIRE_FALSE( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, "CATCH_REQUIRE_FALSE" )
        -:10429:
        -:10430:#define CATCH_REQUIRE_THROWS( expr ) INTERNAL_CATCH_THROWS( expr, Catch::ResultDisposition::Normal, "", "CATCH_REQUIRE_THROWS" )
        -:10431:#define CATCH_REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( expr, exceptionType, Catch::ResultDisposition::Normal, "CATCH_REQUIRE_THROWS_AS" )
        -:10432:#define CATCH_REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS( expr, Catch::ResultDisposition::Normal, matcher, "CATCH_REQUIRE_THROWS_WITH" )
        -:10433:#define CATCH_REQUIRE_NOTHROW( expr ) INTERNAL_CATCH_NO_THROW( expr, Catch::ResultDisposition::Normal, "CATCH_REQUIRE_NOTHROW" )
        -:10434:
        -:10435:#define CATCH_CHECK( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::ContinueOnFailure, "CATCH_CHECK" )
        -:10436:#define CATCH_CHECK_FALSE( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, "CATCH_CHECK_FALSE" )
        -:10437:#define CATCH_CHECKED_IF( expr ) INTERNAL_CATCH_IF( expr, Catch::ResultDisposition::ContinueOnFailure, "CATCH_CHECKED_IF" )
        -:10438:#define CATCH_CHECKED_ELSE( expr ) INTERNAL_CATCH_ELSE( expr, Catch::ResultDisposition::ContinueOnFailure, "CATCH_CHECKED_ELSE" )
        -:10439:#define CATCH_CHECK_NOFAIL( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, "CATCH_CHECK_NOFAIL" )
        -:10440:
        -:10441:#define CATCH_CHECK_THROWS( expr )  INTERNAL_CATCH_THROWS( expr, Catch::ResultDisposition::ContinueOnFailure, "", "CATCH_CHECK_THROWS" )
        -:10442:#define CATCH_CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( expr, exceptionType, Catch::ResultDisposition::ContinueOnFailure, "CATCH_CHECK_THROWS_AS" )
        -:10443:#define CATCH_CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS( expr, Catch::ResultDisposition::ContinueOnFailure, matcher, "CATCH_CHECK_THROWS_WITH" )
        -:10444:#define CATCH_CHECK_NOTHROW( expr ) INTERNAL_CATCH_NO_THROW( expr, Catch::ResultDisposition::ContinueOnFailure, "CATCH_CHECK_NOTHROW" )
        -:10445:
        -:10446:#define CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( arg, matcher, Catch::ResultDisposition::ContinueOnFailure, "CATCH_CHECK_THAT" )
        -:10447:#define CATCH_REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( arg, matcher, Catch::ResultDisposition::Normal, "CATCH_REQUIRE_THAT" )
        -:10448:
        -:10449:#define CATCH_INFO( msg ) INTERNAL_CATCH_INFO( msg, "CATCH_INFO" )
        -:10450:#define CATCH_WARN( msg ) INTERNAL_CATCH_MSG( Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, "CATCH_WARN", msg )
        -:10451:#define CATCH_SCOPED_INFO( msg ) INTERNAL_CATCH_INFO( msg, "CATCH_INFO" )
        -:10452:#define CATCH_CAPTURE( msg ) INTERNAL_CATCH_INFO( #msg " := " << msg, "CATCH_CAPTURE" )
        -:10453:#define CATCH_SCOPED_CAPTURE( msg ) INTERNAL_CATCH_INFO( #msg " := " << msg, "CATCH_CAPTURE" )
        -:10454:
        -:10455:#ifdef CATCH_CONFIG_VARIADIC_MACROS
        -:10456:    #define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )
        -:10457:    #define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )
        -:10458:    #define CATCH_METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )
        -:10459:    #define CATCH_REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )
        -:10460:    #define CATCH_SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )
        -:10461:    #define CATCH_FAIL( ... ) INTERNAL_CATCH_MSG( Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, "CATCH_FAIL", __VA_ARGS__ )
        -:10462:    #define CATCH_SUCCEED( ... ) INTERNAL_CATCH_MSG( Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, "CATCH_SUCCEED", __VA_ARGS__ )
        -:10463:#else
        -:10464:    #define CATCH_TEST_CASE( name, description ) INTERNAL_CATCH_TESTCASE( name, description )
        -:10465:    #define CATCH_TEST_CASE_METHOD( className, name, description ) INTERNAL_CATCH_TEST_CASE_METHOD( className, name, description )
        -:10466:    #define CATCH_METHOD_AS_TEST_CASE( method, name, description ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, name, description )
        -:10467:    #define CATCH_REGISTER_TEST_CASE( function, name, description ) INTERNAL_CATCH_REGISTER_TESTCASE( function, name, description )
        -:10468:    #define CATCH_SECTION( name, description ) INTERNAL_CATCH_SECTION( name, description )
        -:10469:    #define CATCH_FAIL( msg ) INTERNAL_CATCH_MSG( Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, "CATCH_FAIL", msg )
        -:10470:    #define CATCH_SUCCEED( msg ) INTERNAL_CATCH_MSG( Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, "CATCH_SUCCEED", msg )
        -:10471:#endif
        -:10472:#define CATCH_ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE( "", "" )
        -:10473:
        -:10474:#define CATCH_REGISTER_REPORTER( name, reporterType ) INTERNAL_CATCH_REGISTER_REPORTER( name, reporterType )
        -:10475:#define CATCH_REGISTER_LEGACY_REPORTER( name, reporterType ) INTERNAL_CATCH_REGISTER_LEGACY_REPORTER( name, reporterType )
        -:10476:
        -:10477:#define CATCH_GENERATE( expr) INTERNAL_CATCH_GENERATE( expr )
        -:10478:
        -:10479:// "BDD-style" convenience wrappers
        -:10480:#ifdef CATCH_CONFIG_VARIADIC_MACROS
        -:10481:#define CATCH_SCENARIO( ... ) CATCH_TEST_CASE( "Scenario: " __VA_ARGS__ )
        -:10482:#define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: " __VA_ARGS__ )
        -:10483:#else
        -:10484:#define CATCH_SCENARIO( name, tags ) CATCH_TEST_CASE( "Scenario: " name, tags )
        -:10485:#define CATCH_SCENARIO_METHOD( className, name, tags ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: " name, tags )
        -:10486:#endif
        -:10487:#define CATCH_GIVEN( desc )    CATCH_SECTION( std::string( "Given: ") + desc, "" )
        -:10488:#define CATCH_WHEN( desc )     CATCH_SECTION( std::string( " When: ") + desc, "" )
        -:10489:#define CATCH_AND_WHEN( desc ) CATCH_SECTION( std::string( "  And: ") + desc, "" )
        -:10490:#define CATCH_THEN( desc )     CATCH_SECTION( std::string( " Then: ") + desc, "" )
        -:10491:#define CATCH_AND_THEN( desc ) CATCH_SECTION( std::string( "  And: ") + desc, "" )
        -:10492:
        -:10493:// If CATCH_CONFIG_PREFIX_ALL is not defined then the CATCH_ prefix is not required
        -:10494:#else
        -:10495:
        -:10496:#define REQUIRE( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::Normal, "REQUIRE" )
        -:10497:#define REQUIRE_FALSE( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, "REQUIRE_FALSE" )
        -:10498:
        -:10499:#define REQUIRE_THROWS( expr ) INTERNAL_CATCH_THROWS( expr, Catch::ResultDisposition::Normal, "", "REQUIRE_THROWS" )
        -:10500:#define REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( expr, exceptionType, Catch::ResultDisposition::Normal, "REQUIRE_THROWS_AS" )
        -:10501:#define REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS( expr, Catch::ResultDisposition::Normal, matcher, "REQUIRE_THROWS_WITH" )
        -:10502:#define REQUIRE_NOTHROW( expr ) INTERNAL_CATCH_NO_THROW( expr, Catch::ResultDisposition::Normal, "REQUIRE_NOTHROW" )
        -:10503:
        -:10504:#define CHECK( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::ContinueOnFailure, "CHECK" )
        -:10505:#define CHECK_FALSE( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, "CHECK_FALSE" )
        -:10506:#define CHECKED_IF( expr ) INTERNAL_CATCH_IF( expr, Catch::ResultDisposition::ContinueOnFailure, "CHECKED_IF" )
        -:10507:#define CHECKED_ELSE( expr ) INTERNAL_CATCH_ELSE( expr, Catch::ResultDisposition::ContinueOnFailure, "CHECKED_ELSE" )
        -:10508:#define CHECK_NOFAIL( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, "CHECK_NOFAIL" )
        -:10509:
        -:10510:#define CHECK_THROWS( expr )  INTERNAL_CATCH_THROWS( expr, Catch::ResultDisposition::ContinueOnFailure, "", "CHECK_THROWS" )
        -:10511:#define CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( expr, exceptionType, Catch::ResultDisposition::ContinueOnFailure, "CHECK_THROWS_AS" )
        -:10512:#define CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS( expr, Catch::ResultDisposition::ContinueOnFailure, matcher, "CHECK_THROWS_WITH" )
        -:10513:#define CHECK_NOTHROW( expr ) INTERNAL_CATCH_NO_THROW( expr, Catch::ResultDisposition::ContinueOnFailure, "CHECK_NOTHROW" )
        -:10514:
        -:10515:#define CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( arg, matcher, Catch::ResultDisposition::ContinueOnFailure, "CHECK_THAT" )
        -:10516:#define REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( arg, matcher, Catch::ResultDisposition::Normal, "REQUIRE_THAT" )
        -:10517:
        -:10518:#define INFO( msg ) INTERNAL_CATCH_INFO( msg, "INFO" )
        -:10519:#define WARN( msg ) INTERNAL_CATCH_MSG( Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, "WARN", msg )
        -:10520:#define SCOPED_INFO( msg ) INTERNAL_CATCH_INFO( msg, "INFO" )
        -:10521:#define CAPTURE( msg ) INTERNAL_CATCH_INFO( #msg " := " << msg, "CAPTURE" )
        -:10522:#define SCOPED_CAPTURE( msg ) INTERNAL_CATCH_INFO( #msg " := " << msg, "CAPTURE" )
        -:10523:
        -:10524:#ifdef CATCH_CONFIG_VARIADIC_MACROS
        -:10525:    #define TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )
        -:10526:    #define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )
        -:10527:    #define METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )
        -:10528:    #define REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )
        -:10529:    #define SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )
        -:10530:    #define FAIL( ... ) INTERNAL_CATCH_MSG( Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, "FAIL", __VA_ARGS__ )
        -:10531:    #define SUCCEED( ... ) INTERNAL_CATCH_MSG( Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, "SUCCEED", __VA_ARGS__ )
        -:10532:#else
        -:10533:    #define TEST_CASE( name, description ) INTERNAL_CATCH_TESTCASE( name, description )
        -:10534:    #define TEST_CASE_METHOD( className, name, description ) INTERNAL_CATCH_TEST_CASE_METHOD( className, name, description )
        -:10535:    #define METHOD_AS_TEST_CASE( method, name, description ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, name, description )
        -:10536:    #define REGISTER_TEST_CASE( method, name, description ) INTERNAL_CATCH_REGISTER_TESTCASE( method, name, description )
        -:10537:    #define SECTION( name, description ) INTERNAL_CATCH_SECTION( name, description )
        -:10538:    #define FAIL( msg ) INTERNAL_CATCH_MSG( Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, "FAIL", msg )
        -:10539:    #define SUCCEED( msg ) INTERNAL_CATCH_MSG( Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, "SUCCEED", msg )
        -:10540:#endif
        -:10541:#define ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE( "", "" )
        -:10542:
        -:10543:#define REGISTER_REPORTER( name, reporterType ) INTERNAL_CATCH_REGISTER_REPORTER( name, reporterType )
        -:10544:#define REGISTER_LEGACY_REPORTER( name, reporterType ) INTERNAL_CATCH_REGISTER_LEGACY_REPORTER( name, reporterType )
        -:10545:
        -:10546:#define GENERATE( expr) INTERNAL_CATCH_GENERATE( expr )
        -:10547:
        -:10548:#endif
        -:10549:
        -:10550:#define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature )
        -:10551:
        -:10552:// "BDD-style" convenience wrappers
        -:10553:#ifdef CATCH_CONFIG_VARIADIC_MACROS
        -:10554:#define SCENARIO( ... ) TEST_CASE( "Scenario: " __VA_ARGS__ )
        -:10555:#define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: " __VA_ARGS__ )
        -:10556:#else
        -:10557:#define SCENARIO( name, tags ) TEST_CASE( "Scenario: " name, tags )
        -:10558:#define SCENARIO_METHOD( className, name, tags ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: " name, tags )
        -:10559:#endif
        -:10560:#define GIVEN( desc )    SECTION( std::string("   Given: ") + desc, "" )
        -:10561:#define WHEN( desc )     SECTION( std::string("    When: ") + desc, "" )
        -:10562:#define AND_WHEN( desc ) SECTION( std::string("And when: ") + desc, "" )
        -:10563:#define THEN( desc )     SECTION( std::string("    Then: ") + desc, "" )
        -:10564:#define AND_THEN( desc ) SECTION( std::string("     And: ") + desc, "" )
        -:10565:
        -:10566:using Catch::Detail::Approx;
        -:10567:
        -:10568:#endif // TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED
        -:10569:
